<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsworking</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = `${w}px`;
    box.style.height = `${h}px`;
    box.dataset.id = id;
    box.dataset.fontSize = fontSize;

    // Header
    const header = document.createElement('div');
    header.classList.add('box-header');

    // Drag handle ✥
    const dragHandle = document.createElement('div');
    dragHandle.classList.add('drag-handle');
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle
    const connectToggle = document.createElement('button');
    connectToggle.classList.add('connect-toggle');
    connectToggle.title = "Toggle connection";
    header.appendChild(connectToggle);

    // Font size controls
    const fontDecBtn = document.createElement('button');
    fontDecBtn.classList.add('font-size-btn');
    fontDecBtn.textContent = '−';
    fontDecBtn.title = 'Decrease font size';

    const fontIncBtn = document.createElement('button');
    fontIncBtn.classList.add('font-size-btn');
    fontIncBtn.textContent = '+';
    fontIncBtn.title = 'Increase font size';

    header.appendChild(fontDecBtn);
    header.appendChild(fontIncBtn);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.textContent = '×';
    deleteBtn.title = "Delete box";
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content editable
    const content = document.createElement('div');
    content.classList.add('box-content');
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.classList.add('resize-handle', pos);
      box.appendChild(handle);
    });

    // Event handlers

    // Dragging
    let dragData = null;
    function onDragStart(e) {
      if (!editMode) return;
      if (e.target.closest('.resize-handle')) return; // Don't drag when resizing
      if (e.target.closest('.connect-toggle')) return; // Don't drag on connect toggle
      if (e.target.closest('.delete-btn')) return; // Don't drag on delete btn
      if (e.target.closest('.font-size-btn')) return; // Don't drag on font buttons
      e.preventDefault();
      dragData = {
        startX: e.clientX,
        startY: e.clientY,
        origX: parseFloat(box.style.left),
        origY: parseFloat(box.style.top),
      };
      if (e.shiftKey) {
        // Multi-select
        if (!selectedBoxes.has(box)) {
          selectedBoxes.forEach(b => b.classList.remove('selected'));
          selectedBoxes.clear();
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
      document.addEventListener('pointermove', onDragMove);
      document.addEventListener('pointerup', onDragEnd);
    }
    function onDragMove(e) {
      if (!dragData) return;
      const dx = e.clientX - dragData.startX;
      const dy = e.clientY - dragData.startY;
      selectedBoxes.forEach(b => {
        const origX = parseFloat(b.style.left);
        const origY = parseFloat(b.style.top);
        const newX = origX + dx / scale;
        const newY = origY + dy / scale;
        b.style.left = `${newX}px`;
        b.style.top = `${newY}px`;
      });
      drawConnections();
    }
    function onDragEnd(e) {
      if (!dragData) return;
      dragData = null;
      document.removeEventListener('pointermove', onDragMove);
      document.removeEventListener('pointerup', onDragEnd);
    }

    dragHandle.addEventListener('pointerdown', onDragStart);
    header.addEventListener('pointerdown', e => {
      if (e.target === dragHandle) return; // handled
      if (e.target.closest('.connect-toggle')) return;
      if (e.target.closest('.delete-btn')) return;
      if (e.target.closest('.font-size-btn')) return;
      if (!editMode) return;
      onDragStart(e);
    });

    // Delete box
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(id);
    });

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectToggle.classList.contains('active')) {
        connectToggle.classList.remove('active');
        connectionStartBoxId = null;
      } else {
        // deactivate all others
        canvas.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
        connectToggle.classList.add('active');
        connectionStartBoxId = id;
      }
    });

    // Clicking on box content disables multi-selection but leaves editing possible
    content.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      selectedBoxes.forEach(b => b.classList.remove('selected'));
      selectedBoxes.clear();
      box.classList.add('selected');
      selectedBoxes.add(box);
    });

    // Content changes
    content.addEventListener('input', e => {
      adjustFontSizeToFit(content, box);
    });

    // Font size controls
    fontIncBtn.addEventListener('click', e => {
      e.stopPropagation();
      let fs = parseInt(box.dataset.fontSize, 10);
      if (fs < 40) {
        fs += 1;
        box.dataset.fontSize = fs;
        content.style.fontSize = fs + 'px';
      }
    });
    fontDecBtn.addEventListener('click', e => {
      e.stopPropagation();
      let fs = parseInt(box.dataset.fontSize, 10);
      if (fs > 6) {
        fs -= 1;
        box.dataset.fontSize = fs;
        content.style.fontSize = fs + 'px';
      }
    });

    // Resize handles logic

    let resizing = false;
    let resizeDir = null;
    let resizeStart = null;
    let resizeBoxStart = null;

    function onResizePointerDown(e) {
      if (!editMode) return;
      e.stopPropagation();
      resizing = true;
      resizeDir = e.target.classList.contains('nw') ? 'nw' :
                  e.target.classList.contains('ne') ? 'ne' :
                  e.target.classList.contains('sw') ? 'sw' :
                  e.target.classList.contains('se') ? 'se' : null;
      resizeStart = { x: e.clientX, y: e.clientY };
      resizeBoxStart = {
        left: parseFloat(box.style.left),
        top: parseFloat(box.style.top),
        width: parseFloat(box.style.width),
        height: parseFloat(box.style.height)
      };
      document.addEventListener('pointermove', onResizePointerMove);
      document.addEventListener('pointerup', onResizePointerUp);
    }
    function onResizePointerMove(e) {
      if (!resizing) return;
      e.preventDefault();
      const dx = (e.clientX - resizeStart.x) / scale;
      const dy = (e.clientY - resizeStart.y) / scale;

      let newLeft = resizeBoxStart.left;
      let newTop = resizeBoxStart.top;
      let newWidth = resizeBoxStart.width;
      let newHeight = resizeBoxStart.height;

      if (resizeDir.includes('n')) {
        newHeight -= dy;
        newTop += dy;
      }
      if (resizeDir.includes('s')) {
        newHeight += dy;
      }
      if (resizeDir.includes('w')) {
        newWidth -= dx;
        newLeft += dx;
      }
      if (resizeDir.includes('e')) {
        newWidth += dx;
      }
      // enforce min sizes
      newWidth = Math.max(80, newWidth);
      newHeight = Math.max(40, newHeight);

      box.style.left = `${newLeft}px`;
      box.style.top = `${newTop}px`;
      box.style.width = `${newWidth}px`;
      box.style.height = `${newHeight}px`;

      adjustFontSizeToFit(content, box);
      drawConnections();
    }
    function onResizePointerUp(e) {
      resizing = false;
      resizeDir = null;
      document.removeEventListener('pointermove', onResizePointerMove);
      document.removeEventListener('pointerup', onResizePointerUp);
    }
    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', onResizePointerDown);
    });

    // Adding box to map and DOM
    canvas.appendChild(box);
    boxesMap.set(id, {element: box, content, header, connectToggle, fontIncBtn, fontDecBtn, deleteBtn});

    return box;
  }

  // Delete box and cleanup connections
  function deleteBox(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;

    // Save undo info
    const undoInfo = {
      boxes: new Map(boxesMap),
      connections: [...connections],
      currentMapId,
      panX,
      panY,
      scale
    };
    undoStack.push(undoInfo);
    undoBtn.disabled = false;

    // Remove box element
    boxData.element.remove();
    boxesMap.delete(id);

    // Remove related connections
    for (let i = connections.length - 1; i >= 0; i--) {
      const c = connections[i];
      if (c.from === id || c.to === id) connections.splice(i, 1);
    }
    drawConnections();
  }

  // Adjust font size so text fits inside box content area (basic approach)
  function adjustFontSizeToFit(contentEl, boxEl) {
    // For simplicity, no auto fit beyond user font size controls
    // But can add minimal font size clamp here if needed.
  }

  // Connections handling

  // Draw connections with slight curves
  function drawConnections() {
    const svg = connectionLayer;
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    connections.forEach(({from, to}) => {
      const boxA = boxesMap.get(from);
      const boxB = boxesMap.get(to);
      if (!boxA || !boxB) return;

      const aRect = boxA.element.getBoundingClientRect();
      const bRect = boxB.element.getBoundingClientRect();

      // Convert screen coordinates to canvas coordinates
      const cRect = viewport.getBoundingClientRect();

      const ax = (aRect.left + aRect.width / 2 - cRect.left - panX) / scale;
      const ay = (aRect.top + aRect.height / 2 - cRect.top - panY) / scale;

      const bx = (bRect.left + bRect.width / 2 - cRect.left - panX) / scale;
      const by = (bRect.top + bRect.height / 2 - cRect.top - panY) / scale;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const dx = bx - ax;
      const dy = by - ay;
      const curvature = 0.3; // curve factor

      const control1x = ax + dx * curvature;
      const control1y = ay;
      const control2x = bx - dx * curvature;
      const control2y = by;

      const d = `M${ax},${ay} C${control1x},${control1y} ${control2x},${control2y} ${bx},${by}`;

      path.setAttribute('d', d);
      path.setAttribute('stroke', '#222');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', 'url(#arrowhead)');

      svg.appendChild(path);
    });

    // Define arrowhead marker if missing
    if (!svg.querySelector('marker#arrowhead')) {
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '7');
      marker.setAttribute('refX', '10');
      marker.setAttribute('refY', '3.5');
      marker.setAttribute('orient', 'auto');
      marker.setAttribute('fill', '#222');

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', 'M0,0 L10,3.5 L0,7 Z');
      marker.appendChild(path);
      defs.appendChild(marker);
      svg.appendChild(defs);
    }
  }

  // Multi select logic - handled above in drag start

  // Double click creates a new box exactly at that location (adjusted for pan and scale)
  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target !== viewport && !e.target.classList.contains('box-content') && !e.target.closest('.box')) {
      const rect = viewport.getBoundingClientRect();
      const x = (e.clientX - rect.left - panX) / scale;
      const y = (e.clientY - rect.top - panY) / scale;
      const newId = generateId();
      createBox(newId, x, y);
      drawConnections();
    }
  });

  // Click on canvas deselect all
  canvas.addEventListener('pointerdown', e => {
    if (!e.shiftKey) {
      selectedBoxes.forEach(b => b.classList.remove('selected'));
      selectedBoxes.clear();
    }
  });

  // Connect toggle logic: when a blue connect toggle is active and you click another blue connect toggle,
  // create connection from start box to target box and deactivate toggles
  canvas.addEventListener('click', e => {
    if (!editMode) return;
    const toggleBtn = e.target.closest('.connect-toggle');
    if (!toggleBtn) return;
    if (!toggleBtn.classList.contains('active')) return;

    if (connectionStartBoxId) {
      const targetBox = toggleBtn.parentElement.parentElement;
      const targetBoxId = targetBox.dataset.id;
      if (targetBoxId !== connectionStartBoxId) {
        // Add connection
        if (!connections.some(c => c.from === connectionStartBoxId && c.to === targetBoxId)) {
          connections.push({from: connectionStartBoxId, to: targetBoxId});
        }
      }
      // Deactivate all toggles
      canvas.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
      connectionStartBoxId = null;
      drawConnections();
    }
  });

  // Undo delete
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const undoInfo = undoStack.pop();
    if (!undoInfo) return;

    // Clear current boxes
    boxesMap.forEach(b => b.element.remove());
    boxesMap.clear();
    connections.length = 0;

    // Restore state
    undoInfo.boxes.forEach((val, key) => {
      createBox(key, parseFloat(val.element.style.left), parseFloat(val.element.style.top),
                parseFloat(val.element.style.width), parseFloat(val.element.style.height),
                val.content.textContent, parseInt(val.element.dataset.fontSize, 10));
    });
    connections.push(...undoInfo.connections);
    currentMapId = undoInfo.currentMapId;
    panX = undoInfo.panX;
    panY = undoInfo.panY;
    scale = undoInfo.scale;
    updateTransform();
    drawConnections();

    undoBtn.disabled = undoStack.length === 0;
  });

  // Mark Center & Go to Center
  let markedCenter = {x: 0, y: 0};

  markCenterBtn.addEventListener('click', () => {
    markedCenter.x = -panX / scale;
    markedCenter.y = -panY / scale;
    updateFooterInfo(`Center marked at (${markedCenter.x.toFixed(1)}, ${markedCenter.y.toFixed(1)})`);
  });

  goCenterBtn.addEventListener('click', () => {
    panX = -markedCenter.x * scale;
    panY = -markedCenter.y * scale;
    updateTransform();
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? "Disable Edit Mode" : "Enable Edit Mode";
    boxesMap.forEach(({element, content, connectToggle, deleteBtn, fontIncBtn, fontDecBtn}) => {
      content.contentEditable = editMode;
      connectToggle.style.pointerEvents = editMode ? 'auto' : 'none';
      deleteBtn.style.pointerEvents = editMode ? 'auto' : 'none';
      fontIncBtn.style.pointerEvents = editMode ? 'auto' : 'none';
      fontDecBtn.style.pointerEvents = editMode ? 'auto' : 'none';
      element.querySelectorAll('.resize-handle').forEach(handle => {
        handle.style.pointerEvents = editMode ? 'auto' : 'none';
      });
    });
  });

  // Save and Load maps from Firebase Firestore

  async function loadMapList() {
    mapSelect.innerHTML = '';
    const querySnapshot = await getDocs(collection(db, "mindmaps"));
    querySnapshot.forEach(docSnap => {
      const option = document.createElement('option');
      option.value = docSnap.id;
      option.textContent = docSnap.data().name || docSnap.id;
      mapSelect.appendChild(option);
      mapsCache.set(docSnap.id, docSnap.data());
    });
    if (mapSelect.options.length > 0) {
      currentMapId = mapSelect.options[0].value;
      mapSelect.value = currentMapId;
      await loadMap(currentMapId);
    } else {
      createNewMap();
    }
  }

  async function loadMap(id) {
    if (!id) return;
    currentMapId = id;
    const docRef = doc(db, "mindmaps", id);
    const docSnap = await getDoc(docRef);
    if (!docSnap.exists()) return;

    const data = docSnap.data();
    // Clear existing
    boxesMap.forEach(b => b.element.remove());
    boxesMap.clear();
    connections.length = 0;

    if (data.boxes) {
      for (const boxId in data.boxes) {
        const boxData = data.boxes[boxId];
        createBox(boxId, boxData.x, boxData.y, boxData.w, boxData.h, boxData.text, boxData.fontSize || 14);
      }
    }
    if (data.connections) {
      data.connections.forEach(c => connections.push(c));
    }
    panX = data.panX ?? 0;
    panY = data.panY ?? 0;
    scale = data.scale ?? 1;
    updateTransform();
    drawConnections();
    updateSaveStatus("Map loaded.");
  }

  async function saveMap() {
    if (!currentMapId) {
      updateSaveStatus("No map selected.");
      return;
    }
    const boxesData = {};
    boxesMap.forEach(({element, content}, id) => {
      boxesData[id] = {
        x: parseFloat(element.style.left),
        y: parseFloat(element.style.top),
        w: parseFloat(element.style.width),
        h: parseFloat(element.style.height),
        text: content.textContent,
        fontSize: parseInt(element.dataset.fontSize, 10)
      };
    });
    const dataToSave = {
      name: mapSelect.options[mapSelect.selectedIndex]?.textContent || currentMapId,
      boxes: boxesData,
      connections: connections,
      panX,
      panY,
      scale,
      updatedAt: new Date().toISOString()
    };
    try {
      await setDoc(doc(db, "mindmaps", currentMapId), dataToSave);
      updateSaveStatus("Saved successfully.");
      mapsCache.set(currentMapId, dataToSave);
    } catch (err) {
      updateSaveStatus("Error saving map.");
      console.error(err);
    }
  }

  // Rename map prompt
  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    const newName = prompt("Enter new map name:", mapSelect.options[mapSelect.selectedIndex]?.textContent || currentMapId);
    if (!newName) return;
    // Save name change locally & remotely
    const cached = mapsCache.get(currentMapId) || {};
    cached.name = newName;
    try {
      await setDoc(doc(db, "mindmaps", currentMapId), cached);
      mapsCache.set(currentMapId, cached);
      loadMapList();
      updateSaveStatus("Map renamed.");
    } catch (err) {
      updateSaveStatus("Error renaming map.");
      console.error(err);
    }
  });

  // Delete map prompt
  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    if (!confirm(`Delete map "${mapSelect.options[mapSelect.selectedIndex]?.textContent || currentMapId}"? This cannot be undone.`)) return;
    try {
      await deleteDoc(doc(db, "mindmaps", currentMapId));
      mapsCache.delete(currentMapId);
      updateSaveStatus("Map deleted.");
      await loadMapList();
    } catch (err) {
      updateSaveStatus("Error deleting map.");
      console.error(err);
    }
  });

  // New map
  newMapBtn.addEventListener('click', () => {
    const newName = prompt("Enter new map name:");
    if (!newName) return;
    const newId = generateId();
    currentMapId = newId;
    mapSelect.value = newId;
    createNewMap(newId, newName);
  });

  async function createNewMap(id = generateId(), name = "New Map") {
    // Clear current
    boxesMap.forEach(b => b.element.remove());
    boxesMap.clear();
    connections.length = 0;
    panX = 0;
    panY = 0;
    scale = 1;
    updateTransform();
    drawConnections();

    // Save new map
    const data = {
      name,
      boxes: {},
      connections: [],
      panX: 0,
      panY: 0,
      scale: 1,
      createdAt: new Date().toISOString()
    };
    try {
      await setDoc(doc(db, "mindmaps", id), data);
      mapsCache.set(id, data);
      await loadMapList();
      mapSelect.value = id;
      currentMapId = id;
      updateSaveStatus("New map created.");
    } catch (err) {
      updateSaveStatus("Error creating new map.");
      console.error(err);
    }
  }

  mapSelect.addEventListener('change', async () => {
    const id = mapSelect.value;
    await loadMap(id);
  });

  saveMapBtn.addEventListener('click', () => saveMap());

  // Save status updates
  function updateSaveStatus(msg) {
    saveStatus.textContent = msg;
    setTimeout(() => {
      if (saveStatus.textContent === msg) saveStatus.textContent = '';
    }, 5000);
  }

  // Footer info display for mark center
  const footerInfo = document.createElement('div');
  footerInfo.id = 'footerInfo';
  document.body.appendChild(footerInfo);

  function updateFooterInfo(text) {
    footerInfo.textContent = text;
    setTimeout(() => {
      footerInfo.textContent = '';
    }, 3000);
  }

  // Initialize

  (async function init() {
    await loadMapList();
    updateTransform();
    drawConnections();
  })();

</script>

</body>
</html>
