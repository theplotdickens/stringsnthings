<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9ea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    let oldScale = scale;
    if (e.deltaY < 0) scale *= 1.1;
    else scale /= 1.1;
    scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale));
    // Adjust pan to zoom to mouse pointer
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    panX -= (mx / oldScale - mx / scale);
    panY -= (my / oldScale - my / scale);
    updateTransform();
    updateZoomDisplay();
  }, { passive: false });

  function updateZoomDisplay() {
    let zoomDisplay = document.getElementById('zoomDisplay');
    if (!zoomDisplay) {
      zoomDisplay = document.createElement('div');
      zoomDisplay.id = 'zoomDisplay';
      document.body.appendChild(zoomDisplay);
    }
    zoomDisplay.textContent = `Zoom: ${(scale * 100).toFixed(0)}%`;
  }
  updateZoomDisplay();

  // Box creation

  function createBox({id = null, x = 100, y = 100, width = 140, height = 80, text = '', fontSize = 14, connected = false} = {}) {
    const box = document.createElement('div');
    box.className = 'box';
    if (id) box.dataset.id = id;
    else box.dataset.id = generateId();

    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = `${width}px`;
    box.style.height = `${height}px`;
    box.style.fontSize = fontSize + 'px';

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';
    box.appendChild(header);

    // Drag handle ✥
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle button (blue/green circle)
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    if (connected) connectToggle.classList.add('active');
    connectToggle.title = 'Toggle connection mode';
    header.appendChild(connectToggle);

    // Font size buttons +
    const fontUpBtn = document.createElement('button');
    fontUpBtn.className = 'font-size-btn';
    fontUpBtn.textContent = '+';
    fontUpBtn.title = 'Increase font size';
    header.appendChild(fontUpBtn);

    // Font size buttons −
    const fontDownBtn = document.createElement('button');
    fontDownBtn.className = 'font-size-btn';
    fontDownBtn.textContent = '−';
    fontDownBtn.title = 'Decrease font size';
    header.appendChild(fontDownBtn);

    // Delete button red x
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Delete this box';
    header.appendChild(deleteBtn);

    // Content editable
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.textContent = text;
    box.appendChild(content);

    // Resize handles (corners)
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    canvas.appendChild(box);

    boxesMap.set(box.dataset.id, {element: box, content, header, dragHandle, connectToggle, fontUpBtn, fontDownBtn, deleteBtn});

    // Event listeners

    // Delete
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(box.dataset.id);
    });

    // Dragging for box - on drag handle only
    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.stopPropagation();
      startDragBox(e, box);
    });

    // Shift+click to multi-select on header or drag handle
    header.addEventListener('click', e => {
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
        e.stopPropagation();
      }
    });

    // Connect toggle click
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (!connectToggle.classList.contains('active')) {
        // Activate connection start
        clearConnectStart();
        connectToggle.classList.add('active');
        connectionStartBoxId = box.dataset.id;
      } else {
        // Cancel connection start
        clearConnectStart();
      }
    });

    // Click on box content disables connections
    content.addEventListener('click', e => {
      if (connectionStartBoxId !== null) {
        // Trying to connect
        const targetId = box.dataset.id;
        if (connectionStartBoxId !== targetId) {
          addConnection(connectionStartBoxId, targetId, '');
          clearConnectStart();
        }
      }
    });

    // Font size change buttons
    fontUpBtn.addEventListener('click', e => {
      e.stopPropagation();
      changeFontSize(box, 1);
    });
    fontDownBtn.addEventListener('click', e => {
      e.stopPropagation();
      changeFontSize(box, -1);
    });

    // Content editable toggle when toggling edit mode
    content.contentEditable = editMode;

    // Resizing
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = box.querySelector(`.resize-handle.${pos}`);
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        startResizeBox(e, box, pos);
      });
    });

    // Drag multi-select move support
    box.addEventListener('pointerdown', e => {
      if (!editMode) return;
      if (selectedBoxes.has(box)) {
        if (!e.shiftKey && !e.target.classList.contains('drag-handle') && !e.target.classList.contains('box-header')) return;
        e.stopPropagation();
        startDragMultiBoxes(e);
      }
    });

    // Text input autosize and center content
    content.addEventListener('input', () => {
      adjustBoxSize(box);
    });

    adjustBoxSize(box);
    return box;
  }

  // Resize box to fit content but keep min sizes and center text
  function adjustBoxSize(box) {
    const content = box.querySelector('.box-content');
    const style = getComputedStyle(content);
    const lineHeight = parseFloat(style.lineHeight) || 16;
    // We let box size remain manually resizable but adjust height if content is smaller
    const minHeight = 40;
    const minWidth = 80;
    const scrollHeight = content.scrollHeight;
    const scrollWidth = content.scrollWidth;
    const newHeight = Math.max(minHeight, scrollHeight + 6);
    const newWidth = Math.max(minWidth, scrollWidth + 12);
    box.style.height = newHeight + 'px';
    box.style.width = newWidth + 'px';

    // Center text horizontally and vertically by flex on box-content
    content.style.justifyContent = 'center';
    content.style.alignItems = 'center';
  }

  // Change font size of box text content
  function changeFontSize(box, delta) {
    const currentSize = parseInt(box.style.fontSize) || 14;
    let newSize = currentSize + delta;
    newSize = Math.min(48, Math.max(8, newSize));
    box.style.fontSize = newSize + 'px';
  }

  // Drag box support

  let dragData = null;

  function startDragBox(e, box) {
    if (!editMode) return;
    if (selectedBoxes.size > 1 && selectedBoxes.has(box)) {
      startDragMultiBoxes(e);
      return;
    }
    dragData = {
      startX: e.clientX,
      startY: e.clientY,
      box,
      origLeft: parseFloat(box.style.left),
      origTop: parseFloat(box.style.top),
      draggingMulti: false,
    };
    window.addEventListener('pointermove', dragBoxMove);
    window.addEventListener('pointerup', dragBoxEnd);
  }
  function dragBoxMove(e) {
    if (!dragData) return;
    const dx = (e.clientX - dragData.startX) / scale;
    const dy = (e.clientY - dragData.startY) / scale;
    dragData.box.style.left = (dragData.origLeft + dx) + 'px';
    dragData.box.style.top = (dragData.origTop + dy) + 'px';
    drawConnections();
  }
  function dragBoxEnd(e) {
    if (!dragData) return;
    // Save position to box data
    dragData = null;
    window.removeEventListener('pointermove', dragBoxMove);
    window.removeEventListener('pointerup', dragBoxEnd);
  }

  // Multi box drag support

  let multiDragData = null;

  function startDragMultiBoxes(e) {
    if (!editMode) return;
    multiDragData = {
      startX: e.clientX,
      startY: e.clientY,
      boxes: Array.from(selectedBoxes).map(box => ({
        element: box,
        origLeft: parseFloat(box.style.left),
        origTop: parseFloat(box.style.top)
      })),
    };
    window.addEventListener('pointermove', dragMultiBoxesMove);
    window.addEventListener('pointerup', dragMultiBoxesEnd);
  }
  function dragMultiBoxesMove(e) {
    if (!multiDragData) return;
    const dx = (e.clientX - multiDragData.startX) / scale;
    const dy = (e.clientY - multiDragData.startY) / scale;
    multiDragData.boxes.forEach(({element, origLeft, origTop}) => {
      element.style.left = (origLeft + dx) + 'px';
      element.style.top = (origTop + dy) + 'px';
    });
    drawConnections();
  }
  function dragMultiBoxesEnd(e) {
    if (!multiDragData) return;
    multiDragData = null;
    window.removeEventListener('pointermove', dragMultiBoxesMove);
    window.removeEventListener('pointerup', dragMultiBoxesEnd);
  }

  // Resize box support

  let resizeData = null;

  function startResizeBox(e, box, corner) {
    if (!editMode) return;
    resizeData = {
      startX: e.clientX,
      startY: e.clientY,
      box,
      corner,
      origLeft: parseFloat(box.style.left),
      origTop: parseFloat(box.style.top),
      origWidth: parseFloat(box.style.width),
      origHeight: parseFloat(box.style.height),
    };
    window.addEventListener('pointermove', resizeBoxMove);
    window.addEventListener('pointerup', resizeBoxEnd);
  }
  function resizeBoxMove(e) {
    if (!resizeData) return;
    const dx = (e.clientX - resizeData.startX) / scale;
    const dy = (e.clientY - resizeData.startY) / scale;
    let newLeft = resizeData.origLeft;
    let newTop = resizeData.origTop;
    let newWidth = resizeData.origWidth;
    let newHeight = resizeData.origHeight;

    if (resizeData.corner.includes('n')) {
      newHeight = resizeData.origHeight - dy;
      newTop = resizeData.origTop + dy;
      if (newHeight < 40) {
        newHeight = 40;
        newTop = resizeData.origTop + (resizeData.origHeight - 40);
      }
    }
    if (resizeData.corner.includes('s')) {
      newHeight = resizeData.origHeight + dy;
      if (newHeight < 40) newHeight = 40;
    }
    if (resizeData.corner.includes('w')) {
      newWidth = resizeData.origWidth - dx;
      newLeft = resizeData.origLeft + dx;
      if (newWidth < 80) {
        newWidth = 80;
        newLeft = resizeData.origLeft + (resizeData.origWidth - 80);
      }
    }
    if (resizeData.corner.includes('e')) {
      newWidth = resizeData.origWidth + dx;
      if (newWidth < 80) newWidth = 80;
    }

    resizeData.box.style.left = newLeft + 'px';
    resizeData.box.style.top = newTop + 'px';
    resizeData.box.style.width = newWidth + 'px';
    resizeData.box.style.height = newHeight + 'px';
    adjustBoxSize(resizeData.box);
    drawConnections();
  }
  function resizeBoxEnd(e) {
    if (!resizeData) return;
    resizeData = null;
    window.removeEventListener('pointermove', resizeBoxMove);
    window.removeEventListener('pointerup', resizeBoxEnd);
  }

  // Delete box

  function deleteBox(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    const elem = boxData.element;
    undoStack.push({
      type: 'deleteBox',
      boxData: {
        id,
        x: parseFloat(elem.style.left),
        y: parseFloat(elem.style.top),
        width: parseFloat(elem.style.width),
        height: parseFloat(elem.style.height),
        text: boxData.content.textContent,
        fontSize: parseInt(elem.style.fontSize) || 14,
        connected: boxData.connectToggle.classList.contains('active'),
      },
      connections: connections.filter(c => c.from === id || c.to === id),
    });
    undoBtn.disabled = false;

    // Remove connections related to this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }

    elem.remove();
    boxesMap.delete(id);
    drawConnections();
  }

  // Undo support

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    if (last.type === 'deleteBox') {
      const b = last.boxData;
      const box = createBox({
        id: b.id,
        x: b.x,
        y: b.y,
        width: b.width,
        height: b.height,
        text: b.text,
        fontSize: b.fontSize,
        connected: b.connected,
      });
      last.connections.forEach(c => connections.push({...c}));
      drawConnections();
    }
    undoBtn.disabled = undoStack.length === 0;
  });

  // Connections handling

  function addConnection(fromId, toId, label = '') {
    if (connections.some(c => c.from === fromId && c.to === toId)) return; // no duplicates
    connections.push({from: fromId, to: toId, label});
    drawConnections();
  }

  function clearConnectStart() {
    connectionStartBoxId = null;
    // Remove active class from all connect toggles
    boxesMap.forEach(({connectToggle}) => connectToggle.classList.remove('active'));
  }

  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.firstChild.remove();
    connections.forEach(({from, to, label}) => {
      const fromBox = boxesMap.get(from);
      const toBox = boxesMap.get(to);
      if (!fromBox || !toBox) return;
      const fromRect = fromBox.element.getBoundingClientRect();
      const toRect = toBox.element.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      // Calculate points relative to viewport + scroll
      const startX = (fromRect.left + fromRect.width / 2) - vpRect.left;
      const startY = (fromRect.top + fromRect.height / 2) - vpRect.top;
      const endX = (toRect.left + toRect.width / 2) - vpRect.left;
      const endY = (toRect.top + toRect.height / 2) - vpRect.top;

      // Create SVG path with a cubic Bezier curve
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("stroke", "black");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-width", "2");
      const dx = endX - startX;
      const dy = endY - startY;
      const mx = startX + dx / 2;
      const my = startY + dy / 2;
      const pathData = `M${startX},${startY} C${mx},${startY} ${mx},${endY} ${endX},${endY}`;
      path.setAttribute("d", pathData);
      connectionLayer.appendChild(path);

      if (label) {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", mx);
        text.setAttribute("y", my - 5);
        text.setAttribute("font-size", "12");
        text.setAttribute("font-family", "monospace");
        text.setAttribute("text-anchor", "middle");
        text.textContent = label;
        connectionLayer.appendChild(text);
      }
    });
  }

  // Clear canvas

  function clearCanvas() {
    boxesMap.forEach(({element}) => element.remove());
    boxesMap.clear();
    connections.length = 0;
    drawConnections();
  }

  // Save map to Firestore

  async function saveMap() {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    const mapData = {
      name: mapSelect.options[mapSelect.selectedIndex]?.text || 'Unnamed Map',
      boxes: [],
      connections: [...connections],
      center: { panX, panY, scale },
      timestamp: new Date().toISOString(),
    };
    boxesMap.forEach(({element, content}) => {
      mapData.boxes.push({
        id: element.dataset.id,
        x: parseFloat(element.style.left),
        y: parseFloat(element.style.top),
        width: parseFloat(element.style.width),
        height: parseFloat(element.style.height),
        text: content.textContent,
        fontSize: parseInt(element.style.fontSize) || 14,
        connected: element.querySelector('.connect-toggle').classList.contains('active'),
      });
    });
    try {
      await setDoc(doc(db, "maps", currentMapId), mapData);
      saveStatus.textContent = 'Saved';
      setTimeout(() => saveStatus.textContent = '', 2000);
      mapsCache.set(currentMapId, mapData);
      refreshMapSelect();
    } catch (e) {
      alert('Error saving map: ' + e.message);
    }
  }

  // Load all maps list into dropdown

  async function refreshMapSelect() {
    try {
      const querySnapshot = await getDocs(collection(db, "maps"));
      mapSelect.innerHTML = '';
      mapsCache.clear();
      querySnapshot.forEach(docSnap => {
        const data = docSnap.data();
        mapsCache.set(docSnap.id, data);
      });
      // Sort by name alphabetically
      const sorted = Array.from(mapsCache.entries()).sort((a, b) => {
        const nameA = a[1].name.toLowerCase();
        const nameB = b[1].name.toLowerCase();
        return nameA.localeCompare(nameB);
      });
      sorted.forEach(([id, data]) => {
        const option = document.createElement('option');
        option.value = id;
        option.textContent = data.name;
        mapSelect.appendChild(option);
      });
      if (currentMapId && mapsCache.has(currentMapId)) {
        mapSelect.value = currentMapId;
      } else if (sorted.length > 0) {
        currentMapId = sorted[0][0];
        mapSelect.value = currentMapId;
      } else {
        currentMapId = null;
      }
    } catch (e) {
      alert('Error loading map list: ' + e.message);
    }
  }

  // Load selected map into canvas

  async function loadMap(id) {
    if (!id) return;
    clearCanvas();
    currentMapId = id;
    const mapData = mapsCache.get(id);
    if (!mapData) {
      try {
        // If not cached, get from Firestore
        const docSnap = await getDoc(doc(db, "maps", id));
        if (!docSnap.exists()) {
          alert("Map not found.");
          return;
        }
        mapsCache.set(id, docSnap.data());
        await loadMap(id); // recursive call to load after caching
        return;
      } catch (e) {
        alert('Error loading map: ' + e.message);
        return;
      }
    }
    // Apply center
    panX = mapData.center?.panX ?? 0;
    panY = mapData.center?.panY ?? 0;
    scale = mapData.center?.scale ?? 1;
    updateTransform();

    // Create boxes
    mapData.boxes.forEach(b => {
      createBox(b);
    });

    // Set connections
    connections.length = 0;
    if (mapData.connections) {
      mapData.connections.forEach(c => connections.push(c));
    }
    drawConnections();

    saveStatus.textContent = 'Loaded';
    setTimeout(() => saveStatus.textContent = '', 2000);
  }

  // Rename map

  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    const newName = prompt('Enter new name for map:', mapsCache.get(currentMapId)?.name || '');
    if (newName === null) return; // cancelled
    if (newName.trim() === '') {
      alert('Name cannot be empty');
      return;
    }
    try {
      const mapData = mapsCache.get(currentMapId);
      mapData.name = newName.trim();
      await setDoc(doc(db, "maps", currentMapId), mapData);
      mapsCache.set(currentMapId, mapData);
      refreshMapSelect();
    } catch (e) {
      alert('Error renaming map: ' + e.message);
    }
  });

  // Delete map

  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    if (!confirm(`Delete map "${mapsCache.get(currentMapId)?.name}"? This cannot be undone.`)) return;
    try {
      await deleteDoc(doc(db, "maps", currentMapId));
      mapsCache.delete(currentMapId);
      await refreshMapSelect();
      if (mapSelect.options.length > 0) {
        await loadMap(mapSelect.value);
      } else {
        clearCanvas();
        currentMapId = null;
      }
    } catch (e) {
      alert('Error deleting map: ' + e.message);
    }
  });

  // Create new map

  newMapBtn.addEventListener('click', async () => {
    const newName = prompt('Enter name for new map:', 'Untitled Map');
    if (!newName) return;
    const newId = generateId();
    const newMapData = {
      name: newName.trim(),
      boxes: [],
      connections: [],
      center: { panX: 0, panY: 0, scale: 1 },
      timestamp: new Date().toISOString(),
    };
    try {
      await setDoc(doc(db, "maps", newId), newMapData);
      mapsCache.set(newId, newMapData);
      currentMapId = newId;
      await refreshMapSelect();
      await loadMap(newId);
    } catch (e) {
      alert('Error creating new map: ' + e.message);
    }
  });

  // Load map on selection change

  mapSelect.addEventListener('change', e => {
    loadMap(e.target.value);
  });

  // Buttons bottom container

  goCenterBtn.addEventListener('click', () => {
    panX = 0;
    panY = 0;
    scale = 1;
    updateTransform();
    updateZoomDisplay();
  });

  markCenterBtn.addEventListener('click', () => {
    alert(`Current center saved:\npanX: ${panX}\npamY: ${panY}\nscale: ${scale}`);
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'Toggle View Mode';
    boxesMap.forEach(({content, connectToggle}) => {
      content.contentEditable = editMode;
      connectToggle.disabled = !editMode;
    });
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });

  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Create box on double click if in edit mode

  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target !== viewport && e.target !== canvas) return;
    // Calculate position relative to canvas coords
    const rect = viewport.getBoundingClientRect();
    const cx = (e.clientX - rect.left - panX) / scale;
    const cy = (e.clientY - rect.top - panY) / scale;
    createBox({x: cx, y: cy});
  });

  // Initialization

  (async () => {
    await refreshMapSelect();
    if (mapSelect.options.length > 0) {
      await loadMap(mapSelect.value);
    } else {
      currentMapId = null;
    }
  })();

</script>

</body>
</html>
