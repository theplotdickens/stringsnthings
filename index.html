<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV4-full</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
      padding-top: 50px; /* for top menu */
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    /* Top menu styling */
    #topMenu {
      position: fixed;
      top: 0; left: 50%;
      transform: translateX(-50%);
      height: 40px;
      background: #ddd;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 12px;
      border-bottom: 1px solid #bbb;
      box-sizing: border-box;
      z-index: 1100;
      font-family: monospace, monospace;
    }
    #mindMapSelect {
      font-size: 14px;
      padding: 4px 8px;
    }
    #renameInput {
      font-size: 14px;
      padding: 4px 8px;
      width: 200px;
    }
    #savedMessage {
      margin-left: 12px;
      color: green;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.5s ease;
      user-select: none;
      font-size: 14px;
      white-space: nowrap;
    }
    #topMenu button {
      font-family: monospace, monospace;
      font-size: 14px;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
      border: 1px solid #888;
      border-radius: 3px;
      background: white;
      transition: background-color 0.3s ease;
    }
    #topMenu button:hover {
      background-color: #ccc;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mindMapSelect" title="Select Mind Map"></select>
    <input type="text" id="renameInput" placeholder="Rename selected mind map" />
    <button id="renameBtn" title="Rename selected mind map">Rename</button>
    <button id="deleteBtn" title="Delete selected mind map">Delete</button>
    <span id="savedMessage">Saved ✔</span>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      **New:** Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the top menu to select, rename, or delete mind maps.
      Selecting a mind map from the dropdown automatically loads it.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-app.js";
  import {
    getFirestore, collection, doc,
    setDoc, getDoc, getDocs,
    updateDoc, deleteDoc
  } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-firestore.js";

  // Your Firebase config - update as needed
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM references
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const connectionLayer = document.getElementById('connectionLayer');
  const mindMapSelect = document.getElementById('mindMapSelect');
  const renameInput = document.getElementById('renameInput');
  const renameBtn = document.getElementById('renameBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const savedMessage = document.getElementById('savedMessage');

  // State variables
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;
  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();
  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMindMapId = null;
  const mindMapsCollection = collection(db, 'mindmaps');

  // Utils
  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  // Transform & viewport
  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Panning & zooming
  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, mindMapSelect, renameInput, renameBtn, deleteBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // Deselect on background click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  // Double click adds box
  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, mindMapSelect, renameInput, renameBtn, deleteBtn].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  // Mark center button - saves center position to Firestore under current map
  markCenterBtn.addEventListener('click', async () => {
    if (!currentMindMapId) {
      alert('No mind map loaded.');
      return;
    }
    const rect = viewport.getBoundingClientRect();
    const centerX = (rect.width / 2 - panX) / scale;
    const centerY = (rect.height / 2 - panY) / scale;
    try {
      await updateDoc(doc(mindMapsCollection, currentMindMapId), { center: { x: centerX, y: centerY } });
      alert('Center marked at: ' + Math.round(centerX) + ', ' + Math.round(centerY));
    } catch (err) {
      alert('Error saving center: ' + err.message);
    }
  });

  // Go center button - moves viewport to saved center if any
  goCenterBtn.addEventListener('click', async () => {
    if (!currentMindMapId) return;
    try {
      const snap = await getDoc(doc(mindMapsCollection, currentMindMapId));
      if (!snap.exists()) return;
      const data = snap.data();
      if (data.center) {
        const rect = viewport.getBoundingClientRect();
        panX = rect.width / 2 - data.center.x * scale;
        panY = rect.height / 2 - data.center.y * scale;
        updateTransform();
      } else {
        alert('No center saved for this mind map.');
      }
    } catch (err) {
      alert('Error loading center: ' + err.message);
    }
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
    boxesMap.forEach(box => {
      box.content.contentEditable = editMode;
      if (editMode) {
        box.header.style.cursor = 'default';
      } else {
        box.header.style.cursor = 'default';
      }
    });
  });

  // How To Modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Add new box function
  function addBox(x, y, id = null, text = '', fontSize = 16, width = 120, height = 60) {
    if (!editMode) return;
    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.style.fontSize = fontSize + 'px';

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';
    // Drag handle
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect this box';
    header.appendChild(connectToggle);

    // Delete button
    const deleteBtnBox = document.createElement('button');
    deleteBtnBox.className = 'delete-btn';
    deleteBtnBox.title = 'Delete this box';
    deleteBtnBox.textContent = '×';
    header.appendChild(deleteBtnBox);

    box.appendChild(header);

    // Content editable area
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.textContent = text;
    box.appendChild(content);

    // Font size controls
    const fontControls = document.createElement('div');
    fontControls.style.display = 'flex';
    fontControls.style.justifyContent = 'center';
    fontControls.style.gap = '4px';
    fontControls.style.padding = '2px 0';

    const minusBtn = document.createElement('button');
    minusBtn.className = 'font-size-btn';
    minusBtn.title = 'Decrease font size';
    minusBtn.textContent = '−'; // just minus sign, no A
    fontControls.appendChild(minusBtn);

    const plusBtn = document.createElement('button');
    plusBtn.className = 'font-size-btn';
    plusBtn.title = 'Increase font size';
    plusBtn.textContent = '+'; // just plus sign, no A
    fontControls.appendChild(plusBtn);

    box.appendChild(fontControls);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + corner;
      box.appendChild(handle);
    });

    canvas.appendChild(box);

    // Store box info
    const boxData = {
      id: id || crypto.randomUUID(),
      element: box,
      header,
      dragHandle,
      connectToggle,
      deleteBtn: deleteBtnBox,
      content,
      fontSize,
      width,
      height,
      x,
      y
    };
    boxesMap.set(boxData.id, boxData);

    // Event handlers
    setupBoxEvents(boxData);

    return boxData.id;
  }

  // Setup event handlers for a box
  function setupBoxEvents(boxData) {
    const { element, header, dragHandle, connectToggle, deleteBtn, content } = boxData;

    // Dragging box by drag handle or shift+click header for multi-select
    let dragging = false;
    let dragStartX, dragStartY;
    let boxStartX, boxStartY;

    function dragStart(e) {
      if (!editMode) return;
      if (e.shiftKey && e.target.closest('.box-header')) {
        // Multi select toggle
        if (selectedBoxes.has(element)) {
          selectedBoxes.delete(element);
          element.classList.remove('selected');
        } else {
          selectedBoxes.add(element);
          element.classList.add('selected');
        }
        e.preventDefault();
        return;
      }
      if (e.target === dragHandle) {
        dragging = true;
        const coords = getClientCoords(e);
        dragStartX = coords.x;
        dragStartY = coords.y;
        boxStartX = parseFloat(element.style.left);
        boxStartY = parseFloat(element.style.top);
        if (!selectedBoxes.has(element)) {
          selectedBoxes.forEach(b => b.classList.remove('selected'));
          selectedBoxes.clear();
          selectedBoxes.add(element);
          element.classList.add('selected');
        }
        element.setPointerCapture(e.pointerId);
      }
    }
    function dragMove(e) {
      if (!dragging) return;
      e.preventDefault();
      const coords = getClientCoords(e);
      const dx = coords.x - dragStartX;
      const dy = coords.y - dragStartY;
      selectedBoxes.forEach(el => {
        const boxData = [...boxesMap.values()].find(b => b.element === el);
        if (!boxData) return;
        const newX = boxData.x + dx / scale;
        const newY = boxData.y + dy / scale;
        boxData.x = newX;
        boxData.y = newY;
        el.style.left = newX + 'px';
        el.style.top = newY + 'px';
      });
      drawConnections();
    }
    function dragEnd(e) {
      if (!dragging) return;
      dragging = false;
      selectedBoxes.forEach(el => {
        const boxData = [...boxesMap.values()].find(b => b.element === el);
        if (!boxData) return;
        boxData.x = parseFloat(el.style.left);
        boxData.y = parseFloat(el.style.top);
      });
      element.releasePointerCapture(e.pointerId);
      saveCurrentMindMap();
    }
    dragHandle.addEventListener('pointerdown', dragStart);
    dragHandle.addEventListener('pointermove', dragMove);
    dragHandle.addEventListener('pointerup', dragEnd);
    dragHandle.addEventListener('pointercancel', dragEnd);

    // Connect toggle
    connectToggle.addEventListener('click', () => {
      if (!editMode) return;
      if (connectionStartBoxId === boxData.id) {
        // Cancel connection mode
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (connectionStartBoxId === null) {
        // Start connection from this box
        connectionStartBoxId = boxData.id;
        connectToggle.classList.add('active');
      } else {
        // Connect start box to this box
        connections.push({ from: connectionStartBoxId, to: boxData.id });
        // Remove active state from start box toggle
        const startBox = boxesMap.get(connectionStartBoxId);
        if (startBox) startBox.connectToggle.classList.remove('active');
        connectionStartBoxId = null;
        drawConnections();
        saveCurrentMindMap();
      }
    });

    // Delete button
    deleteBtn.addEventListener('click', () => {
      if (!editMode) return;
      deleteBox(boxData.id);
    });

    // Font size buttons
    const minusBtn = element.querySelector('.font-size-btn:nth-child(1)');
    const plusBtn = element.querySelector('.font-size-btn:nth-child(2)');
    if (minusBtn && plusBtn) {
      minusBtn.addEventListener('click', () => {
        if (!editMode) return;
        if (boxData.fontSize > 6) {
          boxData.fontSize -= 1;
          element.style.fontSize = boxData.fontSize + 'px';
          saveCurrentMindMap();
        }
      });
      plusBtn.addEventListener('click', () => {
        if (!editMode) return;
        if (boxData.fontSize < 72) {
          boxData.fontSize += 1;
          element.style.fontSize = boxData.fontSize + 'px';
          saveCurrentMindMap();
        }
      });
    }

    // Content change handler to save
    content.addEventListener('input', () => {
      if (!editMode) return;
      saveCurrentMindMap();
    });

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = element.querySelector('.resize-handle.' + corner);
      let resizing = false;
      let resizeStartX, resizeStartY;
      let startWidth, startHeight;
      let startLeft, startTop;

      function resizeStart(e) {
        if (!editMode) return;
        resizing = true;
        const coords = getClientCoords(e);
        resizeStartX = coords.x;
        resizeStartY = coords.y;
        startWidth = element.offsetWidth;
        startHeight = element.offsetHeight;
        startLeft = parseFloat(element.style.left);
        startTop = parseFloat(element.style.top);
        e.preventDefault();
        element.setPointerCapture(e.pointerId);
      }
      function resizeMove(e) {
        if (!resizing) return;
        e.preventDefault();
        const coords = getClientCoords(e);
        const dx = (coords.x - resizeStartX) / scale;
        const dy = (coords.y - resizeStartY) / scale;
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;
        if (corner.includes('e')) newWidth = Math.max(40, startWidth + dx);
        if (corner.includes('s')) newHeight = Math.max(24, startHeight + dy);
        if (corner.includes('w')) {
          newWidth = Math.max(40, startWidth - dx);
          newLeft = startLeft + dx;
        }
        if (corner.includes('n')) {
          newHeight = Math.max(24, startHeight - dy);
          newTop = startTop + dy;
        }
        element.style.width = newWidth + 'px';
        element.style.height = newHeight + 'px';
        element.style.left = newLeft + 'px';
        element.style.top = newTop + 'px';

        boxData.width = newWidth;
        boxData.height = newHeight;
        boxData.x = newLeft;
        boxData.y = newTop;

        drawConnections();
      }
      function resizeEnd(e) {
        if (!resizing) return;
        resizing = false;
        element.releasePointerCapture(e.pointerId);
        saveCurrentMindMap();
      }

      handle.addEventListener('pointerdown', resizeStart);
      handle.addEventListener('pointermove', resizeMove);
      handle.addEventListener('pointerup', resizeEnd);
      handle.addEventListener('pointercancel', resizeEnd);
    });

    // Header shift+click for multi-select (already handled in dragStart)
  }

  // Delete box function
  function deleteBox(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    // Remove element
    canvas.removeChild(boxData.element);
    boxesMap.delete(id);

    // Remove any connections related to this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    undoStack.push({ action: 'delete', boxData, connectionsSnapshot: [...connections] });
    undoBtn.disabled = false;
    saveCurrentMindMap();
    drawConnections();
  }

  // Undo delete
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastAction = undoStack.pop();
    if (lastAction.action === 'delete') {
      const bd = lastAction.boxData;
      canvas.appendChild(bd.element);
      boxesMap.set(bd.id, bd);
      connections.length = 0;
      lastAction.connectionsSnapshot.forEach(c => connections.push(c));
      undoBtn.disabled = undoStack.length === 0;
      drawConnections();
      saveCurrentMindMap();
    }
  });

  // Draw connections between boxes using SVG lines
  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);
    connections.forEach(({ from, to }) => {
      const fromBox = boxesMap.get(from);
      const toBox = boxesMap.get(to);
      if (!fromBox || !toBox) return;

      const startX = fromBox.x + fromBox.width / 2;
      const startY = fromBox.y + fromBox.height / 2;
      const endX = toBox.x + toBox.width / 2;
      const endY = toBox.y + toBox.height / 2;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", startX);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", endX);
      line.setAttribute("y2", endY);
      line.setAttribute("stroke", "black");
      line.setAttribute("stroke-width", "2");
      connectionLayer.appendChild(line);
    });
  }

  // Save mind map data to Firestore
  async function saveCurrentMindMap() {
    if (!currentMindMapId) return;
    const boxes = [];
    boxesMap.forEach(b => {
      boxes.push({
        id: b.id,
        x: b.x,
        y: b.y,
        width: b.width,
        height: b.height,
        text: b.content.textContent,
        fontSize: b.fontSize
      });
    });
    try {
      await setDoc(doc(mindMapsCollection, currentMindMapId), {
        boxes,
        connections,
        lastModified: new Date()
      }, { merge: true });
      showSavedMessage();
      populateMindMapList();
    } catch (err) {
      alert('Error saving mind map: ' + err.message);
    }
  }

  // Show "Saved" message briefly
  let savedTimeout;
  function showSavedMessage() {
    savedMessage.style.opacity = '1';
    clearTimeout(savedTimeout);
    savedTimeout = setTimeout(() => {
      savedMessage.style.opacity = '0';
    }, 1500);
  }

  // Load mind map data from Firestore
  async function loadMindMap(id) {
    if (!id) return;
    const snap = await getDoc(doc(mindMapsCollection, id));
    if (!snap.exists()) {
      alert('Mind map does not exist');
      return;
    }
    currentMindMapId = id;
    clearCanvas();
    const data = snap.data();
    if (data.boxes) {
      data.boxes.forEach(b => {
        addBox(b.x, b.y, b.id, b.text, b.fontSize, b.width, b.height);
      });
    }
    connections.length = 0;
    if (data.connections) {
      data.connections.forEach(c => connections.push(c));
    }
    drawConnections();
    // Load center
    if (data.center) {
      const rect = viewport.getBoundingClientRect();
      panX = rect.width / 2 - data.center.x * scale;
      panY = rect.height / 2 - data.center.y * scale;
      updateTransform();
    } else {
      panX = 0;
      panY = 0;
      updateTransform();
    }
    selectedBoxes.clear();
    undoStack.length = 0;
    undoBtn.disabled = true;
    renameInput.value = mindMapSelect.options[mindMapSelect.selectedIndex]?.text || '';
  }

  // Clear all boxes and connections from canvas
  function clearCanvas() {
    boxesMap.forEach(b => {
      if (canvas.contains(b.element)) canvas.removeChild(b.element);
    });
    boxesMap.clear();
    connections.length = 0;
    while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);
  }

  // Populate mind map list in dropdown
  async function populateMindMapList() {
    const querySnapshot = await getDocs(mindMapsCollection);
    mindMapSelect.innerHTML = '';
    querySnapshot.forEach(docSnap => {
      const option = document.createElement('option');
      option.value = docSnap.id;
      const data = docSnap.data();
      option.textContent = data.name || docSnap.id;
      mindMapSelect.appendChild(option);
    });
    // Set selected to currentMindMapId if exists
    if (currentMindMapId) {
      mindMapSelect.value = currentMindMapId;
    }
  }

  // Rename button action
  renameBtn.addEventListener('click', async () => {
    if (!currentMindMapId) {
      alert('No mind map selected');
      return;
    }
    const newName = renameInput.value.trim();
    if (!newName) {
      alert('Please enter a valid name');
      return;
    }
    try {
      await updateDoc(doc(mindMapsCollection, currentMindMapId), { name: newName });
      await populateMindMapList();
      mindMapSelect.value = currentMindMapId;
      showSavedMessage();
    } catch (err) {
      alert('Error renaming mind map: ' + err.message);
    }
  });

  // Delete button action
  deleteBtn.addEventListener('click', async () => {
    if (!currentMindMapId) {
      alert('No mind map selected');
      return;
    }
    if (!confirm('Are you sure you want to delete this mind map? This cannot be undone.')) return;
    try {
      await deleteDoc(doc(mindMapsCollection, currentMindMapId));
      currentMindMapId = null;
      clearCanvas();
      populateMindMapList();
      renameInput.value = '';
      selectedBoxes.clear();
      undoStack.length = 0;
      undoBtn.disabled = true;
      panX = 0; panY = 0; updateTransform();
    } catch (err) {
      alert('Error deleting mind map: ' + err.message);
    }
  });

  // When dropdown changes, load that mind map automatically
  mindMapSelect.addEventListener('change', () => {
    const id = mindMapSelect.value;
    if (id) {
      loadMindMap(id);
    }
  });

  // Initialization: create a new mind map if none exist
  async function init() {
    await populateMindMapList();
    if (mindMapSelect.options.length === 0) {
      // Create default mind map
      const newId = crypto.randomUUID();
      currentMindMapId = newId;
      await setDoc(doc(mindMapsCollection, newId), {
        name: 'Default Mind Map',
        boxes: [],
        connections: [],
        lastModified: new Date()
      });
      await populateMindMapList();
      mindMapSelect.value = newId;
    } else {
      currentMindMapId = mindMapSelect.options[0].value;
      await loadMindMap(currentMindMapId);
    }
  }

  // Save every 10 seconds if editing
  setInterval(() => {
    if (editMode && currentMindMapId) {
      saveCurrentMindMap();
    }
  }, 10000);

  // Start
  init();
</script>
</body>
</html>
