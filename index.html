<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsfurtherwork</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = "id-te4y6fgv6"; // Start with your map id as requested
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  // Double-click to add box

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn,
         saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      // double click detected
      const rect = viewport.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const x = (clickX - panX) / scale;
      const y = (clickY - panY) / scale;
      createBox({ x, y, w: 120, h: 50, content: '', id: generateId() }, true);
      lastTap = 0;
    } else {
      lastTap = now;
    }
  });

  // Box creation, rendering

  function createBox(data, saveAfterCreate = false) {
    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = data.x + 'px';
    box.style.top = data.y + 'px';
    box.style.width = data.w + 'px';
    box.style.height = data.h + 'px';
    box.dataset.id = data.id;

    // Header
    const header = document.createElement('div');
    header.classList.add('box-header');
    header.title = "Shift+Click to multi-select";
    // Drag handle ✥
    const dragHandle = document.createElement('div');
    dragHandle.classList.add('drag-handle');
    dragHandle.textContent = '✥';
    dragHandle.title = "Drag handle";
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectBtn = document.createElement('button');
    connectBtn.classList.add('connect-toggle');
    connectBtn.title = "Connect this box";
    header.appendChild(connectBtn);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.textContent = '×';
    deleteBtn.title = "Delete this box";
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content editable div with centered text
    const contentDiv = document.createElement('div');
    contentDiv.classList.add('box-content');
    contentDiv.contentEditable = editMode ? "true" : "false";
    contentDiv.spellcheck = false;
    contentDiv.style.textAlign = 'center';
    contentDiv.textContent = data.content || '';
    box.appendChild(contentDiv);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const rh = document.createElement('div');
      rh.classList.add('resize-handle', pos);
      box.appendChild(rh);
    });

    canvas.appendChild(box);
    boxesMap.set(data.id, { element: box, data });

    // Events

    // Dragging box
    let dragOffsetX, dragOffsetY;
    function onPointerDownDrag(e) {
      if (e.button !== 0) return;
      if (!editMode) return;
      if (!e.target.closest('.drag-handle')) return;
      e.stopPropagation();
      e.preventDefault();

      // Multi select logic
      if (!selectedBoxes.has(box)) {
        if (!e.shiftKey) {
          clearSelection();
        }
        selectBox(box);
      }

      dragOffsetX = e.clientX;
      dragOffsetY = e.clientY;
      document.addEventListener('pointermove', onPointerMoveDrag);
      document.addEventListener('pointerup', onPointerUpDrag);
    }
    function onPointerMoveDrag(e) {
      e.preventDefault();
      const dx = (e.clientX - dragOffsetX) / scale;
      const dy = (e.clientY - dragOffsetY) / scale;
      dragOffsetX = e.clientX;
      dragOffsetY = e.clientY;
      selectedBoxes.forEach(b => {
        const id = b.dataset.id;
        const boxData = boxesMap.get(id).data;
        boxData.x += dx;
        boxData.y += dy;
        b.style.left = boxData.x + 'px';
        b.style.top = boxData.y + 'px';
      });
      drawConnections();
    }
    function onPointerUpDrag(e) {
      document.removeEventListener('pointermove', onPointerMoveDrag);
      document.removeEventListener('pointerup', onPointerUpDrag);
      saveCurrentMap();
    }
    dragHandle.addEventListener('pointerdown', onPointerDownDrag);

    // Shift+click on header to toggle multi-select
    header.addEventListener('click', e => {
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          deselectBox(box);
        } else {
          selectBox(box);
        }
      }
    });

    // Delete box
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(data.id);
    });

    // Connect toggle
    connectBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === null) {
        connectionStartBoxId = data.id;
        connectBtn.classList.add('active');
      } else if (connectionStartBoxId === data.id) {
        connectionStartBoxId = null;
        connectBtn.classList.remove('active');
      } else {
        // Make connection
        addConnection(connectionStartBoxId, data.id);
        connectionStartBoxId = null;
        // Reset all connect toggles
        document.querySelectorAll('.connect-toggle').forEach(btn => btn.classList.remove('active'));
        saveCurrentMap();
      }
    });

    // Content editable events
    contentDiv.addEventListener('input', e => {
      data.content = contentDiv.textContent;
      saveCurrentMap();
      adjustFontSizeToFit(contentDiv, box);
    });

    // Prevent text selection on drag handle
    dragHandle.addEventListener('mousedown', e => e.preventDefault());

    // Resize box

    let resizing = false;
    let resizeHandle = null;
    let resizeStartX, resizeStartY;
    let origW, origH, origX, origY;

    function onPointerDownResize(e) {
      if (e.button !== 0) return;
      if (!editMode) return;
      resizeHandle = e.target;
      resizing = true;
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      const id = box.dataset.id;
      const boxData = boxesMap.get(id).data;
      origW = boxData.w;
      origH = boxData.h;
      origX = boxData.x;
      origY = boxData.y;
      document.addEventListener('pointermove', onPointerMoveResize);
      document.addEventListener('pointerup', onPointerUpResize);
      e.stopPropagation();
      e.preventDefault();
    }

    function onPointerMoveResize(e) {
      if (!resizing) return;
      e.preventDefault();
      const dx = (e.clientX - resizeStartX) / scale;
      const dy = (e.clientY - resizeStartY) / scale;
      const id = box.dataset.id;
      const boxData = boxesMap.get(id).data;

      switch(resizeHandle.classList[1]) {
        case 'nw':
          boxData.x = origX + dx;
          boxData.y = origY + dy;
          boxData.w = Math.max(40, origW - dx);
          boxData.h = Math.max(24, origH - dy);
          break;
        case 'ne':
          boxData.y = origY + dy;
          boxData.w = Math.max(40, origW + dx);
          boxData.h = Math.max(24, origH - dy);
          break;
        case 'sw':
          boxData.x = origX + dx;
          boxData.w = Math.max(40, origW - dx);
          boxData.h = Math.max(24, origH + dy);
          break;
        case 'se':
          boxData.w = Math.max(40, origW + dx);
          boxData.h = Math.max(24, origH + dy);
          break;
      }
      box.style.left = boxData.x + 'px';
      box.style.top = boxData.y + 'px';
      box.style.width = boxData.w + 'px';
      box.style.height = boxData.h + 'px';

      adjustFontSizeToFit(contentDiv, box);
      drawConnections();
    }

    function onPointerUpResize(e) {
      resizing = false;
      document.removeEventListener('pointermove', onPointerMoveResize);
      document.removeEventListener('pointerup', onPointerUpResize);
      saveCurrentMap();
    }

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', onPointerDownResize);
    });

    adjustFontSizeToFit(contentDiv, box);

    if (saveAfterCreate) saveCurrentMap();
  }

  // Adjust font size to fit box

  function adjustFontSizeToFit(contentDiv, box) {
    if (!contentDiv) return;
    let fontSize = 20;
    contentDiv.style.fontSize = fontSize + "px";
    const maxWidth = box.clientWidth - 6;
    const maxHeight = box.clientHeight - 24;
    let fits = false;
    while (!fits && fontSize > 6) {
      contentDiv.style.fontSize = fontSize + "px";
      if (contentDiv.scrollWidth <= maxWidth && contentDiv.scrollHeight <= maxHeight) {
        fits = true;
      } else {
        fontSize -= 1;
      }
    }
    if (fontSize < 6) fontSize = 6;
    contentDiv.style.fontSize = fontSize + "px";
  }

  // Delete box

  function deleteBox(id) {
    const boxEntry = boxesMap.get(id);
    if (!boxEntry) return;
    const boxEl = boxEntry.element;
    undoStack.push({
      boxes: [{ ...boxEntry.data }],
      connections: connections.filter(c => c.from === id || c.to === id)
    });
    connections
      .filter(c => c.from === id || c.to === id)
      .forEach(c => removeConnection(c.from, c.to));
    boxesMap.delete(id);
    boxEl.remove();
    saveCurrentMap();
    undoBtn.disabled = false;
  }

  // Undo delete

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    last.boxes.forEach(b => createBox(b));
    last.connections.forEach(c => addConnection(c.from, c.to));
    undoBtn.disabled = undoStack.length === 0;
    saveCurrentMap();
  });

  // Selection helpers

  function selectBox(box) {
    if (!selectedBoxes.has(box)) {
      selectedBoxes.add(box);
      box.classList.add('selected');
    }
  }

  function deselectBox(box) {
    if (selectedBoxes.has(box)) {
      selectedBoxes.delete(box);
      box.classList.remove('selected');
    }
  }

  function clearSelection() {
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  }

  // Connections management

  function addConnection(fromId, toId) {
    if (connections.find(c => c.from === fromId && c.to === toId)) return;
    connections.push({ from: fromId, to: toId });
    drawConnections();
  }

  function removeConnection(fromId, toId) {
    const idx = connections.findIndex(c => c.from === fromId && c.to === toId);
    if (idx >= 0) {
      connections.splice(idx, 1);
      drawConnections();
    }
  }

  function drawConnections() {
    // Clear previous connections
    while (connectionLayer.firstChild) connectionLayer.firstChild.remove();

    connections.forEach(c => {
      const fromBox = boxesMap.get(c.from);
      const toBox = boxesMap.get(c.to);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.element.getBoundingClientRect();
      const toRect = toBox.element.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      // Calculate coordinates relative to viewport + pan/scale
      const fromX = fromBox.data.x + fromBox.data.w / 2;
      const fromY = fromBox.data.y + fromBox.data.h / 2;
      const toX = toBox.data.x + toBox.data.w / 2;
      const toY = toBox.data.y + toBox.data.h / 2;

      const startX = fromX * scale + panX;
      const startY = fromY * scale + panY;
      const endX = toX * scale + panX;
      const endY = toY * scale + panY;

      // Draw a curved cubic Bezier path
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('stroke', 'black');
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-width', '1.8');
      path.style.pointerEvents = 'auto';
      const dx = endX - startX;
      const dy = endY - startY;
      const curvature = 0.3;
      const cp1X = startX + curvature * dx;
      const cp1Y = startY;
      const cp2X = endX - curvature * dx;
      const cp2Y = endY;
      path.setAttribute('d', `M${startX},${startY} C${cp1X},${cp1Y} ${cp2X},${cp2Y} ${endX},${endY}`);

      connectionLayer.appendChild(path);
    });
  }

  // Map management

  async function loadMapsList() {
    mapSelect.innerHTML = '';
    mapsCache.clear();

    const mapsSnapshot = await getDocs(collection(db, "mindmaps"));
    mapsSnapshot.forEach(docSnap => {
      const mapData = docSnap.data();
      mapsCache.set(docSnap.id, mapData);
      const opt = document.createElement('option');
      opt.value = docSnap.id;
      opt.textContent = mapData.name || docSnap.id;
      mapSelect.appendChild(opt);
    });
    if (mapsCache.size === 0) {
      const newId = generateId();
      mapsCache.set(newId, { name: "Default Map", boxes: [], connections: [], center: { x: 0, y: 0, scale: 1 } });
      const opt = document.createElement('option');
      opt.value = newId;
      opt.textContent = "Default Map";
      mapSelect.appendChild(opt);
      currentMapId = newId;
      saveCurrentMap();
    }
    mapSelect.value = currentMapId;
  }

  async function loadMap(id) {
    if (!mapsCache.has(id)) return;
    clearSelection();
    // Clear boxes and connections
    boxesMap.forEach(({element}) => element.remove());
    boxesMap.clear();
    connections.length = 0;
    updateTransform();

    const mapData = mapsCache.get(id);
    if (!mapData) return;

    currentMapId = id;

    mapData.boxes.forEach(b => createBox(b, false));
    connections.push(...(mapData.connections || []));

    panX = mapData.center?.x || 0;
    panY = mapData.center?.y || 0;
    scale = mapData.center?.scale || 1;

    updateTransform();
    drawConnections();
  }

  async function saveCurrentMap() {
    const boxesArray = [];
    boxesMap.forEach(({ data }) => {
      boxesArray.push({
        id: data.id,
        x: data.x,
        y: data.y,
        w: data.w,
        h: data.h,
        content: data.content
      });
    });

    const mapData = {
      name: mapsCache.get(currentMapId)?.name || currentMapId,
      boxes: boxesArray,
      connections: [...connections],
      center: { x: panX, y: panY, scale }
    };

    mapsCache.set(currentMapId, mapData);
    saveStatus.textContent = 'Saving...';

    try {
      await setDoc(doc(db, "mindmaps", currentMapId), mapData);
      saveStatus.textContent = 'Saved ✓';
      setTimeout(() => { saveStatus.textContent = ''; }, 2000);
    } catch (err) {
      saveStatus.textContent = 'Save failed';
      console.error(err);
    }
  }

  mapSelect.addEventListener('change', async () => {
    if (undoStack.length > 0) {
      if (!confirm("You have unsaved undo history. Switch map anyway?")) {
        mapSelect.value = currentMapId;
        return;
      }
    }
    currentMapId = mapSelect.value;
    undoStack.length = 0;
    undoBtn.disabled = true;
    await loadMap(currentMapId);
  });

  saveMapBtn.addEventListener('click', () => {
    saveCurrentMap();
  });

  renameMapBtn.addEventListener('click', async () => {
    const newName = prompt("Enter new name for current map", mapsCache.get(currentMapId)?.name || "");
    if (!newName) return;
    const mapData = mapsCache.get(currentMapId);
    mapData.name = newName;
    await saveCurrentMap();
    await loadMapsList();
    mapSelect.value = currentMapId;
  });

  deleteMapBtn.addEventListener('click', async () => {
    if (!confirm("Are you sure you want to delete the current map?")) return;
    try {
      await deleteDoc(doc(db, "mindmaps", currentMapId));
      mapsCache.delete(currentMapId);
      await loadMapsList();
      if (mapsCache.size > 0) {
        currentMapId = [...mapsCache.keys()][0];
      } else {
        currentMapId = generateId();
        mapsCache.set(currentMapId, { name: "Default Map", boxes: [], connections: [], center: { x: 0, y: 0, scale: 1 } });
        await saveCurrentMap();
      }
      mapSelect.value = currentMapId;
      await loadMap(currentMapId);
    } catch (err) {
      alert("Delete failed");
      console.error(err);
    }
  });

  newMapBtn.addEventListener('click', async () => {
    const newId = generateId();
    mapsCache.set(newId, { name: "New Map", boxes: [], connections: [], center: { x: 0, y: 0, scale: 1 } });
    currentMapId = newId;
    await saveCurrentMap();
    await loadMapsList();
    mapSelect.value = newId;
    await loadMap(newId);
  });

  // Undo button initially disabled
  undoBtn.disabled = true;

  // Go to center and Mark center

  let markedCenter = { x: 0, y: 0, scale: 1 };

  goCenterBtn.addEventListener('click', () => {
    panX = markedCenter.x;
    panY = markedCenter.y;
    scale = markedCenter.scale;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    markedCenter.x = panX;
    markedCenter.y = panY;
    markedCenter.scale = scale;
    alert("Center marked!");
  });

  // Toggle edit mode

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    document.querySelectorAll('.box-content').forEach(div => {
      div.contentEditable = editMode ? "true" : "false";
    });
    toggleEditModeBtn.textContent = editMode ? "Toggle Edit Mode (ON)" : "Toggle Edit Mode (OFF)";
  });
  toggleEditModeBtn.textContent = editMode ? "Toggle Edit Mode (ON)" : "Toggle Edit Mode (OFF)";

  // How to use modal

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Save map on unload

  window.addEventListener('beforeunload', e => {
    saveCurrentMap();
  });

  // Initialization

  (async () => {
    await loadMapsList();
    await loadMap(currentMapId);
  })();

</script>

</body>
</html>
