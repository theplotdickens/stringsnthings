<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV4-withRenameDelete</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      flex-wrap: wrap;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }

    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #mindmapSelectorContainer {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 6px 8px;
      font-family: monospace;
      z-index: 1010;
      display: flex;
      align-items: center;
      gap: 6px;
      user-select: none;
    }
    #mindmapSelector {
      font-family: monospace;
      font-size: 14px;
      padding: 4px 6px;
    }
    #renameMindmapBtn, #deleteMindmapBtn {
      min-width: auto;
      padding: 2px 6px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      border-radius: 3px;
      border: 1px solid #555;
      background: rgba(100,100,100,0.4);
      color: white;
      transition: background 0.2s ease;
    }
    #renameMindmapBtn:hover {
      background: rgba(80,80,200,0.8);
    }
    #deleteMindmapBtn {
      background-color: #c44;
      border-color: #a22;
    }
    #deleteMindmapBtn:hover {
      background-color: #b33;
    }
  </style>
</head>
<body>
  <div id="mindmapSelectorContainer">
    <label for="mindmapSelector">Mind Map:</label>
    <select id="mindmapSelector">
      <option value="" disabled selected>Loading...</option>
    </select>
    <button id="renameMindmapBtn">Rename</button>
    <button id="deleteMindmapBtn">Delete</button>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      **New:** Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Select a mind map from the dropdown to load it.
      Use Rename and Delete buttons to manage mind maps.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
  import { getFirestore, collection, doc, getDoc, setDoc, deleteDoc, getDocs } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const howToContent = document.getElementById('howToContent');
  const connectionLayer = document.getElementById('connectionLayer');

  const mindmapSelector = document.getElementById('mindmapSelector');
  const renameMindmapBtn = document.getElementById('renameMindmapBtn');
  const deleteMindmapBtn = document.getElementById('deleteMindmapBtn');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMindmapId = null;
  let mindmapsList = [];

  // Helper functions
  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  // Panning
  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, mindmapSelector, renameMindmapBtn, deleteMindmapBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // deselect on background click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  // Zooming
  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Double click to add box
  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, mindmapSelector, renameMindmapBtn, deleteMindmapBtn].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  // Mark and go center using localStorage
  markCenterBtn.addEventListener('click', () => {
    const rect = viewport.getBoundingClientRect();
    const centerX = (rect.width / 2 - panX) / scale;
    const centerY = (rect.height / 2 - panY) / scale;
    localStorage.setItem('markedCenter', JSON.stringify({ x: centerX, y: centerY }));
    alert('Center marked at: ' + Math.round(centerX) + ', ' + Math.round(centerY));
  });

  goCenterBtn.addEventListener('click', () => {
    const savedCenter = localStorage.getItem('markedCenter');
    if (savedCenter) {
      const c = JSON.parse(savedCenter);
      const rect = viewport.getBoundingClientRect();
      panX = rect.width / 2 - c.x * scale;
      panY = rect.height / 2 - c.y * scale;
    } else {
      panX = window.innerWidth / 2;
      panY = window.innerHeight / 2;
    }
    updateTransform();
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    document.querySelectorAll('.box-header').forEach(header => {
      header.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.connect-toggle').forEach(toggle => {
      toggle.style.display = editMode ? 'inline-block' : 'none';
    });
    document.querySelectorAll('.font-size-btn').forEach(btn => {
      btn.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.drag-handle').forEach(handle => {
      handle.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.resize-handle').forEach(rh => {
      rh.style.display = editMode ? 'block' : 'none';
    });
  });

  // How to modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Boxes creation, selection, moving, resizing, editing
  function createBoxElement(id, x, y, width = 120, height = 60, text = '') {
    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.dataset.id = id;

    const header = document.createElement('div');
    header.className = 'box-header';
    box.appendChild(header);

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Click to start/end connecting boxes';
    header.appendChild(connectToggle);

    // Font size buttons
    const fontDownBtn = document.createElement('button');
    fontDownBtn.className = 'font-size-btn';
    fontDownBtn.textContent = '-';
    header.appendChild(fontDownBtn);

    const fontUpBtn = document.createElement('button');
    fontUpBtn.className = 'font-size-btn';
    fontUpBtn.textContent = '+';
    header.appendChild(fontUpBtn);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = '14px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const rh = document.createElement('div');
      rh.className = 'resize-handle ' + pos;
      box.appendChild(rh);
    });

    // Events
    dragHandle.addEventListener('pointerdown', dragBoxPointerDown);
    deleteBtn.addEventListener('click', () => deleteBox(id));
    connectToggle.addEventListener('click', () => toggleConnectionStart(id, connectToggle));
    fontDownBtn.addEventListener('click', () => adjustFontSize(content, -1));
    fontUpBtn.addEventListener('click', () => adjustFontSize(content, +1));
    content.addEventListener('input', () => scheduleSave());
    content.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        e.preventDefault();
        document.execCommand('insertText', false, '\t');
      }
    });

    box.addEventListener('pointerdown', boxPointerDown);
    box.querySelectorAll('.resize-handle').forEach(rh => rh.addEventListener('pointerdown', resizePointerDown));

    return box;
  }

  function addBox(x, y, width = 120, height = 60, text = '') {
    const id = 'box_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    const box = createBoxElement(id, x, y, width, height, text);
    canvas.appendChild(box);
    boxesMap.set(id, box);
    scheduleSave();
  }

  function deleteBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    undoStack.push({ type: 'delete', id, html: box.outerHTML });
    box.remove();
    boxesMap.delete(id);
    // Remove connections involving this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) connections.splice(i, 1);
    }
    drawConnections();
    undoBtn.disabled = false;
    scheduleSave();
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const action = undoStack.pop();
    if (action.type === 'delete') {
      const temp = document.createElement('div');
      temp.innerHTML = action.html;
      const box = temp.firstElementChild;
      canvas.appendChild(box);
      boxesMap.set(action.id, box);
      // reattach events for restored box
      const dragHandle = box.querySelector('.drag-handle');
      dragHandle.addEventListener('pointerdown', dragBoxPointerDown);
      const deleteBtn = box.querySelector('.delete-btn');
      deleteBtn.addEventListener('click', () => deleteBox(action.id));
      const connectToggle = box.querySelector('.connect-toggle');
      connectToggle.addEventListener('click', () => toggleConnectionStart(action.id, connectToggle));
      const fontDownBtn = box.querySelector('.font-size-btn:nth-of-type(1)');
      fontDownBtn.addEventListener('click', () => adjustFontSize(box.querySelector('.box-content'), -1));
      const fontUpBtn = box.querySelector('.font-size-btn:nth-of-type(2)');
      fontUpBtn.addEventListener('click', () => adjustFontSize(box.querySelector('.box-content'), +1));
      const content = box.querySelector('.box-content');
      content.addEventListener('input', () => scheduleSave());
      content.addEventListener('keydown', e => {
        if (e.key === 'Tab') {
          e.preventDefault();
          document.execCommand('insertText', false, '\t');
        }
      });
      box.addEventListener('pointerdown', boxPointerDown);
      box.querySelectorAll('.resize-handle').forEach(rh => rh.addEventListener('pointerdown', resizePointerDown));
      drawConnections();
      undoBtn.disabled = undoStack.length === 0;
      scheduleSave();
    }
  });

  function adjustFontSize(content, delta) {
    let size = parseInt(content.style.fontSize) || 14;
    size += delta;
    if (size < 8) size = 8;
    if (size > 48) size = 48;
    content.style.fontSize = size + 'px';
    scheduleSave();
  }

  // Box dragging and multi-select
  let dragData = null;

  function boxPointerDown(e) {
    if (!editMode) return;
    const box = e.currentTarget;
    if (e.shiftKey) {
      if (selectedBoxes.has(box)) {
        box.classList.remove('selected');
        selectedBoxes.delete(box);
      } else {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    } else {
      if (!selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    }
  }

  function dragBoxPointerDown(e) {
    if (!editMode) return;
    e.stopPropagation();
    const box = e.target.closest('.box');
    if (!selectedBoxes.has(box)) {
      selectedBoxes.forEach(b => b.classList.remove('selected'));
      selectedBoxes.clear();
      selectedBoxes.add(box);
      box.classList.add('selected');
    }
    dragData = {
      startX: e.clientX,
      startY: e.clientY,
      positions: Array.from(selectedBoxes).map(b => {
        return { box: b, x: parseFloat(b.style.left), y: parseFloat(b.style.top) };
      }),
    };
    window.addEventListener('pointermove', dragBoxPointerMove);
    window.addEventListener('pointerup', dragBoxPointerUp);
  }
  function dragBoxPointerMove(e) {
    if (!dragData) return;
    e.preventDefault();
    const dx = (e.clientX - dragData.startX) / scale;
    const dy = (e.clientY - dragData.startY) / scale;
    dragData.positions.forEach(({ box, x, y }) => {
      box.style.left = x + dx + 'px';
      box.style.top = y + dy + 'px';
    });
    drawConnections();
  }
  function dragBoxPointerUp(e) {
    if (!dragData) return;
    dragData = null;
    scheduleSave();
    window.removeEventListener('pointermove', dragBoxPointerMove);
    window.removeEventListener('pointerup', dragBoxPointerUp);
  }

  // Resizing boxes
  let resizeData = null;

  function resizePointerDown(e) {
    if (!editMode) return;
    e.stopPropagation();
    const handle = e.target;
    const box = handle.parentElement;
    resizeData = {
      box,
      handle,
      startX: e.clientX,
      startY: e.clientY,
      startW: parseFloat(box.style.width),
      startH: parseFloat(box.style.height),
      startLeft: parseFloat(box.style.left),
      startTop: parseFloat(box.style.top),
    };
    window.addEventListener('pointermove', resizePointerMove);
    window.addEventListener('pointerup', resizePointerUp);
  }
  function resizePointerMove(e) {
    if (!resizeData) return;
    e.preventDefault();
    const { box, handle, startX, startY, startW, startH, startLeft, startTop } = resizeData;
    const dx = (e.clientX - startX) / scale;
    const dy = (e.clientY - startY) / scale;

    let newW = startW;
    let newH = startH;
    let newLeft = startLeft;
    let newTop = startTop;

    if (handle.classList.contains('se')) {
      newW = Math.max(80, startW + dx);
      newH = Math.max(40, startH + dy);
    } else if (handle.classList.contains('sw')) {
      newW = Math.max(80, startW - dx);
      newH = Math.max(40, startH + dy);
      newLeft = startLeft + dx;
    } else if (handle.classList.contains('ne')) {
      newW = Math.max(80, startW + dx);
      newH = Math.max(40, startH - dy);
      newTop = startTop + dy;
    } else if (handle.classList.contains('nw')) {
      newW = Math.max(80, startW - dx);
      newH = Math.max(40, startH - dy);
      newLeft = startLeft + dx;
      newTop = startTop + dy;
    }

    box.style.width = newW + 'px';
    box.style.height = newH + 'px';
    box.style.left = newLeft + 'px';
    box.style.top = newTop + 'px';

    drawConnections();
  }
  function resizePointerUp(e) {
    if (!resizeData) return;
    resizeData = null;
    scheduleSave();
    window.removeEventListener('pointermove', resizePointerMove);
    window.removeEventListener('pointerup', resizePointerUp);
  }

  // Connections
  function toggleConnectionStart(boxId, toggleBtn) {
    if (!editMode) return;
    if (connectionStartBoxId === null) {
      connectionStartBoxId = boxId;
      toggleBtn.classList.add('active');
    } else {
      if (connectionStartBoxId !== boxId) {
        // Add connection
        connections.push({ from: connectionStartBoxId, to: boxId });
      }
      // Clear all toggles
      document.querySelectorAll('.connect-toggle').forEach(btn => btn.classList.remove('active'));
      connectionStartBoxId = null;
      drawConnections();
      scheduleSave();
    }
  }

  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);
    connections.forEach(conn => {
      const fromBox = boxesMap.get(conn.from);
      const toBox = boxesMap.get(conn.to);
      if (!fromBox || !toBox) return;
      const fromRect = fromBox.getBoundingClientRect();
      const toRect = toBox.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();
      const startX = (fromRect.left - vpRect.left + fromRect.width / 2) / scale;
      const startY = (fromRect.top - vpRect.top + fromRect.height / 2) / scale;
      const endX = (toRect.left - vpRect.left + toRect.width / 2) / scale;
      const endY = (toRect.top - vpRect.top + toRect.height / 2) / scale;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', startX);
      line.setAttribute('y1', startY);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '2');
      connectionLayer.appendChild(line);
    });
  }

  // Save / Load Firebase
  let saveTimeout = null;
  function scheduleSave() {
    if (!currentMindmapId) return;
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => saveMindmap(currentMindmapId), 1000);
  }

  async function saveMindmap(id) {
    const boxes = [];
    boxesMap.forEach((box, key) => {
      boxes.push({
        id: key,
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        width: parseFloat(box.style.width),
        height: parseFloat(box.style.height),
        text: box.querySelector('.box-content').textContent,
        fontSize: box.querySelector('.box-content').style.fontSize || '14px',
      });
    });
    try {
      await setDoc(doc(db, 'mindmaps', id), {
        boxes,
        connections,
      });
      console.log('Save successful');
    } catch (e) {
      alert('Save failed: ' + e.message);
    }
  }

  async function loadMindmapsList() {
    mindmapsList = [];
    mindmapSelector.innerHTML = '<option value="" disabled selected>Select Mind Map</option>';
    const snapshot = await getDocs(collection(db, 'mindmaps'));
    snapshot.forEach(docSnap => {
      mindmapsList.push({ id: docSnap.id });
    });
    mindmapsList.sort((a,b) => a.id.localeCompare(b.id));
    mindmapsList.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m.id;
      opt.textContent = m.id;
      mindmapSelector.appendChild(opt);
    });
  }

  mindmapSelector.addEventListener('change', async () => {
    const id = mindmapSelector.value;
    if (!id) return;
    currentMindmapId = id;
    await loadMindmap(id);
  });

  async function loadMindmap(id) {
    boxesMap.clear();
    connections.length = 0;
    canvas.innerHTML = '';
    undoStack.length = 0;
    undoBtn.disabled = true;
    try {
      const docSnap = await getDoc(doc(db, 'mindmaps', id));
      if (!docSnap.exists()) {
        alert('Mind map not found: ' + id);
        return;
      }
      const data = docSnap.data();
      if (!data.boxes) return;
      data.boxes.forEach(b => {
        const box = createBoxElement(b.id, b.x, b.y, b.width, b.height, b.text);
        box.querySelector('.box-content').style.fontSize = b.fontSize || '14px';
        canvas.appendChild(box);
        boxesMap.set(b.id, box);
      });
      if (data.connections) {
        data.connections.forEach(c => connections.push(c));
      }
      drawConnections();
    } catch (e) {
      alert('Load failed: ' + e.message);
    }
  }

  // Rename mindmap button
  renameMindmapBtn.addEventListener('click', async () => {
    if (!currentMindmapId) {
      alert('No mind map selected to rename.');
      return;
    }
    const newName = prompt('Enter new name for mind map:', currentMindmapId);
    if (!newName || newName.trim() === '') {
      alert('Invalid name.');
      return;
    }
    if (newName === currentMindmapId) {
      return; // no change
    }
    if (mindmapsList.some(m => m.id === newName)) {
      alert('A mind map with that name already exists.');
      return;
    }
    try {
      // Get current data
      const currentDoc = await getDoc(doc(db, 'mindmaps', currentMindmapId));
      if (!currentDoc.exists()) {
        alert('Current mind map not found.');
        return;
      }
      const data = currentDoc.data();

      // Create new doc with newName and same data
      await setDoc(doc(db, 'mindmaps', newName), data);
      // Delete old doc
      await deleteDoc(doc(db, 'mindmaps', currentMindmapId));

      currentMindmapId = newName;
      await loadMindmapsList();
      mindmapSelector.value = newName;
      alert('Mind map renamed to "' + newName + '"');
    } catch (e) {
      alert('Rename failed: ' + e.message);
    }
  });

  // Delete mindmap button
  deleteMindmapBtn.addEventListener('click', async () => {
    if (!currentMindmapId) {
      alert('No mind map selected to delete.');
      return;
    }
    const confirmed = confirm('Are you sure you want to DELETE mind map "' + currentMindmapId + '"? This cannot be undone.');
    if (!confirmed) return;
    try {
      await deleteDoc(doc(db, 'mindmaps', currentMindmapId));
      boxesMap.clear();
      canvas.innerHTML = '';
      connections.length = 0;
      currentMindmapId = null;
      undoStack.length = 0;
      undoBtn.disabled = true;
      drawConnections();
      await loadMindmapsList();
      mindmapSelector.value = '';
      alert('Mind map deleted.');
    } catch (e) {
      alert('Delete failed: ' + e.message);
    }
  });

  // Initial load mindmaps list
  await loadMindmapsList();

  // Load last mindmap or nothing
  if (mindmapsList.length > 0) {
    currentMindmapId = mindmapsList[0].id;
    mindmapSelector.value = currentMindmapId;
    await loadMindmap(currentMindmapId);
  }

  // Apply marked center on load
  const savedCenter = localStorage.getItem('markedCenter');
  if (savedCenter) {
    const c = JSON.parse(savedCenter);
    const rect = viewport.getBoundingClientRect();
    panX = rect.width / 2 - c.x * scale;
    panY = rect.height / 2 - c.y * scale;
    updateTransform();
  }

  // Save on unload
  window.addEventListener('beforeunload', () => {
    if (currentMindmapId) saveMindmap(currentMindmapId);
  });
</script>
</body>
</html>
