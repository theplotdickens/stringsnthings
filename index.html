<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>stringsnthings</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    font-family: Garamond, serif;
    background: #eee;
  }
  #viewport {
    position: relative;
    width: 100vw; height: 100vh;
    overflow: hidden;
    cursor: grab;
  }
  #lineLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 0;
  }
  #boxesContainer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 10;
    user-select: none;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    padding: 8px;
    min-width: 80px; min-height: 40px;
    box-sizing: border-box;
    font-size: 16px;
    cursor: move;
    white-space: pre-wrap;
    overflow-wrap: break-word;
  }
  .box[contenteditable="true"]:focus {
    outline: 2px solid #09f;
  }
  #menuBar {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: rgba(128,128,128,0.3);
    padding: 6px 10px;
    font-family: Garamond, serif;
    display: flex;
    gap: 12px;
    user-select: none;
    z-index: 20;
  }
  button.floating-button {
    background: rgba(128,128,128,0.3);
    border: none;
    padding: 4px 12px;
    font-family: Garamond, serif;
    cursor: pointer;
    font-size: 16px;
    border-radius: 4px;
    user-select: none;
  }
  button.floating-button:focus {
    outline: 2px solid #09f;
  }
  path.line-path {
    fill: none;
    stroke: black;
    stroke-width: 2;
  }
  text.line-label {
    font-family: Garamond, serif;
    font-size: 14px;
    user-select: none;
    pointer-events: none;
    fill: black;
  }
</style>
</head>
<body>

<div id="viewport">
  <svg id="lineLayer"></svg>
  <div id="boxesContainer"></div>
</div>

<div id="menuBar">
  <button id="btnCenter" class="floating-button">Go to Center</button>
  <button id="btnToggleDraw" class="floating-button">Draw Line OFF</button>
  <button id="btnUndoDelete" class="floating-button" disabled>Undo Delete</button>
  <button id="btnUndoLine" class="floating-button" disabled>Undo Line</button>
</div>

<script>
  const viewport = document.getElementById('viewport');
  const lineLayer = document.getElementById('lineLayer');
  const boxesContainer = document.getElementById('boxesContainer');

  let panX = 0, panY = 0, scale = 1;
  let isPanning = false;
  let panStart = {x:0, y:0};
  let panOrigin = {x:0, y:0};

  let isDrawingPath = false;
  let currentPathPoints = [];
  let pathElement = null;
  let labelElement = null;

  let selectedBoxes = [];
  let boxIdCounter = 0;
  const idMap = new Map();

  const undoDeleteStack = [];
  const undoLineStack = [];
  const linesMap = new Map();

  // Basic pan/zoom handlers on viewport
  viewport.addEventListener('pointerdown', e => {
    if (isDrawingPath) return; // disable panning while drawing
    if (e.target !== viewport) return;
    isPanning = true;
    panStart = {x: e.clientX, y: e.clientY};
    panOrigin = {x: panX, y: panY};
    viewport.style.cursor = 'grabbing';
  });
  window.addEventListener('pointerup', e => {
    if (isPanning) {
      isPanning = false;
      viewport.style.cursor = 'grab';
    }
  });
  window.addEventListener('pointermove', e => {
    if (!isPanning) return;
    panX = panOrigin.x + (e.clientX - panStart.x);
    panY = panOrigin.y + (e.clientY - panStart.y);
    updateTransform();
  });
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    let oldScale = scale;
    scale += e.deltaY * -0.001;
    scale = Math.min(Math.max(0.1, scale), 5);
    // zoom towards mouse pointer
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    panX -= (mx / oldScale - mx / scale);
    panY -= (my / oldScale - my / scale);
    updateTransform();
  }, { passive: false });

  function updateTransform() {
    boxesContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    lineLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  // Add box function
  function addBox(x, y, text = 'Edit me', id=null) {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.contentEditable = !isDrawingPath;
    box.textContent = text;
    box.style.fontSize = '16px';
    box.dataset.id = id || 'box-' + (++boxIdCounter);
    idMap.set(box, box.dataset.id);

    boxesContainer.appendChild(box);

    // Drag to move box
    let dragStart = null;
    box.addEventListener('pointerdown', e => {
      if (isDrawingPath) return; // no drag while drawing
      dragStart = {x: e.clientX, y: e.clientY};
      box.style.cursor = 'grabbing';
      e.stopPropagation();
      window.addEventListener('pointermove', dragMove);
      window.addEventListener('pointerup', dragEnd);
    });
    function dragMove(e) {
      if (!dragStart) return;
      let dx = (e.clientX - dragStart.x) / scale;
      let dy = (e.clientY - dragStart.y) / scale;
      const left = parseFloat(box.style.left) + dx;
      const top = parseFloat(box.style.top) + dy;
      box.style.left = left + 'px';
      box.style.top = top + 'px';
      dragStart = {x: e.clientX, y: e.clientY};
      updateLinesForBox(box.dataset.id);
    }
    function dragEnd(e) {
      dragStart = null;
      box.style.cursor = 'move';
      window.removeEventListener('pointermove', dragMove);
      window.removeEventListener('pointerup', dragEnd);
    }

    return box;
  }

  // Line drawing functions
  function screenToCanvas(x, y) {
    return {
      x: (x - panX) / scale,
      y: (y - panY) / scale
    };
  }

  function pointerDownDraw(e) {
    if (!isDrawingPath) return;
    e.preventDefault();
    currentPathPoints = [screenToCanvas(e.clientX, e.clientY)];
    pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathElement.classList.add('line-path');
    lineLayer.appendChild(pathElement);

    labelElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelElement.classList.add('line-label');
    lineLayer.appendChild(labelElement);
  }

  function pointerMoveDraw(e) {
    if (!isDrawingPath || !pathElement) return;
    e.preventDefault();
    currentPathPoints.push(screenToCanvas(e.clientX, e.clientY));
    const d = createPathD(smoothPoints(currentPathPoints, 4));
    pathElement.setAttribute('d', d);
    const mid = getPathMidPoint(d);
    if (mid) {
      labelElement.setAttribute('x', mid.x);
      labelElement.setAttribute('y', mid.y);
      labelElement.textContent = ''; // label text after input
    }
  }

  function pointerUpDraw(e) {
    if (!isDrawingPath || !pathElement) return;
    e.preventDefault();

    // Ask for label
    const label = prompt('Label for this line? (optional)') || '';
    labelElement.textContent = label;

    // Save line data
    undoLineStack.push({points: currentPathPoints.slice(), label});
    if (undoLineStack.length > 5) undoLineStack.shift();
    btnUndoLine.disabled = false;

    currentPathPoints = [];
    pathElement = null;
    labelElement = null;
  }

  // Path helpers
  function smoothPoints(points, iterations=3) {
    if (points.length < 3) return points;
    let pts = points.slice();
    for (let i = 0; i < iterations; i++) {
      let newPts = [];
      newPts.push(pts[0]);
      for (let j = 0; j < pts.length - 1; j++) {
        const p0 = pts[j];
        const p1 = pts[j + 1];
        const Q = { x: 0.75 * p0.x + 0.25 * p1.x, y: 0.75 * p0.y + 0.25 * p1.y };
        const R = { x: 0.25 * p0.x + 0.75 * p1.x, y: 0.25 * p0.y + 0.75 * p1.y };
        newPts.push(Q, R);
      }
      newPts.push(pts[pts.length - 1]);
      pts = newPts;
    }
    return pts;
  }
  function createPathD(points) {
    if (points.length < 2) return '';
    let d = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      const midX = (points[i-1].x + points[i].x)/2;
      const midY = (points[i-1].y + points[i].y)/2;
      d += ` Q ${points[i-1].x} ${points[i-1].y}, ${midX} ${midY}`;
    }
    const last = points[points.length - 1];
    d += ` T ${last.x} ${last.y}`;
    return d;
  }
  function getPathMidPoint(d) {
    try {
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', d);
      const len = path.getTotalLength();
      const pt = path.getPointAtLength(len/2);
      return {x: pt.x, y: pt.y};
    } catch {
      return null;
    }
  }

  // Toggle line drawing mode
  const btnToggleDraw = document.getElementById('btnToggleDraw');
  btnToggleDraw.addEventListener('click', () => {
    isDrawingPath = !isDrawingPath;
    if (isDrawingPath) {
      lineLayer.style.pointerEvents = 'auto';
      boxesContainer.style.pointerEvents = 'none';
      viewport.style.cursor = 'crosshair';
      btnToggleDraw.textContent = 'Draw Line ON';
      // disable box contenteditable and dragging
      document.querySelectorAll('.box').forEach(b => {
        b.contentEditable = 'false';
        b.style.cursor = 'default';
      });
    } else {
      lineLayer.style.pointerEvents = 'none';
      boxesContainer.style.pointerEvents = 'auto';
      viewport.style.cursor = 'grab';
      btnToggleDraw.textContent = 'Draw Line OFF';
      // re-enable box contenteditable and dragging cursor
      document.querySelectorAll('.box').forEach(b => {
        b.contentEditable = 'true';
        b.style.cursor = 'move';
      });
    }
  });

  // Undo buttons (delete and line undo stub)
  const btnUndoDelete = document.getElementById('btnUndoDelete');
  const btnUndoLine = document.getElementById('btnUndoLine');

  btnUndoDelete.addEventListener('click', () => {
    alert('Undo delete not implemented in this snippet');
  });
  btnUndoLine.addEventListener('click', () => {
    alert('Undo line not implemented in this snippet');
  });

  // Center button
  const btnCenter = document.getElementById('btnCenter');
  btnCenter.addEventListener('click', () => {
    panX = 0; panY = 0; scale = 1;
    updateTransform();
  });

  // Initialize with one box
  addBox(100, 100, 'Hello World!');

  // Attach SVG drawing listeners
  lineLayer.addEventListener('pointerdown', pointerDownDraw);
  lineLayer.addEventListener('pointermove', pointerMoveDraw);
  lineLayer.addEventListener('pointerup', pointerUpDraw);
  lineLayer.style.pointerEvents = 'none'; // default off

  updateTransform();
</script>

</body>
</html>
