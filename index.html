<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings Mindmap</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body, #viewport {
    margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#f0f0f0;
    font-family: Arial, sans-serif;
  }
  #viewport {
    position: relative;
    overflow: hidden;
  }
  #canvas {
    position: absolute;
    top:0; left:0;
    width:100%; height:100%;
    transform-origin: 0 0;
  }
  .box {
    position: absolute;
    border: 1px solid #666;
    border-radius: 4px;
    background: #fff;
    box-shadow: 1px 1px 6px rgba(0,0,0,0.15);
    user-select: none;
    font-size: 14px;
    display: flex;
    flex-direction: column;
    min-width: 80px;
    min-height: 40px;
    box-sizing: border-box;
  }
  .box-content {
    flex-grow: 1;
    padding: 6px 8px;
    overflow-wrap: break-word;
    outline: none;
    user-select: text;
  }
  .box-header {
    display: flex;
    align-items: center;
    background: #ddd;
    padding: 2px 4px;
    cursor: grab;
    user-select: none;
  }
  .drag-handle {
    font-weight: bold;
    margin-right: 6px;
    cursor: grab;
  }
  button {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    margin-left: 6px;
    user-select: none;
  }
  button:focus {
    outline: none;
  }
  .palette-btn svg {
    width: 18px;
    height: 18px;
    fill: #333;
  }
  .font-size-btn::before {
    display: inline-block;
    width: 12px;
    height: 12px;
    line-height: 12px;
    font-weight: bold;
    color: #333;
  }
  .font-size-btn.minus::before {
    content: "−";
  }
  .font-size-btn.plus::before {
    content: "+";
  }
  .delete-btn {
    font-size: 18px;
    color: #900;
    font-weight: bold;
  }
  .resize-handle.se {
    width: 12px;
    height: 12px;
    background: #666;
    position: absolute;
    right: 0;
    bottom: 0;
    cursor: se-resize;
    user-select: none;
  }
  .selected {
    box-shadow: 0 0 8px 3px #0077ffaa;
  }
  /* Connection toggles */
  .conn-toggle {
    width: 18px;
    height: 18px;
    background: #0077ffcc;
    border-radius: 50%;
    border: 1px solid #0055cc;
    cursor: pointer;
    margin-left: 6px;
  }
  .conn-toggle.selected {
    background: #0055cc;
  }
  /* Z layers */
  #connection-layer {
    position: absolute;
    top:0; left:0; right:0; bottom:0;
    pointer-events: none;
    z-index: 1;
  }
  #canvas .box {
    z-index: 10;
  }
</style>
</head>
<body>
<div id="viewport">
  <svg id="connection-layer" xmlns="http://www.w3.org/2000/svg"></svg>
  <div id="canvas"></div>
</div>

<!-- Controls -->
<div style="position: fixed; top: 6px; left: 6px; background: white; padding: 6px; border-radius: 4px; box-shadow: 0 0 5px #ccc; z-index: 1000;">
  <select id="mapSelect" title="Select map"></select>
  <button id="newMapBtn" title="New map">New</button>
  <button id="saveMapBtn" title="Save map">Save</button>
  <button id="renameMapBtn" title="Rename map">Rename</button>
  <button id="deleteMapBtn" title="Delete map">Delete</button>
  <button id="undoBtn" disabled title="Undo delete">Undo</button>
  <button id="toggleEditModeBtn" title="Toggle edit mode">Edit</button>
  <button id="markCenterBtn" title="Mark center">Mark Center</button>
  <button id="goCenterBtn" title="Go to center">Go Center</button>
  <span id="saveStatus" style="margin-left:10px; font-size:14px;"></span>
</div>

<script type="module">
// Firebase config and imports
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getFirestore, collection, getDocs, setDoc, doc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
  authDomain: "stringsnthings-65aa0.firebaseapp.com",
  projectId: "stringsnthings-65aa0",
  storageBucket: "stringsnthings-65aa0.appspot.com",
  messagingSenderId: "35780192306",
  appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Elements
const viewport = document.getElementById('viewport');
const canvas = document.getElementById('canvas');
const connectionLayer = document.getElementById('connection-layer');

const mapSelect = document.getElementById('mapSelect');
const newMapBtn = document.getElementById('newMapBtn');
const saveMapBtn = document.getElementById('saveMapBtn');
const renameMapBtn = document.getElementById('renameMapBtn');
const deleteMapBtn = document.getElementById('deleteMapBtn');
const undoBtn = document.getElementById('undoBtn');
const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
const markCenterBtn = document.getElementById('markCenterBtn');
const goCenterBtn = document.getElementById('goCenterBtn');
const saveStatus = document.getElementById('saveStatus');

let editMode = true;
let panX = 0;
let panY = 0;
let scale = 1;
let markedCenter = null;

const boxesMap = new Map();
const connections = [];
const selectedBoxes = new Set();
const undoStack = [];
const mapsCache = new Map();

let currentMapId = null;

function generateId() {
  return 'id-' + Math.random().toString(36).substr(2, 9);
}

// Create box with all UI and logic
function createBox(id, x, y, w=150, h=100, text='', fontSize=14, bgColor='transparent') {
  if (boxesMap.has(id)) return boxesMap.get(id).el;

  const box = document.createElement('div');
  box.classList.add('box');
  box.style.left = x + 'px';
  box.style.top = y + 'px';
  box.style.width = w + 'px';
  box.style.height = h + 'px';
  box.style.fontSize = fontSize + 'px';
  box.style.backgroundColor = bgColor === 'transparent' ? 'transparent' : hexToRGBA(bgColor, 0.1);

  // Header with drag handle, palette, font size, delete, and connection toggles
  const header = document.createElement('div');
  header.classList.add('box-header');

  // Drag handle
  const dragHandle = document.createElement('div');
  dragHandle.classList.add('drag-handle');
  dragHandle.textContent = '✥';
  header.appendChild(dragHandle);

  // Palette button
  const paletteBtn = document.createElement('button');
  paletteBtn.classList.add('palette-btn');
  paletteBtn.title = "Change box background color";
  paletteBtn.innerHTML = `
    <svg viewBox="0 0 24 24" >
      <circle cx="12" cy="12" r="10" stroke="#333" stroke-width="1" fill="none"/>
      <circle cx="12" cy="12" r="6" fill="#333"/>
    </svg>`;
  header.appendChild(paletteBtn);

  // Font size controls
  const fontMinus = document.createElement('button');
  fontMinus.classList.add('font-size-btn', 'minus');
  fontMinus.title = "Decrease font size";
  header.appendChild(fontMinus);

  const fontPlus = document.createElement('button');
  fontPlus.classList.add('font-size-btn', 'plus');
  fontPlus.title = "Increase font size";
  header.appendChild(fontPlus);

  // Delete button
  const deleteBtn = document.createElement('button');
  deleteBtn.classList.add('delete-btn');
  deleteBtn.textContent = '×';
  deleteBtn.title = "Delete box";
  header.appendChild(deleteBtn);

  // Connection toggles (two toggles: from and to)
  const connToggleFrom = document.createElement('div');
  connToggleFrom.classList.add('conn-toggle');
  connToggleFrom.title = "Connect from this box";
  header.appendChild(connToggleFrom);

  const connToggleTo = document.createElement('div');
  connToggleTo.classList.add('conn-toggle');
  connToggleTo.title = "Connect to this box";
  header.appendChild(connToggleTo);

  box.appendChild(header);

  // Content editable area
  const content = document.createElement('div');
  content.classList.add('box-content');
  content.contentEditable = editMode;
  content.spellcheck = false;
  content.textContent = text;
  box.appendChild(content);

  // Resize handle bottom-right
  const resizeHandle = document.createElement('div');
  resizeHandle.classList.add('resize-handle', 'se');
  box.appendChild(resizeHandle);

  canvas.appendChild(box);
  boxesMap.set(id, { el: box, content, header, fontSize, bgColor, x, y, w, h, connToggleFrom, connToggleTo });

  // Dragging
  let dragging = false;
  let dragOffsetX, dragOffsetY;
  function onDragStart(e) {
    if (!editMode) return;
    if (e.target !== dragHandle) return;
    dragging = true;
    const rect = box.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;
    e.preventDefault();
  }
  function onDragMove(e) {
    if (!dragging) return;
    let newX = (e.clientX - dragOffsetX - panX) / scale;
    let newY = (e.clientY - dragOffsetY - panY) / scale;
    // Snap to grid 5px
    newX = Math.round(newX / 5) * 5;
    newY = Math.round(newY / 5) * 5;
    box.style.left = newX + 'px';
    box.style.top = newY + 'px';
    const b = boxesMap.get(id);
    b.x = newX;
    b.y = newY;
    drawConnections();
  }
  function onDragEnd() {
    dragging = false;
  }
  dragHandle.addEventListener('pointerdown', onDragStart);
  window.addEventListener('pointermove', onDragMove);
  window.addEventListener('pointerup', onDragEnd);

  // Resize
  let resizing = false;
  let resizeStartX, resizeStartY;
  let startW, startH;
  resizeHandle.addEventListener('pointerdown', e => {
    if (!editMode) return;
    resizing = true;
    resizeStartX = e.clientX;
    resizeStartY = e.clientY;
    startW = box.offsetWidth;
    startH = box.offsetHeight;
    e.preventDefault();
    e.stopPropagation();
  });
  window.addEventListener('pointermove', e => {
    if (!resizing) return;
    let newW = startW + (e.clientX - resizeStartX);
    let newH = startH + (e.clientY - resizeStartY);
    newW = Math.max(80, newW);
    newH = Math.max(40, newH);
    box.style.width = newW + 'px';
    box.style.height = newH + 'px';
    const b = boxesMap.get(id);
    b.w = newW;
    b.h = newH;
    drawConnections();
  });
  window.addEventListener('pointerup', e => {
    resizing = false;
  });

  // Content editable events
  content.addEventListener('input', e => {
    const b = boxesMap.get(id);
    b.text = content.textContent;
  });

  // Font size controls
  fontMinus.addEventListener('click', e => {
    e.preventDefault();
    const b = boxesMap.get(id);
    b.fontSize = Math.max(8, b.fontSize - 1);
    box.style.fontSize = b.fontSize + 'px';
  });
  fontPlus.addEventListener('click', e => {
    e.preventDefault();
    const b = boxesMap.get(id);
    b.fontSize = Math.min(36, b.fontSize + 1);
    box.style.fontSize = b.fontSize + 'px';
  });

  // Delete box
  deleteBtn.addEventListener('click', e => {
    e.preventDefault();
    removeBox(id);
  });

  // Palette button: open color picker immediately
  paletteBtn.addEventListener('click', e => {
    e.stopPropagation();
    openColorPicker(id);
  });

  // Connection toggles events
  connToggleFrom.addEventListener('click', e => {
    e.stopPropagation();
    toggleConnectionMode('from', id);
  });
  connToggleTo.addEventListener('click', e => {
    e.stopPropagation();
    toggleConnectionMode('to', id);
  });

  // Select box on header click (for multiple selection with Shift)
  header.addEventListener('click', e => {
    if (e.target === connToggleFrom || e.target === connToggleTo || e.target === paletteBtn ||
        e.target === fontMinus || e.target === fontPlus || e.target === deleteBtn || e.target === dragHandle) {
      return; // Ignore header click on controls
    }
    e.preventDefault();
    e.stopPropagation();
    if (!editMode) return;
    if (e.shiftKey) {
      if (selectedBoxes.has(box)) {
        selectedBoxes.delete(box);
        box.classList.remove('selected');
      } else {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    } else {
      selectedBoxes.forEach(b => b.classList.remove('selected'));
      selectedBoxes.clear();
      selectedBoxes.add(box);
      box.classList.add('selected');
    }
  });

  return box;
}

// Remove box and related connections
function removeBox(id) {
  if (!boxesMap.has(id)) return;
  const { el } = boxesMap.get(id);
  undoStack.push({ id, data: boxesMap.get(id) });
  undoBtn.disabled = false;
  el.remove();
  boxesMap.delete(id);
  // Remove connections linked to this box
  for (let i = connections.length - 1; i >= 0; i--) {
    if (connections[i].from === id || connections[i].to === id) {
      connections.splice(i, 1);
    }
  }
  drawConnections();
}

// Undo delete
undoBtn.addEventListener('click', () => {
  if (undoStack.length === 0) return;
  const { id, data } = undoStack.pop();
  createBox(id, data.x, data.y, data.w, data.h, data.text || '', data.fontSize, data.bgColor || 'transparent');
  undoBtn.disabled = undoStack.length === 0;
  drawConnections();
});

// Connection mode tracking
let connectionMode = null; // { type: 'from'|'to', boxId: string }
function toggleConnectionMode(type, boxId) {
  if (connectionMode && connectionMode.type === type && connectionMode.boxId === boxId) {
    // Turn off connection mode
    connectionMode = null;
    updateConnectionToggles();
  } else {
    connectionMode = { type, boxId };
    updateConnectionToggles();
  }
}

function updateConnectionToggles() {
  boxesMap.forEach(({connToggleFrom, connToggleTo, el}, id) => {
    if (!connToggleFrom || !connToggleTo) return;
    if (connectionMode && connectionMode.boxId === id) {
      if (connectionMode.type === 'from') {
        connToggleFrom.classList.add('selected');
        connToggleTo.classList.remove('selected');
      } else {
        connToggleTo.classList.add('selected');
        connToggleFrom.classList.remove('selected');
      }
    } else {
      connToggleFrom.classList.remove('selected');
      connToggleTo.classList.remove('selected');
    }
  });
}

// When connectionMode active, clicking another box toggles a connection
function onBoxClickedForConnection(boxId) {
  if (!connectionMode) return;
  const fromId = connectionMode.type === 'from' ? connectionMode.boxId : boxId;
  const toId = connectionMode.type === 'to' ? connectionMode.boxId : boxId;
  if (fromId === toId) return; // No self connection

  // Check if connection exists, remove it if so, else add
  const idx = connections.findIndex(c => c.from === fromId && c.to === toId);
  if (idx >= 0) {
    connections.splice(idx, 1);
  } else {
    connections.push({ from: fromId, to: toId });
  }
  connectionMode = null;
  updateConnectionToggles();
  drawConnections();
}

// Draw curved connections behind boxes
function drawConnections() {
  connectionLayer.innerHTML = ''; // Clear
  for (const c of connections) {
    if (!boxesMap.has(c.from) || !boxesMap.has(c.to)) continue;
    const bFrom = boxesMap.get(c.from);
    const bTo = boxesMap.get(c.to);

    // Center points of boxes
    const x1 = bFrom.x + bFrom.w / 2;
    const y1 = bFrom.y + bFrom.h / 2;
    const x2 = bTo.x + bTo.w / 2;
    const y2 = bTo.y + bTo.h / 2;

    // Create smooth curve with cubic bezier
    const dx = x2 - x1;
    const dy = y2 - y1;
    const curvature = 0.3; // adjust for curve strength

    const cx1 = x1 + dx * curvature;
    const cy1 = y1;
    const cx2 = x2 - dx * curvature;
    const cy2 = y2;

    const pathData = `M${x1} ${y1} C${cx1} ${cy1} ${cx2} ${cy2} ${x2} ${y2}`;

    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", pathData);
    path.setAttribute("stroke", "#0077cc");
    path.setAttribute("stroke-width", "2");
    path.setAttribute("fill", "none");
    path.setAttribute("marker-end", "url(#arrowhead)");

    connectionLayer.appendChild(path);
  }
}

// Add arrow marker to SVG defs
function setupArrowMarker() {
  let defs = connectionLayer.querySelector('defs');
  if (!defs) {
    defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    connectionLayer.appendChild(defs);
  }
  let marker = defs.querySelector('#arrowhead');
  if (!marker) {
    marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute('id', 'arrowhead');
    marker.setAttribute('markerWidth', '10');
    marker.setAttribute('markerHeight', '7');
    marker.setAttribute('refX', '10');
    marker.setAttribute('refY', '3.5');
    marker.setAttribute('orient', 'auto');
    marker.setAttribute('fill', '#0077cc');
    marker.innerHTML = '<path d="M0,0 L10,3.5 L0,7 Z" />';
    defs.appendChild(marker);
  }
}
setupArrowMarker();

// Convert hex color to rgba with opacity
function hexToRGBA(hex, opacity) {
  let c;
  if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
      c= hex.substring(1).split('');
      if(c.length== 3){
          c= [c[0], c[0], c[1], c[1], c[2], c[2]];
      }
      c= '0x'+c.join('');
      return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+opacity+')';
  }
  return hex; // fallback if invalid
}

// Open color picker for box background with opacity
function openColorPicker(boxId) {
  if (!boxesMap.has(boxId)) return;
  const { el } = boxesMap.get(boxId);

  // Remove existing picker if any
  let existingPicker = document.getElementById('color-picker-popup');
  if (existingPicker) existingPicker.remove();

  // Create input type color
  const picker = document.createElement('input');
  picker.type = 'color';
  picker.id = 'color-picker-popup';
  picker.style.position = 'fixed';
  picker.style.zIndex = '9999';
  // Position near palette button
  const paletteBtn = el.querySelector('.palette-btn');
  if (!paletteBtn) return;

  const rect = paletteBtn.getBoundingClientRect();
  picker.style.left = rect.left + 'px';
  picker.style.top = (rect.bottom + 4) + 'px';

  // Set initial color to current bg or black
  const b = boxesMap.get(boxId);
  let initialColor = b.bgColor || '#000000';
  // Remove transparency conversion for picker
  if(initialColor === 'transparent') initialColor = '#000000';
  picker.value = rgbToHex(initialColor);

  document.body.appendChild(picker);
  picker.focus();
  picker.click();

  picker.addEventListener('input', (e) => {
    const color = e.target.value;
    // Save color in box data
    b.bgColor = color;
    el.style.backgroundColor = hexToRGBA(color, 0.1);
  });

  picker.addEventListener('blur', (e) => {
    picker.remove();
    saveStatus.textContent = 'Color changed, remember to save map.';
  });
}
// Convert rgb or rgba string to hex
function rgbToHex(rgb) {
  const ctx = document.createElement('canvas').getContext('2d');
  ctx.fillStyle = rgb;
  return ctx.fillStyle;
}

// Create box exactly where user double-clicked (account for pan and scale)
viewport.addEventListener('dblclick', (e) => {
  if (!editMode) return;
  const rect = canvas.getBoundingClientRect();
  // Calculate coords relative to canvas (account pan, scale)
  const x = (e.clientX - rect.left - panX) / scale;
  const y = (e.clientY - rect.top - panY) / scale;
  const id = generateId();
  createBox(id, x, y);
});

// Clicking boxes for connection when connectionMode active
canvas.addEventListener('click', e => {
  if (!editMode) return;
  let target = e.target;
  while (target && !target.classList.contains('box')) {
    target = target.parentElement;
  }
  if (target && connectionMode) {
    // Find box id
    for (const [id, b] of boxesMap.entries()) {
      if (b.el === target) {
        onBoxClickedForConnection(id);
        break;
      }
    }
  }
});

// Basic pan with middle mouse or right mouse drag
let panning = false;
let panStartX, panStartY;
viewport.addEventListener('mousedown', e => {
  if (e.button === 1 || e.button === 2) {
    panning = true;
    panStartX = e.clientX - panX;
    panStartY = e.clientY - panY;
    e.preventDefault();
  }
});
window.addEventListener('mouseup', e => {
  panning = false;
});
window.addEventListener('mousemove', e => {
  if (panning) {
    panX = e.clientX - panStartX;
    panY = e.clientY - panStartY;
    updateTransform();
  }
});

// Zoom with wheel
viewport.addEventListener('wheel', e => {
  e.preventDefault();
  const oldScale = scale;
  scale += e.deltaY * -0.001;
  scale = Math.min(Math.max(0.2, scale), 4);

  // Zoom towards mouse position
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  panX -= (mx / oldScale - mx / scale);
  panY -= (my / oldScale - my / scale);
  updateTransform();
}, { passive: false });

function updateTransform() {
  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
}

// Map load/save functions
async function loadMaps() {
  const colRef = collection(db, 'maps');
  const snapshot = await getDocs(colRef);
  mapSelect.innerHTML = '';
  mapsCache.clear();
  snapshot.forEach(docSnap => {
    const data = docSnap.data();
    mapsCache.set(docSnap.id, data);
    const option = document.createElement('option');
    option.value = docSnap.id;
    option.textContent = data.name || docSnap.id;
    mapSelect.appendChild(option);
  });
  if (mapsCache.has('id-19dmwrpql')) {
    mapSelect.value = 'id-19dmwrpql';
    await loadMap('id-19dmwrpql');
  } else if (mapSelect.options.length > 0) {
    await loadMap(mapSelect.options[0].value);
  }
}

async function loadMap(id) {
  if (!mapsCache.has(id)) return;
  currentMapId = id;
  clearMap();
  const data = mapsCache.get(id);
  if (!data) return;

  if (data.panX !== undefined) panX = data.panX;
  if (data.panY !== undefined) panY = data.panY;
  if (data.scale !== undefined) scale = data.scale;
  updateTransform();

  if (data.boxes) {
    for (const box of data.boxes) {
      createBox(box.id, box.x, box.y, box.w, box.h, box.text, box.fontSize, box.bgColor);
    }
  }
  if (data.connections) {
    connections.length = 0;
    for (const c of data.connections) {
      connections.push(c);
    }
  }
  drawConnections();
  saveStatus.textContent = 'Map loaded: ' + (data.name || id);
}

function clearMap() {
  boxesMap.forEach(({el}) => el.remove());
  boxesMap.clear();
  connections.length = 0;
  drawConnections();
  selectedBoxes.clear();
}

async function saveMap() {
  if (!currentMapId) return;
  const boxesArr = [];
  boxesMap.forEach(({el, x, y, w, h, content, fontSize, bgColor, text}) => {
    boxesArr.push({
      id: [...boxesMap.entries()].find(([key, val]) => val.el === el)[0],
      x, y, w, h,
      text: content.textContent,
      fontSize,
      bgColor
    });
  });
  const data = {
    name: mapSelect.options[mapSelect.selectedIndex]?.text || currentMapId,
    boxes: boxesArr,
    connections: connections,
    panX,
    panY,
    scale
  };
  try {
    await setDoc(doc(db, 'maps', currentMapId), data);
    saveStatus.textContent = 'Map saved.';
  } catch (e) {
    saveStatus.textContent = 'Save failed: ' + e.message;
  }
}

// New map
newMapBtn.addEventListener('click', () => {
  const newId = generateId();
  mapsCache.set(newId, { name: newId, boxes: [], connections: [], panX:0, panY:0, scale:1 });
  const option = document.createElement('option');
  option.value = newId;
  option.textContent = newId;
  mapSelect.appendChild(option);
  mapSelect.value = newId;
  currentMapId = newId;
  clearMap();
  panX = 0; panY = 0; scale = 1;
  updateTransform();
  saveStatus.textContent = 'New map created.';
});

// Rename map
renameMapBtn.addEventListener('click', async () => {
  if (!currentMapId) return;
  const newName = prompt("Enter new map name:", mapSelect.options[mapSelect.selectedIndex].text);
  if (!newName) return;
  mapsCache.get(currentMapId).name = newName;
  mapSelect.options[mapSelect.selectedIndex].textContent = newName;
  saveStatus.textContent = 'Map renamed.';
  await saveMap();
});

// Delete map
deleteMapBtn.addEventListener('click', async () => {
  if (!currentMapId) return;
  if (!confirm("Delete current map?")) return;
  try {
    await deleteDoc(doc(db, 'maps', currentMapId));
    mapsCache.delete(currentMapId);
    for(let i=0; i<mapSelect.options.length; i++) {
      if(mapSelect.options[i].value === currentMapId) {
        mapSelect.remove(i);
        break;
      }
    }
    if(mapSelect.options.length > 0) {
      await loadMap(mapSelect.options[0].value);
    } else {
      clearMap();
      currentMapId = null;
    }
    saveStatus.textContent = 'Map deleted.';
  } catch(e) {
    saveStatus.textContent = 'Delete failed: ' + e.message;
  }
});

// Map select change
mapSelect.addEventListener('change', async (e) => {
  await loadMap(e.target.value);
});

// Save button
saveMapBtn.addEventListener('click', async () => {
  await saveMap();
});

// Undo button enabled/disabled by stack length

// Toggle edit mode
toggleEditModeBtn.addEventListener('click', () => {
  editMode = !editMode;
  toggleEditModeBtn.textContent = editMode ? 'Edit' : 'View';
  boxesMap.forEach(({content, header, connToggleFrom, connToggleTo}) => {
    content.contentEditable = editMode;
    connToggleFrom.style.pointerEvents = editMode ? 'auto' : 'none';
    connToggleTo.style.pointerEvents = editMode ? 'auto' : 'none';
  });
});

// Mark center and go to center
markCenterBtn.addEventListener('click', () => {
  markedCenter = { panX, panY, scale };
  saveStatus.textContent = 'Center marked.';
});
goCenterBtn.addEventListener('click', () => {
  if (!markedCenter) {
    saveStatus.textContent = 'No center marked.';
    return;
  }
  panX = markedCenter.panX;
  panY = markedCenter.panY;
  scale = markedCenter.scale;
  updateTransform();
  saveStatus.textContent = 'Moved to center.';
});

// Initialize
(async () => {
  await loadMaps();
  updateTransform();
})();
</script>
</body>
</html>
