<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv8</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9ea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.style.fontSize = fontSize + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.classList.add('box-header');

    const dragHandle = document.createElement('div');
    dragHandle.classList.add('drag-handle');
    dragHandle.textContent = '✥';
    dragHandle.title = 'Drag handle (Shift+click header to multi-select)';
    header.appendChild(dragHandle);

    const connectToggle = document.createElement('button');
    connectToggle.classList.add('connect-toggle');
    connectToggle.title = 'Toggle connect mode';
    header.appendChild(connectToggle);

    const minusBtn = document.createElement('button');
    minusBtn.classList.add('font-size-btn');
    minusBtn.textContent = '−';
    minusBtn.title = 'Decrease font size';
    header.appendChild(minusBtn);

    const plusBtn = document.createElement('button');
    plusBtn.classList.add('font-size-btn');
    plusBtn.textContent = '+';
    plusBtn.title = 'Increase font size';
    header.appendChild(plusBtn);

    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Delete box';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content
    const content = document.createElement('div');
    content.classList.add('box-content');
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const rh = document.createElement('div');
      rh.classList.add('resize-handle', corner);
      box.appendChild(rh);
    });

    canvas.appendChild(box);
    boxesMap.set(id, box);

    // Events

    // Dragging boxes
    let dragStartX, dragStartY, origX, origY;
    let dragging = false;

    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.preventDefault();
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      origX = parseFloat(box.style.left);
      origY = parseFloat(box.style.top);
      dragging = true;

      if (e.shiftKey) {
        // Shift+click header to multi-select group
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else if (!selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }

      window.addEventListener('pointermove', dragMove);
      window.addEventListener('pointerup', dragEnd);
    });

    function dragMove(e) {
      if (!dragging) return;
      const dx = (e.clientX - dragStartX) / scale;
      const dy = (e.clientY - dragStartY) / scale;

      if (selectedBoxes.size > 1) {
        selectedBoxes.forEach(b => {
          const startX = parseFloat(b.style.left);
          const startY = parseFloat(b.style.top);
          b.style.left = startX + dx + 'px';
          b.style.top = startY + dy + 'px';
        });
      } else {
        box.style.left = origX + dx + 'px';
        box.style.top = origY + dy + 'px';
      }
      drawConnections();
    }

    function dragEnd(e) {
      if (!dragging) return;
      dragging = false;
      window.removeEventListener('pointermove', dragMove);
      window.removeEventListener('pointerup', dragEnd);
    }

    // Resize handles

    const resizeHandles = Array.from(box.querySelectorAll('.resize-handle'));

    resizeHandles.forEach(handle => {
      let resizing = false;
      let resizeStartX, resizeStartY, startWidth, startHeight, startLeft, startTop;

      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.preventDefault();
        resizing = true;
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        startWidth = parseFloat(box.style.width);
        startHeight = parseFloat(box.style.height);
        startLeft = parseFloat(box.style.left);
        startTop = parseFloat(box.style.top);
        window.addEventListener('pointermove', resizeMove);
        window.addEventListener('pointerup', resizeEnd);
      });

      function resizeMove(e) {
        if (!resizing) return;
        const dx = (e.clientX - resizeStartX) / scale;
        const dy = (e.clientY - resizeStartY) / scale;
        let newW = startWidth;
        let newH = startHeight;
        let newX = startLeft;
        let newY = startTop;

        switch (handle.classList[1]) {
          case 'nw':
            newW = startWidth - dx;
            newH = startHeight - dy;
            newX = startLeft + dx;
            newY = startTop + dy;
            break;
          case 'ne':
            newW = startWidth + dx;
            newH = startHeight - dy;
            newY = startTop + dy;
            break;
          case 'sw':
            newW = startWidth - dx;
            newH = startHeight + dy;
            newX = startLeft + dx;
            break;
          case 'se':
            newW = startWidth + dx;
            newH = startHeight + dy;
            break;
        }

        if (newW >= 80) {
          box.style.width = newW + 'px';
          box.style.left = newX + 'px';
        }
        if (newH >= 40) {
          box.style.height = newH + 'px';
          box.style.top = newY + 'px';
        }
        drawConnections();
      }

      function resizeEnd(e) {
        if (!resizing) return;
        resizing = false;
        window.removeEventListener('pointermove', resizeMove);
        window.removeEventListener('pointerup', resizeEnd);
      }
    });

    // Delete box

    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(id);
    });

    // Connect toggle

    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === null) {
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        // create connection from connectionStartBoxId to id
        addConnection(connectionStartBoxId, id);
        connectionStartBoxId = null;
        // reset all connect buttons
        document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
      }
      drawConnections();
    });

    // Font size buttons

    plusBtn.addEventListener('click', e => {
      e.stopPropagation();
      let fs = parseInt(box.style.fontSize) || 14;
      if (fs < 36) fs++;
      box.style.fontSize = fs + 'px';
    });

    minusBtn.addEventListener('click', e => {
      e.stopPropagation();
      let fs = parseInt(box.style.fontSize) || 14;
      if (fs > 8) fs--;
      box.style.fontSize = fs + 'px';
    });

    // Content editable

    content.contentEditable = editMode;
    content.addEventListener('input', e => {
      // nothing special here, text saved on save
    });

    return box;
  }

  function deleteBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    // Save for undo
    undoStack.push({
      type: 'deleteBox',
      boxData: {
        id,
        left: parseFloat(box.style.left),
        top: parseFloat(box.style.top),
        width: parseFloat(box.style.width),
        height: parseFloat(box.style.height),
        text: box.querySelector('.box-content').textContent,
        fontSize: parseInt(box.style.fontSize) || 14,
      },
      connections: connections.filter(c => c.from === id || c.to === id)
    });
    undoBtn.disabled = false;

    // Remove connections related to this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }

    box.remove();
    boxesMap.delete(id);
    drawConnections();
  }

  function undo() {
    if (undoStack.length === 0) return;
    const action = undoStack.pop();
    if (action.type === 'deleteBox') {
      const b = action.boxData;
      createBox(b.id, b.left, b.top, b.width, b.height, b.text, b.fontSize);
      action.connections.forEach(c => {
        addConnection(c.from, c.to);
      });
      drawConnections();
    }
    undoBtn.disabled = undoStack.length === 0;
  }

  undoBtn.addEventListener('click', undo);

  // Connections

  function addConnection(fromId, toId) {
    if (!boxesMap.has(fromId) || !boxesMap.has(toId)) return;
    // Avoid duplicate connections
    if (connections.some(c => c.from === fromId && c.to === toId)) return;
    connections.push({ from: fromId, to: toId });
    drawConnections();
  }

  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);
    connections.forEach(conn => {
      const fromBox = boxesMap.get(conn.from);
      const toBox = boxesMap.get(conn.to);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.getBoundingClientRect();
      const toRect = toBox.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      // Calculate start and end points in viewport coordinates adjusted by pan & scale
      const startX = (parseFloat(fromBox.style.left) + fromBox.offsetWidth / 2) * scale + panX;
      const startY = (parseFloat(fromBox.style.top) + fromBox.offsetHeight / 2) * scale + panY;
      const endX = (parseFloat(toBox.style.left) + toBox.offsetWidth / 2) * scale + panX;
      const endY = (parseFloat(toBox.style.top) + toBox.offsetHeight / 2) * scale + panY;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", startX);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", endX);
      line.setAttribute("y2", endY);
      line.setAttribute("stroke", "black");
      line.setAttribute("stroke-width", 2);
      line.setAttribute("marker-end", "url(#arrowhead)");

      connectionLayer.appendChild(line);
    });

    if (!document.getElementById('arrowhead')) {
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute("id", "arrowhead");
      marker.setAttribute("markerWidth", "10");
      marker.setAttribute("markerHeight", "7");
      marker.setAttribute("refX", "10");
      marker.setAttribute("refY", "3.5");
      marker.setAttribute("orient", "auto");
      marker.setAttribute("markerUnits", "strokeWidth");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M0,0 L10,3.5 L0,7 Z");
      path.setAttribute("fill", "black");
      marker.appendChild(path);
      defs.appendChild(marker);
      connectionLayer.appendChild(defs);
    }
  }

  // Clear canvas

  function clearCanvas() {
    canvas.innerHTML = '';
    boxesMap.clear();
    connections.length = 0;
    drawConnections();
  }

  // Save and load maps

  async function saveMap() {
    if (!currentMapId) {
      alert("No map selected to save.");
      return;
    }
    const mapName = mapSelect.options[mapSelect.selectedIndex]?.text || 'Untitled';

    // Collect data
    const boxesData = [];
    boxesMap.forEach(box => {
      boxesData.push({
        id: box.dataset.id,
        left: parseFloat(box.style.left),
        top: parseFloat(box.style.top),
        width: parseFloat(box.style.width),
        height: parseFloat(box.style.height),
        text: box.querySelector('.box-content').textContent,
        fontSize: parseInt(box.style.fontSize) || 14,
      });
    });

    const mapData = {
      name: mapName,
      boxes: boxesData,
      connections,
      center: { x: panX, y: panY, scale }
    };

    try {
      await setDoc(doc(db, "maps", currentMapId), mapData);
      mapsCache.set(currentMapId, mapData);
      saveStatus.textContent = "Saved";
      setTimeout(() => saveStatus.textContent = '', 2000);
      await loadMapsList();
    } catch(e) {
      alert("Error saving map: " + e.message);
    }
  }

  saveMapBtn.addEventListener('click', saveMap);

  // Load map list from Firebase

  async function loadMapsList() {
    try {
      const querySnapshot = await getDocs(collection(db, "maps"));
      mapSelect.innerHTML = '';
      querySnapshot.forEach(docSnap => {
        const data = docSnap.data();
        const option = document.createElement('option');
        option.value = docSnap.id;
        option.textContent = data.name || docSnap.id;
        mapSelect.appendChild(option);
        mapsCache.set(docSnap.id, data);
      });
      if (currentMapId && mapsCache.has(currentMapId)) {
        mapSelect.value = currentMapId;
      }
    } catch(e) {
      console.error("Error loading maps list:", e);
    }
  }

  mapSelect.addEventListener('change', async () => {
    const newId = mapSelect.value;
    await loadMap(newId);
  });

  // Fixed loadMap function with getDoc

  async function loadMap(mapId) {
    if (!mapId) return;
    clearCanvas();
    currentMapId = mapId;

    if (mapsCache.has(mapId)) {
      const data = mapsCache.get(mapId);
      loadMapData(data);
    } else {
      try {
        // Fetch the single map document
        const docSnap = await getDoc(doc(db, "maps", mapId));
        if (docSnap.exists()) {
          const data = docSnap.data();
          mapsCache.set(mapId, data);
          loadMapData(data);
        } else {
          clearCanvas();
          console.warn(`Map "${mapId}" not found.`);
        }
        // Refresh map list options in dropdown
        await loadMapsList();
      } catch(e) {
        console.error("Error loading map:", e);
      }
    }
  }

  // Load map data into canvas

  function loadMapData(data) {
    if (!data) return;
    if (data.boxes) {
      data.boxes.forEach(b => {
        createBox(b.id, b.left, b.top, b.width, b.height, b.text, b.fontSize);
      });
    }
    if (data.connections) {
      connections.length = 0;
      data.connections.forEach(c => {
        if (c.from && c.to) {
          connections.push(c);
        }
      });
    }
    if (data.center) {
      panX = data.center.x || 0;
      panY = data.center.y || 0;
      scale = data.center.scale || 1;
    } else {
      panX = 0; panY = 0; scale = 1;
    }
    updateTransform();
    drawConnections();
  }

  // Rename map

  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    const newName = prompt("Enter new map name:");
    if (!newName) return;
    try {
      const data = mapsCache.get(currentMapId) || {};
      data.name = newName;
      await setDoc(doc(db, "maps", currentMapId), data);
      mapsCache.set(currentMapId, data);
      await loadMapsList();
      mapSelect.value = currentMapId;
    } catch(e) {
      alert("Error renaming map: " + e.message);
    }
  });

  // Delete map

  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    if (!confirm(`Delete map "${mapSelect.options[mapSelect.selectedIndex].text}"? This cannot be undone.`)) return;
    try {
      await deleteDoc(doc(db, "maps", currentMapId));
      mapsCache.delete(currentMapId);
      clearCanvas();
      currentMapId = null;
      await loadMapsList();
    } catch(e) {
      alert("Error deleting map: " + e.message);
    }
  });

  // New map

  newMapBtn.addEventListener('click', async () => {
    let newName = prompt("Enter new map name:");
    if (!newName) return;
    let newId = generateId();
    while (mapsCache.has(newId)) newId = generateId();

    const newMapData = {
      name: newName,
      boxes: [],
      connections: [],
      center: { x: 0, y: 0, scale: 1 }
    };
    try {
      await setDoc(doc(db, "maps", newId), newMapData);
      mapsCache.set(newId, newMapData);
      currentMapId = newId;
      clearCanvas();
      panX = 0; panY = 0; scale = 1;
      updateTransform();
      await loadMapsList();
      mapSelect.value = newId;
    } catch(e) {
      alert("Error creating new map: " + e.message);
    }
  });

  // Centering

  let markedCenter = { x: 0, y: 0, scale: 1 };

  markCenterBtn.addEventListener('click', () => {
    markedCenter = { x: panX, y: panY, scale };
  });

  goCenterBtn.addEventListener('click', () => {
    panX = markedCenter.x;
    panY = markedCenter.y;
    scale = markedCenter.scale;
    updateTransform();
  });

  // Toggle edit mode

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'Toggle Edit Mode';
    boxesMap.forEach(box => {
      box.querySelector('.box-content').contentEditable = editMode;
      box.querySelector('.connect-toggle').disabled = !editMode;
      box.querySelector('.delete-btn').disabled = !editMode;
      box.querySelectorAll('.resize-handle').forEach(rh => rh.style.display = editMode ? 'block' : 'none');
      box.querySelector('.drag-handle').style.cursor = editMode ? 'move' : 'default';
    });
    if (!editMode) {
      // Clear connection start states
      connectionStartBoxId = null;
      document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
    }
  });

  // How to use modal

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });

  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Double click to create box

  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target.closest('.box')) return;
    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    const id = generateId();
    createBox(id, x, y);
    drawConnections();
  });

  // Initial load

  loadMapsList().then(() => {
    // Auto select first map if available
    if (mapSelect.options.length > 0) {
      currentMapId = mapSelect.options[0].value;
      loadMap(currentMapId);
    }
  });
</script>

</body>
</html>
