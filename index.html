<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthingsfinal</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
  }
  #canvas {
    position: absolute; top: 0; left: 0;
    width: 10000px; height: 10000px; /* Large canvas for panning */
    transform-origin: 0 0;
    z-index: 10;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    min-width: 80px;
    min-height: 40px;
    user-select: none;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    cursor: text;
    overflow: hidden;
    transition: width 0.1s ease, height 0.1s ease;
  }
  .box.selected {
    outline: 2px dashed blue;
  }
  .box-header {
    background: #ddd;
    padding-left: 24px;
    min-width: 40px;
    min-height: 18px;
    height: 18px;
    box-sizing: border-box;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 4px;
    position: relative;
    user-select: none;
    cursor: default;
    border-bottom: 1px solid #bbb;
    font-size: 12px;
    flex-shrink: 0;
  }
  .drag-handle {
    position: absolute;
    left: 4px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 14px;
    cursor: move;
    user-select: none;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #333;
    white-space: nowrap;
    z-index: 5;
  }
  .delete-btn {
    color: red;
    font-weight: bold;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    user-select: none;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .connect-toggle {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: none;
    background-color: blue;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.25s ease;
    padding: 0;
    margin: 0;
    flex-shrink: 0;
  }
  .connect-toggle.active {
    background-color: green;
  }
  .font-size-btn {
    font-size: 14px;
    width: 18px;
    height: 18px;
    line-height: 1;
    cursor: pointer;
    user-select: none;
    background: transparent;
    border: none;
    color: black;
    padding: 0;
    margin: 0 2px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .box-content {
    flex: 1;
    padding: 2px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    overflow-wrap: break-word;
    outline: none;
    cursor: text;
    user-select: text;
    line-height: 1.1;
    min-height: 24px;
    box-sizing: border-box;
    resize: none;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    word-break: break-word;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

  .palette-btn {
    width: 18px;
    height: 18px;
    padding: 0;
    margin: 0 2px 0 2px;
    border: none;
    background: transparent;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    user-select: none;
    color: #444;
    position: relative;
  }
  .palette-btn:hover {
    color: #000;
  }

  .swatch-container {
    position: absolute;
    top: 22px;
    right: 0;
    background: white;
    border: 1px solid #aaa;
    border-radius: 4px;
    padding: 4px;
    display: flex;
    gap: 4px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    z-index: 50;
    user-select: none;
  }
  .swatch {
    width: 18px;
    height: 18px;
    border: 1px solid #888;
    border-radius: 3px;
    cursor: pointer;
    box-sizing: border-box;
    transition: transform 0.1s ease;
  }
  .swatch:hover {
    transform: scale(1.2);
    border-color: #333;
  }
  input[type=color] {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    width: 1px;
    height: 1px;
  }

  #topMenu {
    position: fixed;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(240, 240, 240, 0.95);
    border: 1px solid #bbb;
    border-radius: 6px;
    padding: 6px 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: monospace;
    z-index: 10000;
    box-shadow: 0 0 8px rgba(0,0,0,0.1);
    user-select: none;
  }
  #mapSelect {
    font-family: monospace;
    font-size: 14px;
    padding: 2px 4px;
    border-radius: 4px;
    border: 1px solid #888;
    cursor: pointer;
    min-width: 150px;
  }
  #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
    background: #555;
    color: #eee;
    border: none;
    border-radius: 4px;
    padding: 4px 10px;
    cursor: pointer;
    font-family: monospace;
    font-size: 14px;
    user-select: none;
    transition: background-color 0.2s ease;
  }
  #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
    background: #333;
  }
  #saveStatus {
    font-size: 13px;
    color: green;
    min-width: 90px;
    user-select: none;
  }

  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
    user-select: none;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }
  #zoomDisplay {
    position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.5); color: white; font-family: monospace;
    padding: 4px 8px; border-radius: 4px;
    user-select: none; pointer-events: none; z-index: 1001;
  }
  #connectionLayer {
    position: absolute;
    top: 0; left: 0;
    width: 10000px; height: 10000px;
    pointer-events: none;
    z-index: 1;
    transform-origin: 0 0;
  }
  #footerInfo {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    font-family: monospace, monospace;
    font-size: 14px;
    color: #555;
    user-select: none;
    z-index: 1002;
    background: rgba(255,255,255,0.9);
    padding: 4px 8px;
    border-radius: 4px;
    box-shadow: 0 0 5px rgba(0,0,0,0.1);
    pointer-events: none;
    width: max-content;
    max-width: 90vw;
    text-align: center;
  }
</style>
</head>
<body>
<div id="topMenu">
  <select id="mapSelect" title="Select a mind map"></select>
  <button id="saveMapBtn" title="Save current mind map">Save</button>
  <button id="renameMapBtn" title="Rename current mind map">Rename</button>
  <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
  <button id="newMapBtn" title="Create new mind map">New Map</button>
  <div id="saveStatus"></div>
</div>

<div id="viewport">
  <svg id="connectionLayer" width="10000" height="10000"></svg>
  <div id="canvas"></div>
</div>

<div id="buttonContainer">
  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
  <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
  <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map();

  let markedCenter = null; // {x, y} in canvas coords

  // Global recent colors list for swatches, max 8
  let recentColors = [];

  // Helper to get pointer coords
  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  // Generate unique ID for boxes and maps
  function generateId() {
    return 'id-' + Math.random().toString(36).slice(2, 11);
  }

  // Update pan and zoom transform on canvas and connections layer
  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    connectionLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Pan handling on empty canvas
  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // Clear selection on empty space click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  // Zoom with mouse wheel
  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Create new box element
  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14, bgColor = '') {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.dataset.id = id;
    box.style.fontSize = fontSize + 'px';

    // Apply background color if any, with 10% opacity
    if (bgColor) {
      box.style.backgroundColor = applyOpacityToColor(bgColor, 0.1);
      box.dataset.bgcolor = bgColor;
    }

    // Header
    const header = document.createElement('div');
    header.classList.add('box-header');
    header.style.display = editMode ? 'flex' : 'none';

    // Drag handle "✥"
    const dragHandle = document.createElement('div');
    dragHandle.classList.add('drag-handle');
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle
    const connectToggle = document.createElement('button');
    connectToggle.classList.add('connect-toggle');
    connectToggle.title = 'Toggle connection for this box';
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      connectToggle.classList.toggle('active');
      if (connectToggle.classList.contains('active')) {
        // If connection start not set, set it to this box
        if (!connectionStartBoxId) {
          connectionStartBoxId = id;
          connectToggle.title = 'Selected as connection start';
        } else if (connectionStartBoxId !== id) {
          // Connect start to this box
          createConnection(connectionStartBoxId, id);
          connectionStartBoxId = null;
          // Clear all toggles active state
          clearAllConnectToggles();
        }
      } else {
        if (connectionStartBoxId === id) connectionStartBoxId = null;
        connectToggle.title = 'Toggle connection for this box';
      }
      drawConnections();
    });
    header.appendChild(connectToggle);

    // Palette button with paint emoji 🎨
    const paletteBtn = document.createElement('button');
    paletteBtn.classList.add('palette-btn');
    paletteBtn.title = 'Pick background color';
    paletteBtn.textContent = '🎨';
    header.appendChild(paletteBtn);

    // Hidden color input for system color picker
    const colorInput = document.createElement('input');
    colorInput.type = 'color';
    colorInput.style.position = 'absolute';
    colorInput.style.opacity = '0';
    colorInput.style.pointerEvents = 'none';
    header.appendChild(colorInput);

    // Swatch container (hidden by default)
    const swatchContainer = document.createElement('div');
    swatchContainer.classList.add('swatch-container');
    swatchContainer.style.display = 'none';
    header.appendChild(swatchContainer);

    paletteBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (swatchContainer.style.display === 'flex') {
        swatchContainer.style.display = 'none';
      } else {
        updateSwatches(swatchContainer, id);
        swatchContainer.style.display = 'flex';
      }
    });

    colorInput.addEventListener('input', e => {
      e.stopPropagation();
      const pickedColor = e.target.value;
      applyBoxColor(id, pickedColor);
      addRecentColor(pickedColor);
      updateAllSwatches();
      saveBoxesDebounced();
    });

    // Clicking swatch sets color
    function createSwatch(color) {
      const sw = document.createElement('div');
      sw.classList.add('swatch');
      sw.style.backgroundColor = color;
      sw.title = color;
      sw.addEventListener('click', e => {
        e.stopPropagation();
        applyBoxColor(id, color);
        addRecentColor(color);
        updateAllSwatches();
        saveBoxesDebounced();
      });
      return sw;
    }

    function updateSwatches(container, boxId) {
      container.innerHTML = '';
      if (recentColors.length === 0) {
        const noColors = document.createElement('div');
        noColors.textContent = 'No recent colors';
        noColors.style.padding = '2px 6px';
        noColors.style.color = '#888';
        container.appendChild(noColors);
      } else {
        recentColors.forEach(c => container.appendChild(createSwatch(c)));
      }
    }

    // Box content (editable div)
    const content = document.createElement('div');
    content.classList.add('box-content');
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.textContent = text;
    box.appendChild(header);
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = document.createElement('div');
      handle.classList.add('resize-handle', corner);
      box.appendChild(handle);
    });

    // Delete button inside header on right side
    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.title = 'Delete this box';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(id);
    });

    // Event: drag move box by drag handle
    let dragging = false;
    let dragStartX, dragStartY;
    let boxStartX, boxStartY;

    dragHandle.addEventListener('pointerdown', e => {
      e.preventDefault();
      e.stopPropagation();
      dragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      const rect = box.getBoundingClientRect();
      boxStartX = parseFloat(box.style.left);
      boxStartY = parseFloat(box.style.top);
      viewport.setPointerCapture(e.pointerId);
    });

    dragHandle.addEventListener('pointermove', e => {
      if (!dragging) return;
      e.preventDefault();
      const dx = (e.clientX - dragStartX) / scale;
      const dy = (e.clientY - dragStartY) / scale;
      let newX = boxStartX + dx;
      let newY = boxStartY + dy;
      if (selectedBoxes.has(box)) {
        // Move all selected boxes by dx, dy relative to their start pos
        selectedBoxes.forEach(b => {
          if (b === box) {
            b.style.left = newX + 'px';
            b.style.top = newY + 'px';
          } else {
            const startPos = b._dragStartPos;
            if (startPos) {
              b.style.left = (startPos.x + dx) + 'px';
              b.style.top = (startPos.y + dy) + 'px';
            }
          }
        });
      } else {
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';
      }
      drawConnections();
    });

    dragHandle.addEventListener('pointerup', e => {
      if (!dragging) return;
      dragging = false;
      viewport.releasePointerCapture(e.pointerId);
      // Save drag start positions to each selected box for future moves
      if (selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => {
          b._dragStartPos = { x: parseFloat(b.style.left), y: parseFloat(b.style.top) };
        });
      }
      saveBoxesDebounced();
    });

    // On drag start: store drag start positions for all selected boxes for group move
    dragHandle.addEventListener('pointerdown', e => {
      if (selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => {
          b._dragStartPos = { x: parseFloat(b.style.left), y: parseFloat(b.style.top) };
        });
      } else {
        box._dragStartPos = { x: parseFloat(box.style.left), y: parseFloat(box.style.top) };
      }
    });

    // Resize logic
    let resizing = false;
    let resizeDir = null;
    let resizeStartX, resizeStartY;
    let boxStartW, boxStartH;
    let boxStartLeft, boxStartTop;

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        e.preventDefault();
        e.stopPropagation();
        resizing = true;
        resizeDir = handle.classList.contains('nw') ? 'nw' :
          handle.classList.contains('ne') ? 'ne' :
            handle.classList.contains('sw') ? 'sw' : 'se';
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        boxStartW = box.offsetWidth;
        boxStartH = box.offsetHeight;
        boxStartLeft = parseFloat(box.style.left);
        boxStartTop = parseFloat(box.style.top);
        viewport.setPointerCapture(e.pointerId);
      });
    });

    viewport.addEventListener('pointermove', e => {
      if (!resizing) return;
      e.preventDefault();
      let dx = (e.clientX - resizeStartX) / scale;
      let dy = (e.clientY - resizeStartY) / scale;
      let newW = boxStartW;
      let newH = boxStartH;
      let newLeft = boxStartLeft;
      let newTop = boxStartTop;

      if (resizeDir.includes('n')) {
        newH = boxStartH - dy;
        newTop = boxStartTop + dy;
        if (newH < 30) {
          newTop -= 30 - newH;
          newH = 30;
        }
      }
      if (resizeDir.includes('w')) {
        newW = boxStartW - dx;
        newLeft = boxStartLeft + dx;
        if (newW < 60) {
          newLeft -= 60 - newW;
          newW = 60;
        }
      }
      if (resizeDir.includes('s')) {
        newH = boxStartH + dy;
        if (newH < 30) newH = 30;
      }
      if (resizeDir.includes('e')) {
        newW = boxStartW + dx;
        if (newW < 60) newW = 60;
      }

      box.style.width = newW + 'px';
      box.style.height = newH + 'px';
      box.style.left = newLeft + 'px';
      box.style.top = newTop + 'px';
      drawConnections();
    });

    viewport.addEventListener('pointerup', e => {
      if (resizing) {
        resizing = false;
        viewport.releasePointerCapture(e.pointerId);
        saveBoxesDebounced();
      }
    });

    // Content editable events
    content.addEventListener('input', e => {
      saveBoxesDebounced();
    });

    // Font size controls could be added here if needed in the future

    // Selection by clicking box header with shift to multi-select
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (e.target === paletteBtn || e.target === deleteBtn || e.target === connectToggle) return;
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });

    // Allow clicking drag handle to select box with shift too
    dragHandle.addEventListener('click', e => {
      if (!editMode) return;
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });

    canvas.appendChild(box);
    boxesMap.set(id, box);

    return box;
  }

  // Apply background color with 10% opacity to box
  function applyBoxColor(boxId, color) {
    const box = boxesMap.get(boxId);
    if (!box) return;
    box.dataset.bgcolor = color;
    box.style.backgroundColor = applyOpacityToColor(color, 0.1);
  }

  // Add color to global recent colors array, max 8, newest first, no duplicates
  function addRecentColor(color) {
    const i = recentColors.indexOf(color);
    if (i !== -1) recentColors.splice(i, 1);
    recentColors.unshift(color);
    if (recentColors.length > 8) recentColors.length = 8;
  }

  // Update swatches for all boxes currently visible
  function updateAllSwatches() {
    boxesMap.forEach(box => {
      const header = box.querySelector('.box-header');
      if (!header) return;
      const swatchContainer = header.querySelector('.swatch-container');
      if (!swatchContainer) return;
      if (swatchContainer.style.display === 'flex') {
        swatchContainer.innerHTML = '';
        if (recentColors.length === 0) {
          const noColors = document.createElement('div');
          noColors.textContent = 'No recent colors';
          noColors.style.padding = '2px 6px';
          noColors.style.color = '#888';
          swatchContainer.appendChild(noColors);
        } else {
          recentColors.forEach(c => {
            const sw = document.createElement('div');
            sw.classList.add('swatch');
            sw.style.backgroundColor = c;
            sw.title = c;
            sw.addEventListener('click', e => {
              e.stopPropagation();
              applyBoxColor(box.dataset.id, c);
              addRecentColor(c);
              updateAllSwatches();
              saveBoxesDebounced();
            });
            swatchContainer.appendChild(sw);
          });
        }
      }
    });
  }

  // Converts hex color to rgba string with specified opacity (0 to 1)
  function applyOpacityToColor(hex, opacity) {
    if (!hex) return '';
    // Remove #
    hex = hex.replace('#','');
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    const r = parseInt(hex.substring(0,2),16);
    const g = parseInt(hex.substring(2,4),16);
    const b = parseInt(hex.substring(4,6),16);
    return `rgba(${r},${g},${b},${opacity})`;
  }

  // Delete a box and push undo info
  function deleteBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    const boxData = getBoxData(box);
    undoStack.push(boxData);
    undoBtn.disabled = false;
    box.remove();
    boxesMap.delete(id);
    // Remove connections related to box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) connections.splice(i, 1);
    }
    drawConnections();
    saveBoxesDebounced();
  }

  // Undo last delete
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const boxData = undoStack.pop();
    createBox(boxData.id, boxData.x, boxData.y, boxData.w, boxData.h, boxData.text, boxData.fontSize, boxData.bgColor);
    undoBtn.disabled = undoStack.length === 0;
    saveBoxesDebounced();
  });

  // Get box data from DOM element
  function getBoxData(box) {
    return {
      id: box.dataset.id,
      x: parseFloat(box.style.left),
      y: parseFloat(box.style.top),
      w: box.offsetWidth,
      h: box.offsetHeight,
      text: box.querySelector('.box-content').textContent || '',
      fontSize: parseFloat(box.style.fontSize) || 14,
      bgColor: box.dataset.bgcolor || ''
    };
  }

  // Save all boxes to current map
  let saveTimeout = null;
  function saveBoxesDebounced() {
    if (!currentMapId) return;
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(saveBoxes, 600);
  }
  async function saveBoxes() {
    if (!currentMapId) return;
    const boxData = [];
    boxesMap.forEach(box => {
      boxData.push(getBoxData(box));
    });
    // Save map object including boxes and connections and recent colors
    const mapDoc = doc(db, 'maps', currentMapId);
    try {
      await setDoc(mapDoc, {
        boxes: boxData,
        connections,
        recentColors,
        markedCenter
      });
      saveStatus.textContent = 'Saved';
      setTimeout(() => {
        if (saveStatus.textContent === 'Saved') saveStatus.textContent = '';
      }, 1200);
    } catch (e) {
      saveStatus.textContent = 'Save failed';
      console.error('Save failed', e);
    }
  }

  // Load map by ID
  async function loadMap(id) {
    currentMapId = id;
    undoStack.length = 0;
    undoBtn.disabled = true;
    boxesMap.forEach(box => box.remove());
    boxesMap.clear();
    connections.length = 0;
    recentColors = [];
    markedCenter = null;
    updateTransform();

    const mapDoc = doc(db, 'maps', id);
    try {
      const snapshot = await getDoc(mapDoc);
      if (!snapshot.exists()) {
        alert('Map does not exist: ' + id);
        return;
      }
      const data = snapshot.data();
      if (data.boxes && Array.isArray(data.boxes)) {
        data.boxes.forEach(b => {
          createBox(b.id, b.x, b.y, b.w, b.h, b.text, b.fontSize || 14, b.bgColor || '');
        });
      }
      if (data.connections && Array.isArray(data.connections)) {
        connections.length = 0;
        data.connections.forEach(c => connections.push(c));
      }
      if (data.recentColors && Array.isArray(data.recentColors)) {
        recentColors = data.recentColors;
      }
      if (data.markedCenter) {
        markedCenter = data.markedCenter;
      }
      drawConnections();
      updateAllSwatches();
      updateTransform();
    } catch (e) {
      alert('Failed to load map: ' + e.message);
      console.error(e);
    }
  }

  // List all maps in select
  async function listMaps() {
    const mapsCol = collection(db, 'maps');
    try {
      const snapshots = await getDocs(mapsCol);
      mapsCache.clear();
      mapSelect.innerHTML = '';
      snapshots.forEach(docSnap => {
        const id = docSnap.id;
        const data = docSnap.data();
        const option = document.createElement('option');
        option.value = id;
        option.textContent = data.name || id;
        mapsCache.set(id, data);
        mapSelect.appendChild(option);
      });
      if (mapSelect.options.length === 0) {
        const defaultId = 'id-19dmwrpql';
        mapSelect.innerHTML = '';
        const option = document.createElement('option');
        option.value = defaultId;
        option.textContent = defaultId;
        mapSelect.appendChild(option);
        await createNewMap(defaultId);
      }
      // Select first or current if available
      if (currentMapId && [...mapSelect.options].some(o => o.value === currentMapId)) {
        mapSelect.value = currentMapId;
      } else {
        mapSelect.selectedIndex = 0;
        currentMapId = mapSelect.value;
      }
      await loadMap(currentMapId);
    } catch (e) {
      alert('Failed to list maps: ' + e.message);
      console.error(e);
    }
  }

  // Create new empty map
  async function createNewMap(id = null) {
    if (!id) id = generateId();
    try {
      const mapDoc = doc(db, 'maps', id);
      await setDoc(mapDoc, {
        boxes: [],
        connections: [],
        recentColors: [],
        name: id,
        markedCenter: null
      });
      mapsCache.set(id, { name: id });
      const option = document.createElement('option');
      option.value = id;
      option.textContent = id;
      mapSelect.appendChild(option);
      mapSelect.value = id;
      currentMapId = id;
      await loadMap(id);
    } catch (e) {
      alert('Failed to create new map: ' + e.message);
      console.error(e);
    }
  }

  // Rename current map
  async function renameMap() {
    if (!currentMapId) return;
    const newName = prompt('Enter new name for this map:', mapsCache.get(currentMapId)?.name || currentMapId);
    if (!newName) return;
    try {
      const mapDoc = doc(db, 'maps', currentMapId);
      await setDoc(mapDoc, { name: newName }, { merge: true });
      mapsCache.get(currentMapId).name = newName;
      [...mapSelect.options].forEach(opt => {
        if (opt.value === currentMapId) opt.textContent = newName;
      });
      mapSelect.value = currentMapId;
    } catch (e) {
      alert('Failed to rename map: ' + e.message);
      console.error(e);
    }
  }

  // Delete current map
  async function deleteMap() {
    if (!currentMapId) return;
    if (!confirm('Delete map "' + (mapsCache.get(currentMapId)?.name || currentMapId) + '"?')) return;
    try {
      const mapDoc = doc(db, 'maps', currentMapId);
      await deleteDoc(mapDoc);
      mapsCache.delete(currentMapId);
      [...mapSelect.options].forEach(opt => {
        if (opt.value === currentMapId) opt.remove();
      });
      if (mapSelect.options.length > 0) {
        currentMapId = mapSelect.value = mapSelect.options[0].value;
        await loadMap(currentMapId);
      } else {
        await createNewMap();
      }
    } catch (e) {
      alert('Failed to delete map: ' + e.message);
      console.error(e);
    }
  }

  // Handle map select change
  mapSelect.addEventListener('change', async e => {
    if (!editMode) {
      alert('Save current edits before switching maps.');
      mapSelect.value = currentMapId;
      return;
    }
    currentMapId = mapSelect.value;
    await loadMap(currentMapId);
  });

  saveMapBtn.addEventListener('click', () => {
    saveBoxes();
  });

  renameMapBtn.addEventListener('click', () => {
    renameMap();
  });

  deleteMapBtn.addEventListener('click', () => {
    deleteMap();
  });

  newMapBtn.addEventListener('click', async () => {
    if (!editMode) {
      alert('Enable edit mode to create new map.');
      return;
    }
    await createNewMap();
  });

  // Undo button
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const boxData = undoStack.pop();
    createBox(boxData.id, boxData.x, boxData.y, boxData.w, boxData.h, boxData.text, boxData.fontSize, boxData.bgColor);
    undoBtn.disabled = undoStack.length === 0;
    saveBoxesDebounced();
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    [...boxesMap.values()].forEach(box => {
      box.querySelector('.box-header').style.display = editMode ? 'flex' : 'none';
      box.querySelector('.box-content').contentEditable = editMode;
      box.style.cursor = editMode ? 'text' : 'default';
      if (!editMode) {
        // Clear selection and connection toggles when exiting edit mode
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        clearAllConnectToggles();
        connectionStartBoxId = null;
      }
    });
    undoBtn.disabled = !editMode || undoStack.length === 0;
  });

  // Clear all connection toggles active states
  function clearAllConnectToggles() {
    boxesMap.forEach(box => {
      const toggle = box.querySelector('.connect-toggle');
      if (toggle) {
        toggle.classList.remove('active');
        toggle.title = 'Toggle connection for this box';
      }
    });
  }

  // Connections management
  function createConnection(fromId, toId) {
    // Prevent duplicate connections (undirected)
    if (connections.some(c => (c.from === fromId && c.to === toId) || (c.from === toId && c.to === fromId))) return;
    connections.push({ from: fromId, to: toId });
  }

  // Draw connections as curved Bezier lines on SVG
  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.firstChild.remove();
    connections.forEach(conn => {
      const fromBox = boxesMap.get(conn.from);
      const toBox = boxesMap.get(conn.to);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.getBoundingClientRect();
      const toRect = toBox.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      // Calculate box center coords in canvas coordinates (before transform)
      const fromX = parseFloat(fromBox.style.left) + fromBox.offsetWidth / 2;
      const fromY = parseFloat(fromBox.style.top) + fromBox.offsetHeight / 2;
      const toX = parseFloat(toBox.style.left) + toBox.offsetWidth / 2;
      const toY = parseFloat(toBox.style.top) + toBox.offsetHeight / 2;

      // Draw slightly curved path between centers
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const dx = toX - fromX;
      const dy = toY - fromY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const cpOffset = Math.min(100, dist / 3);
      // Control points for smooth curve
      const cp1x = fromX + cpOffset * (dy / dist);
      const cp1y = fromY - cpOffset * (dx / dist);
      const cp2x = toX + cpOffset * (dy / dist);
      const cp2y = toY - cpOffset * (dx / dist);

      const d = `M${fromX},${fromY} C${cp1x},${cp1y} ${cp2x},${cp2y} ${toX},${toY}`;
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      path.style.pointerEvents = 'auto';
      path.style.cursor = 'pointer';

      // Remove connection on click with confirmation
      path.addEventListener('click', e => {
        e.stopPropagation();
        if (confirm('Delete this connection?')) {
          const index = connections.findIndex(c => c.from === conn.from && c.to === conn.to);
          if (index >= 0) {
            connections.splice(index, 1);
            drawConnections();
            saveBoxesDebounced();
          }
        }
      });

      connectionLayer.appendChild(path);
    });

    // Draw mark center cross if exists
    drawMarkCenter();
  }

  // Mark center related

  markCenterBtn.addEventListener('click', () => {
    // Mark current center in canvas coords
    markedCenter = {
      x: (-panX) / scale + viewport.clientWidth / (2 * scale),
      y: (-panY) / scale + viewport.clientHeight / (2 * scale)
    };
    drawMarkCenter();
    saveBoxesDebounced();
  });

  goCenterBtn.addEventListener('click', () => {
    if (!markedCenter) return;
    panX = viewport.clientWidth / 2 - markedCenter.x * scale;
    panY = viewport.clientHeight / 2 - markedCenter.y * scale;
    updateTransform();
  });

  // Draw cross at marked center in SVG
  function drawMarkCenter() {
    // Remove old marker
    const oldMarker = connectionLayer.querySelector('#markCenterCross');
    if (oldMarker) oldMarker.remove();
    if (!markedCenter) return;
    const crossSize = 20;
    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.setAttribute('id', 'markCenterCross');
    group.style.pointerEvents = 'none';

    const line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line1.setAttribute('x1', markedCenter.x - crossSize/2);
    line1.setAttribute('y1', markedCenter.y);
    line1.setAttribute('x2', markedCenter.x + crossSize/2);
    line1.setAttribute('y2', markedCenter.y);
    line1.setAttribute('stroke', 'red');
    line1.setAttribute('stroke-width', '3');

    const line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line2.setAttribute('x1', markedCenter.x);
    line2.setAttribute('y1', markedCenter.y - crossSize/2);
    line2.setAttribute('x2', markedCenter.x);
    line2.setAttribute('y2', markedCenter.y + crossSize/2);
    line2.setAttribute('stroke', 'red');
    line2.setAttribute('stroke-width', '3');

    group.appendChild(line1);
    group.appendChild(line2);
    connectionLayer.appendChild(group);
  }

  // Double click to create new box at exact click canvas position
  canvas.addEventListener('dblclick', e => {
    if (!editMode) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / scale;
    const y = (e.clientY - rect.top) / scale;
    const id = generateId();
    createBox(id, x, y);
    saveBoxesDebounced();
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', e => {
    if (!editMode) return;
    // Delete selected boxes with Del or Backspace
    if (e.key === 'Delete' || e.key === 'Backspace') {
      e.preventDefault();
      selectedBoxes.forEach(box => {
        deleteBox(box.dataset.id);
      });
      selectedBoxes.clear();
      saveBoxesDebounced();
    }
  });

  // Initialization
  await listMaps();
  updateTransform();

</script>
</body>
</html>
