<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv33</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
      /* Remove blue outline */
    }
    /* Removed .box.selected outline */
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .box-header.view-mode {
      display: none !important;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map();

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // Clear selection on pan start
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  // Box creation
  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target.closest('.box')) return; // prevent creating on existing box
    const coords = getClientCoords(e);
    // Calculate position relative to canvas with pan & zoom
    const x = (coords.x - panX) / scale - 100;
    const y = (coords.y - panY) / scale - 20;
    createBox(x, y, "New box");
  });

  // Create a box element and add it to canvas and internal map
  function createBox(x, y, text, fontSize=14, id=null) {
    if (!id) id = generateId();

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = '160px';
    box.style.height = '60px';
    box.dataset.id = id;
    box.dataset.fontSize = fontSize;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header' + (editMode ? '' : ' view-mode');
    header.title = "Drag (✥) | Delete (x) | Connect (blue) | Resize (corners) | Font size (+/-)";
    box.appendChild(header);

    // Drag handle
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Click to select this box for connection';
    header.appendChild(connectToggle);

    // Font size controls
    const fontDownBtn = document.createElement('button');
    fontDownBtn.className = 'font-size-btn';
    fontDownBtn.textContent = '−';
    fontDownBtn.title = 'Decrease font size';
    header.appendChild(fontDownBtn);

    const fontUpBtn = document.createElement('button');
    fontUpBtn.className = 'font-size-btn';
    fontUpBtn.textContent = '+';
    fontUpBtn.title = 'Increase font size';
    header.appendChild(fontUpBtn);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Delete this box';
    header.appendChild(deleteBtn);

    // Content editable text
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const rh = document.createElement('div');
      rh.className = 'resize-handle ' + corner;
      box.appendChild(rh);
    });

    // Add box to DOM and map
    canvas.appendChild(box);
    boxesMap.set(id, { element: box, connectionsOut: new Set(), connectionsIn: new Set() });

    // Add event listeners
    setupBoxListeners(box);

    return id;
  }

  // Setup event listeners for box controls
  function setupBoxListeners(box) {
    const id = box.dataset.id;
    const header = box.querySelector('.box-header');
    const dragHandle = box.querySelector('.drag-handle');
    const deleteBtn = box.querySelector('.delete-btn');
    const connectToggle = box.querySelector('.connect-toggle');
    const fontUpBtn = box.querySelector('.font-size-btn:last-of-type');
    const fontDownBtn = box.querySelector('.font-size-btn:first-of-type');
    const content = box.querySelector('.box-content');
    const resizeHandles = box.querySelectorAll('.resize-handle');

    // Dragging variables
    let dragStartX, dragStartY;
    let boxStartX, boxStartY;
    let dragging = false;
    let draggingGroup = false;
    let dragPointerId = null;

    // Multi-select & drag support
    function addToSelection() {
      if (!selectedBoxes.has(box)) {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    }

    // Shift+click header selects multiple
    header.addEventListener('mousedown', e => {
      if (!editMode) return;
      if (e.target === dragHandle) {
        // start dragging on drag handle
        e.preventDefault();
        addToSelection();
        startDrag(e);
        return;
      }
      if (e.shiftKey) {
        e.preventDefault();
        addToSelection();
      } else {
        // Clear previous selection, select only this box
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        addToSelection();
      }
    });

    function startDrag(e) {
      if (!editMode) return;
      dragging = true;
      draggingGroup = selectedBoxes.size > 1;
      dragPointerId = e.pointerId;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      boxStartX = parseFloat(box.style.left);
      boxStartY = parseFloat(box.style.top);
      // Store start pos for all selected boxes
      if (draggingGroup) {
        selectedBoxes.forEach(b => {
          b.dataset.dragStartX = parseFloat(b.style.left);
          b.dataset.dragStartY = parseFloat(b.style.top);
        });
      }
      box.setPointerCapture(dragPointerId);
    }

    dragHandle.addEventListener('pointerdown', e => {
      e.preventDefault();
      selectedBoxes.clear();
      selectedBoxes.add(box);
      box.classList.add('selected');
      startDrag(e);
    });

    box.addEventListener('pointermove', e => {
      if (!dragging || e.pointerId !== dragPointerId) return;
      e.preventDefault();
      const dx = (e.clientX - dragStartX) / scale;
      const dy = (e.clientY - dragStartY) / scale;

      if (draggingGroup) {
        selectedBoxes.forEach(b => {
          const startX = parseFloat(b.dataset.dragStartX);
          const startY = parseFloat(b.dataset.dragStartY);
          b.style.left = (startX + dx) + 'px';
          b.style.top = (startY + dy) + 'px';
        });
      } else {
        box.style.left = (boxStartX + dx) + 'px';
        box.style.top = (boxStartY + dy) + 'px';
      }
      drawConnections();
    });

    box.addEventListener('pointerup', e => {
      if (dragging && e.pointerId === dragPointerId) {
        dragging = false;
        box.releasePointerCapture(dragPointerId);
        saveMap();
      }
    });

    box.addEventListener('pointercancel', e => {
      if (dragging && e.pointerId === dragPointerId) {
        dragging = false;
        box.releasePointerCapture(dragPointerId);
      }
    });

    // Delete box
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(id);
    });

    // Connect toggle button
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === null) {
        // Start connection
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else if (connectionStartBoxId === id) {
        // Cancel connection
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        // Create connection
        createConnection(connectionStartBoxId, id);
        clearConnectionToggles();
        connectionStartBoxId = null;
        saveMap();
      }
    });

    // Font size increase
    fontUpBtn.addEventListener('click', e => {
      e.stopPropagation();
      let fs = parseInt(box.dataset.fontSize);
      if (fs < 28) {
        fs++;
        box.dataset.fontSize = fs;
        content.style.fontSize = fs + 'px';
        saveMap();
      }
    });

    // Font size decrease
    fontDownBtn.addEventListener('click', e => {
      e.stopPropagation();
      let fs = parseInt(box.dataset.fontSize);
      if (fs > 8) {
        fs--;
        box.dataset.fontSize = fs;
        content.style.fontSize = fs + 'px';
        saveMap();
      }
    });

    // Resize handles dragging
    resizeHandles.forEach(handle => {
      let resizing = false;
      let resizePointerId = null;
      let startW, startH, startX, startY, startMouseX, startMouseY;

      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        resizing = true;
        resizePointerId = e.pointerId;
        box.setPointerCapture(resizePointerId);
        startW = box.offsetWidth;
        startH = box.offsetHeight;
        startX = parseFloat(box.style.left);
        startY = parseFloat(box.style.top);
        startMouseX = e.clientX;
        startMouseY = e.clientY;
      });

      box.addEventListener('pointermove', e => {
        if (!resizing || e.pointerId !== resizePointerId) return;
        e.preventDefault();
        const dx = (e.clientX - startMouseX) / scale;
        const dy = (e.clientY - startMouseY) / scale;

        switch(handle.classList[1]) {
          case 'nw':
            box.style.left = (startX + dx) + 'px';
            box.style.top = (startY + dy) + 'px';
            box.style.width = Math.max(80, startW - dx) + 'px';
            box.style.height = Math.max(40, startH - dy) + 'px';
            break;
          case 'ne':
            box.style.top = (startY + dy) + 'px';
            box.style.width = Math.max(80, startW + dx) + 'px';
            box.style.height = Math.max(40, startH - dy) + 'px';
            break;
          case 'sw':
            box.style.left = (startX + dx) + 'px';
            box.style.width = Math.max(80, startW - dx) + 'px';
            box.style.height = Math.max(40, startH + dy) + 'px';
            break;
          case 'se':
            box.style.width = Math.max(80, startW + dx) + 'px';
            box.style.height = Math.max(40, startH + dy) + 'px';
            break;
        }
        drawConnections();
      });

      box.addEventListener('pointerup', e => {
        if (resizing && e.pointerId === resizePointerId) {
          resizing = false;
          box.releasePointerCapture(resizePointerId);
          saveMap();
        }
      });

      box.addEventListener('pointercancel', e => {
        if (resizing && e.pointerId === resizePointerId) {
          resizing = false;
          box.releasePointerCapture(resizePointerId);
        }
      });
    });

    // Content editable change save throttled
    let typingTimer = null;
    content.addEventListener('input', e => {
      if (typingTimer) clearTimeout(typingTimer);
      typingTimer = setTimeout(() => {
        saveMap();
      }, 600);
    });
  }

  // Clear all connection toggle buttons active states
  function clearConnectionToggles() {
    canvas.querySelectorAll('.connect-toggle.active').forEach(btn => {
      btn.classList.remove('active');
    });
  }

  // Create a connection between two box IDs
  function createConnection(fromId, toId) {
    if (fromId === toId) return; // No self connections
    // Prevent duplicate connections
    if (connections.some(c => c.from === fromId && c.to === toId)) return;
    connections.push({ from: fromId, to: toId });
    // Update box connection sets
    boxesMap.get(fromId).connectionsOut.add(toId);
    boxesMap.get(toId).connectionsIn.add(fromId);
  }

  // Delete a box and all its connections
  function deleteBox(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    // Save undo info
    undoStack.push({
      action: 'delete',
      box: {
        id,
        left: parseFloat(boxData.element.style.left),
        top: parseFloat(boxData.element.style.top),
        width: boxData.element.offsetWidth,
        height: boxData.element.offsetHeight,
        text: boxData.element.querySelector('.box-content').textContent,
        fontSize: parseInt(boxData.element.dataset.fontSize),
      },
      connections: connections.filter(c => c.from === id || c.to === id)
    });
    undoBtn.disabled = false;

    // Remove box from DOM and map
    canvas.removeChild(boxData.element);
    boxesMap.delete(id);

    // Remove connections involving this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    // Remove connection refs from other boxes
    boxesMap.forEach(({connectionsOut, connectionsIn}) => {
      connectionsOut.delete(id);
      connectionsIn.delete(id);
    });

    // Remove from selection if selected
    selectedBoxes.delete(boxData.element);

    drawConnections();
    saveMap();
  }

  // Undo delete action
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastAction = undoStack.pop();
    if (lastAction.action === 'delete') {
      const b = lastAction.box;
      const id = createBox(b.left, b.top, b.text, b.fontSize, b.id);
      const boxData = boxesMap.get(id);
      boxData.element.style.width = b.width + 'px';
      boxData.element.style.height = b.height + 'px';
      // Restore connections
      lastAction.connections.forEach(c => {
        createConnection(c.from, c.to);
      });
      drawConnections();
      saveMap();
    }
    undoBtn.disabled = undoStack.length === 0;
  });

  // Draw connections as SVG lines between boxes
  function drawConnections() {
    // Clear SVG
    while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);

    // Update SVG size to cover canvas fully
    const rect = canvas.getBoundingClientRect();
    connectionLayer.style.width = rect.width * scale + 'px';
    connectionLayer.style.height = rect.height * scale + 'px';
    connectionLayer.setAttribute('width', rect.width * scale);
    connectionLayer.setAttribute('height', rect.height * scale);
    connectionLayer.style.left = panX + 'px';
    connectionLayer.style.top = panY + 'px';

    connections.forEach(({from, to}) => {
      const fromBox = boxesMap.get(from);
      const toBox = boxesMap.get(to);
      if (!fromBox || !toBox) return;

      const fromEl = fromBox.element;
      const toEl = toBox.element;

      // Calculate center points of boxes relative to canvas
      const fromRect = {
        x: parseFloat(fromEl.style.left),
        y: parseFloat(fromEl.style.top),
        w: fromEl.offsetWidth,
        h: fromEl.offsetHeight
      };
      const toRect = {
        x: parseFloat(toEl.style.left),
        y: parseFloat(toEl.style.top),
        w: toEl.offsetWidth,
        h: toEl.offsetHeight
      };

      const startX = fromRect.x + fromRect.w / 2;
      const startY = fromRect.y + fromRect.h / 2;
      const endX = toRect.x + toRect.w / 2;
      const endY = toRect.y + toRect.h / 2;

      // Create SVG path with a curved cubic bezier
      const dx = endX - startX;
      const dy = endY - startY;
      const curveOffset = Math.min(100, Math.abs(dx) / 2);
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke", "black");
      path.setAttribute("stroke-width", "2");
      path.setAttribute("stroke-linecap", "round");

      const d = `M${startX},${startY} C${startX + curveOffset},${startY} ${endX - curveOffset},${endY} ${endX},${endY}`;
      path.setAttribute("d", d);

      connectionLayer.appendChild(path);
    });
  }

  // Save map data to Firebase
  async function saveMap() {
    if (!currentMapId) return;
    const boxesData = [];
    boxesMap.forEach(({element}) => {
      boxesData.push({
        id: element.dataset.id,
        left: parseFloat(element.style.left),
        top: parseFloat(element.style.top),
        width: element.offsetWidth,
        height: element.offsetHeight,
        text: element.querySelector('.box-content').textContent,
        fontSize: parseInt(element.dataset.fontSize),
      });
    });
    const data = {
      boxes: boxesData,
      connections,
      panX,
      panY,
      scale,
      timestamp: Date.now(),
    };
    try {
      await setDoc(doc(db, "maps", currentMapId), data);
      saveStatus.textContent = "Saved ✓";
      setTimeout(() => { saveStatus.textContent = ""; }, 2000);
    } catch (err) {
      saveStatus.textContent = "Save error!";
      console.error(err);
    }
  }

  // Load map data from Firebase
  async function loadMap(mapId) {
    clearAll();
    try {
      const docSnap = await getDoc(doc(db, "maps", mapId));
      if (docSnap.exists()) {
        const data = docSnap.data();
        panX = data.panX ?? 0;
        panY = data.panY ?? 0;
        scale = data.scale ?? 1;
        updateTransform();
        // Load boxes
        if (data.boxes) {
          for (const b of data.boxes) {
            createBox(b.left, b.top, b.text, b.fontSize, b.id);
          }
        }
        // Load connections
        if (data.connections) {
          connections.length = 0;
          data.connections.forEach(c => connections.push(c));
          // Update connectionsIn/out on boxesMap
          connections.forEach(({from, to}) => {
            boxesMap.get(from)?.connectionsOut.add(to);
            boxesMap.get(to)?.connectionsIn.add(from);
          });
        }
        drawConnections();
      }
    } catch (err) {
      console.error(err);
    }
  }

  // Clear everything from canvas and reset
  function clearAll() {
    connections.length = 0;
    boxesMap.forEach(({element}) => {
      canvas.removeChild(element);
    });
    boxesMap.clear();
    selectedBoxes.clear();
    undoStack.length = 0;
    undoBtn.disabled = true;
    drawConnections();
  }

  // Populate map select dropdown from Firestore
  async function refreshMapList() {
    try {
      const querySnapshot = await getDocs(collection(db, "maps"));
      mapsCache.clear();
      mapSelect.innerHTML = '';
      for (const docItem of querySnapshot.docs) {
        const id = docItem.id;
        mapsCache.set(id, docItem.data());
        const option = document.createElement('option');
        option.value = id;
        option.textContent = id;
        mapSelect.appendChild(option);
      }
      if (mapsCache.size > 0) {
        if (!currentMapId || !mapsCache.has(currentMapId)) {
          currentMapId = Array.from(mapsCache.keys())[0];
        }
        mapSelect.value = currentMapId;
        await loadMap(currentMapId);
      } else {
        // No maps exist, create new map
        currentMapId = generateId();
        mapSelect.innerHTML = '';
        const option = document.createElement('option');
        option.value = currentMapId;
        option.textContent = currentMapId;
        mapSelect.appendChild(option);
        mapSelect.value = currentMapId;
        clearAll();
      }
    } catch (err) {
      console.error(err);
    }
  }

  // Event listeners for map controls
  mapSelect.addEventListener('change', async () => {
    currentMapId = mapSelect.value;
    await loadMap(currentMapId);
  });

  saveMapBtn.addEventListener('click', () => saveMap());

  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    const newName = prompt("Enter new map name (id):", currentMapId);
    if (!newName || newName === currentMapId) return;
    try {
      const docRef = doc(db, "maps", currentMapId);
      const newDocRef = doc(db, "maps", newName);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists()) return alert("Current map does not exist.");
      await setDoc(newDocRef, docSnap.data());
      await deleteDoc(docRef);
      currentMapId = newName;
      await refreshMapList();
    } catch (err) {
      console.error(err);
    }
  });

  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    if (!confirm(`Delete map "${currentMapId}"?`)) return;
    try {
      await deleteDoc(doc(db, "maps", currentMapId));
      currentMapId = null;
      await refreshMapList();
    } catch (err) {
      console.error(err);
    }
  });

  newMapBtn.addEventListener('click', async () => {
    const newMapName = prompt("Enter new map name (id):");
    if (!newMapName) return;
    currentMapId = newMapName;
    clearAll();
    await refreshMapList();
  });

  // Center / mark center buttons
  let markedCenter = {x: 0, y: 0};
  goCenterBtn.addEventListener('click', () => {
    panX = -markedCenter.x * scale + viewport.clientWidth / 2;
    panY = -markedCenter.y * scale + viewport.clientHeight / 2;
    updateTransform();
  });
  markCenterBtn.addEventListener('click', () => {
    // Center in canvas coords
    markedCenter.x = (-panX + viewport.clientWidth / 2) / scale;
    markedCenter.y = (-panY + viewport.clientHeight / 2) / scale;
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    canvas.querySelectorAll('.box').forEach(box => {
      box.querySelector('.box-header').classList.toggle('view-mode', !editMode);
      box.querySelector('.box-content').contentEditable = editMode;
    });
    clearConnectionToggles();
    connectionStartBoxId = null;
  });

  // How to use modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Initial load
  await refreshMapList();
  updateTransform();

</script>
</body>
</html>
