<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map();

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.dataset.id = id;

    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    const connectBtn = document.createElement('button');
    connectBtn.className = 'connect-toggle';
    connectBtn.title = 'Connect boxes';
    header.appendChild(connectBtn);

    const minusBtn = document.createElement('button');
    minusBtn.className = 'font-size-btn';
    minusBtn.textContent = '−';
    minusBtn.title = 'Decrease font size';
    header.appendChild(minusBtn);

    const plusBtn = document.createElement('button');
    plusBtn.className = 'font-size-btn';
    plusBtn.textContent = '+';
    plusBtn.title = 'Increase font size';
    header.appendChild(plusBtn);

    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.textContent = '×';
    delBtn.title = 'Delete box';
    header.appendChild(delBtn);

    box.appendChild(header);

    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    canvas.appendChild(box);

    boxesMap.set(id, { box, dragHandle, header, connectBtn, delBtn, content, fontSize });

    // Event listeners
    delBtn.addEventListener('click', () => {
      deleteBox(id);
    });

    connectBtn.addEventListener('click', () => {
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectBtn.classList.remove('active');
      } else if (connectionStartBoxId === null) {
        connectionStartBoxId = id;
        connectBtn.classList.add('active');
      } else {
        if (connectionStartBoxId !== id) {
          addConnection(connectionStartBoxId, id);
        }
        const startBox = boxesMap.get(connectionStartBoxId);
        if (startBox) startBox.connectBtn.classList.remove('active');
        connectionStartBoxId = null;
      }
      drawConnections();
      saveCurrentMap();
    });

    plusBtn.addEventListener('click', () => {
      changeFontSize(id, 1);
    });

    minusBtn.addEventListener('click', () => {
      changeFontSize(id, -1);
    });

    content.addEventListener('input', () => {
      saveCurrentMapDebounced();
    });

    // Dragging box
    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.preventDefault();
      if (!selectedBoxes.has(box)) {
        clearSelectedBoxes();
        selectBox(box, true);
      }
      startDragBoxes(e);
    });

    // Multi-select with shift+click header (including drag handle)
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (e.shiftKey) {
        e.preventDefault();
        if (selectedBoxes.has(box)) {
          deselectBox(box);
        } else {
          selectBox(box, true);
        }
      } else {
        clearSelectedBoxes();
        selectBox(box, true);
      }
    });

    // Resize handling
    let resizeData = null;
    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.preventDefault();
        resizeData = {
          id,
          startX: e.clientX,
          startY: e.clientY,
          startW: box.offsetWidth,
          startH: box.offsetHeight,
          handlePos: handle.classList[1]
        };
        window.addEventListener('pointermove', doResize);
        window.addEventListener('pointerup', stopResize);
      });
    });

    function doResize(e) {
      if (!resizeData) return;
      const dx = e.clientX - resizeData.startX;
      const dy = e.clientY - resizeData.startY;
      let newW = resizeData.startW;
      let newH = resizeData.startH;
      const b = boxesMap.get(resizeData.id).box;
      const rect = b.getBoundingClientRect();

      switch (resizeData.handlePos) {
        case 'nw':
          newW = resizeData.startW - dx;
          newH = resizeData.startH - dy;
          if (newW >= 60) {
            b.style.width = newW + 'px';
            b.style.left = (parseFloat(b.style.left) + dx) + 'px';
          }
          if (newH >= 40) {
            b.style.height = newH + 'px';
            b.style.top = (parseFloat(b.style.top) + dy) + 'px';
          }
          break;
        case 'ne':
          newW = resizeData.startW + dx;
          newH = resizeData.startH - dy;
          if (newW >= 60) b.style.width = newW + 'px';
          if (newH >= 40) {
            b.style.height = newH + 'px';
            b.style.top = (parseFloat(b.style.top) + dy) + 'px';
          }
          break;
        case 'sw':
          newW = resizeData.startW - dx;
          newH = resizeData.startH + dy;
          if (newW >= 60) {
            b.style.width = newW + 'px';
            b.style.left = (parseFloat(b.style.left) + dx) + 'px';
          }
          if (newH >= 40) b.style.height = newH + 'px';
          break;
        case 'se':
          newW = resizeData.startW + dx;
          newH = resizeData.startH + dy;
          if (newW >= 60) b.style.width = newW + 'px';
          if (newH >= 40) b.style.height = newH + 'px';
          break;
      }
      drawConnections();
    }
    function stopResize(e) {
      if (!resizeData) return;
      window.removeEventListener('pointermove', doResize);
      window.removeEventListener('pointerup', stopResize);
      resizeData = null;
      saveCurrentMap();
    }

    return box;
  }

  function selectBox(box, focus = false) {
    selectedBoxes.add(box);
    box.classList.add('selected');
    if (focus) box.querySelector('.box-content').focus();
  }
  function deselectBox(box) {
    selectedBoxes.delete(box);
    box.classList.remove('selected');
  }
  function clearSelectedBoxes() {
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  }

  let dragData = null;

  function startDragBoxes(e) {
    dragData = {
      startX: e.clientX,
      startY: e.clientY,
      boxPositions: new Map()
    };
    selectedBoxes.forEach(b => {
      dragData.boxPositions.set(b.dataset.id, {
        x: parseFloat(b.style.left),
        y: parseFloat(b.style.top)
      });
    });
    window.addEventListener('pointermove', dragBoxes);
    window.addEventListener('pointerup', stopDragBoxes);
  }

  function dragBoxes(e) {
    if (!dragData) return;
    const dx = e.clientX - dragData.startX;
    const dy = e.clientY - dragData.startY;
    dragData.boxPositions.forEach((pos, id) => {
      const b = boxesMap.get(id).box;
      b.style.left = (pos.x + dx) + 'px';
      b.style.top = (pos.y + dy) + 'px';
    });
    drawConnections();
  }
  function stopDragBoxes(e) {
    window.removeEventListener('pointermove', dragBoxes);
    window.removeEventListener('pointerup', stopDragBoxes);
    dragData = null;
    saveCurrentMap();
  }

  function changeFontSize(id, delta) {
    const info = boxesMap.get(id);
    if (!info) return;
    let newSize = info.fontSize + delta;
    if (newSize < 8) newSize = 8;
    if (newSize > 48) newSize = 48;
    info.fontSize = newSize;
    info.content.style.fontSize = newSize + 'px';
    saveCurrentMap();
  }

  function deleteBox(id) {
    const info = boxesMap.get(id);
    if (!info) return;
    undoStack.push({
      boxes: [{
        id,
        x: parseFloat(info.box.style.left),
        y: parseFloat(info.box.style.top),
        w: info.box.offsetWidth,
        h: info.box.offsetHeight,
        text: info.content.textContent,
        fontSize: info.fontSize
      }],
      connections: connections.filter(c => c.from === id || c.to === id)
    });
    undoBtn.disabled = false;

    // Remove connections involving this box
    for (let i = connections.length -1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    canvas.removeChild(info.box);
    boxesMap.delete(id);
    selectedBoxes.delete(info.box);
    drawConnections();
    saveCurrentMap();
  }

  function addConnection(fromId, toId) {
    if (!connections.some(c => c.from === fromId && c.to === toId)) {
      connections.push({ from: fromId, to: toId });
    }
  }

  function serializeBox(id) {
    const info = boxesMap.get(id);
    if (!info) return null;
    return {
      id,
      x: parseFloat(info.box.style.left),
      y: parseFloat(info.box.style.top),
      w: info.box.offsetWidth,
      h: info.box.offsetHeight,
      text: info.content.textContent,
      fontSize: info.fontSize
    };
  }

  function drawConnections() {
    const svg = connectionLayer;
    svg.innerHTML = '';
    connections.forEach(c => {
      const fromBox = boxesMap.get(c.from);
      const toBox = boxesMap.get(c.to);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.box.getBoundingClientRect();
      const toRect = toBox.box.getBoundingClientRect();

      // Convert screen coords to canvas coords
      const rect = viewport.getBoundingClientRect();
      const fromX = (fromRect.left + fromRect.width / 2 - rect.left - panX) / scale;
      const fromY = (fromRect.top + fromRect.height / 2 - rect.top - panY) / scale;
      const toX = (toRect.left + toRect.width / 2 - rect.left - panX) / scale;
      const toY = (toRect.top + toRect.height / 2 - rect.top - panY) / scale;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

      const cp1x = fromX;
      const cp1y = (fromY + toY) / 2;
      const cp2x = toX;
      const cp2y = (fromY + toY) / 2;

      const d = `M${fromX},${fromY} C${cp1x},${cp1y} ${cp2x},${cp2y} ${toX},${toY}`;

      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '1.5');
      path.setAttribute('fill', 'none');
      svg.appendChild(path);
    });
  }

  function saveCurrentMap() {
    if (!currentMapId) return;
    const boxesData = [];
    boxesMap.forEach((info, id) => {
      boxesData.push(serializeBox(id));
    });
    const mapData = mapsCache.get(currentMapId);
    if (!mapData) {
      alert('Map data missing in cache. Save aborted.');
      return;
    }
    setDoc(doc(db, 'mindmaps', currentMapId), {
      name: mapData.name || 'Untitled Map',
      boxes: boxesData,
      connections,
      center: { panX, panY, scale },
      updatedAt: new Date().toISOString()
    }).then(() => {
      saveStatus.textContent = 'Saved';
      setTimeout(() => {
        if (saveStatus.textContent === 'Saved') saveStatus.textContent = '';
      }, 3000);
      mapsCache.set(currentMapId, {
        name: mapData.name || 'Untitled Map',
        boxes: boxesData,
        connections: [...connections],
        center: { panX, panY, scale }
      });
    }).catch(() => {
      saveStatus.textContent = 'Error saving';
    });
  }
  const saveCurrentMapDebounced = debounce(saveCurrentMap, 400);

  function debounce(func, wait) {
    let timeout;
    return function (...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  async function loadMapsList() {
    mapSelect.innerHTML = '';
    mapsCache.clear();
    try {
      const querySnapshot = await getDocs(collection(db, 'mindmaps'));
      const options = [];
      querySnapshot.forEach(docSnap => {
        const data = docSnap.data();
        const id = docSnap.id;
        mapsCache.set(id, data);
        options.push({ id, name: data.name || 'Untitled Map' });
      });
      options.sort((a,b) => a.name.localeCompare(b.name));
      options.forEach(opt => {
        const optionElem = document.createElement('option');
        optionElem.value = opt.id;
        optionElem.textContent = opt.name;
        mapSelect.appendChild(optionElem);
      });
      if (options.length > 0) {
        currentMapId = options[0].id;
        mapSelect.value = currentMapId;
        await loadMap(currentMapId);
      }
    } catch (e) {
      alert('Error loading maps list');
    }
  }

  async function loadMap(id) {
    clearCanvas();
    selectedBoxes.clear();
    undoStack.length = 0;
    undoBtn.disabled = true;
    const docSnap = await getDoc(doc(db, 'mindmaps', id));
    if (!docSnap.exists()) {
      alert('Map does not exist');
      return;
    }
    const data = docSnap.data();
    currentMapId = id;
    mapsCache.set(id, data);
    if (data.center) {
      panX = data.center.panX || 0;
      panY = data.center.panY || 0;
      scale = data.center.scale || 1;
    } else {
      panX = 0; panY = 0; scale = 1;
    }
    updateTransform();
    connections.length = 0;
    if (data.connections) {
      data.connections.forEach(c => connections.push(c));
    }
    if (data.boxes) {
      data.boxes.forEach(boxData => {
        createBox(boxData.id, boxData.x, boxData.y, boxData.w, boxData.h, boxData.text, boxData.fontSize || 14);
      });
    }
    drawConnections();
  }

  function clearCanvas() {
    connections.length = 0;
    boxesMap.forEach(info => {
      canvas.removeChild(info.box);
    });
    boxesMap.clear();
    connectionStartBoxId = null;
    drawConnections();
  }

  function createNewMap() {
    const newId = generateId();
    const newName = prompt('Enter new map name:', 'New Map');
    if (!newName) return;
    setDoc(doc(db, 'mindmaps', newId), {
      name: newName,
      boxes: [],
      connections: [],
      center: { panX: 0, panY: 0, scale: 1 },
      updatedAt: new Date().toISOString()
    }).then(() => {
      mapsCache.set(newId, {
        name: newName,
        boxes: [],
        connections: [],
        center: { panX: 0, panY: 0, scale: 1 }
      });
      const option = document.createElement('option');
      option.value = newId;
      option.textContent = newName;
      mapSelect.appendChild(option);
      mapSelect.value = newId;
      currentMapId = newId;
      clearCanvas();
      panX = 0; panY = 0; scale = 1;
      updateTransform();
      saveStatus.textContent = 'New map created';
      setTimeout(() => { saveStatus.textContent = ''; }, 3000);
    }).catch(() => {
      alert('Error creating new map');
    });
  }

  function renameCurrentMap() {
    if (!currentMapId) return;
    const currentName = mapsCache.get(currentMapId)?.name || 'Untitled Map';
    const newName = prompt('Enter new name:', currentName);
    if (!newName || newName === currentName) return;
    setDoc(doc(db, 'mindmaps', currentMapId), {
      ...mapsCache.get(currentMapId),
      name: newName,
      updatedAt: new Date().toISOString()
    }).then(() => {
      mapsCache.get(currentMapId).name = newName;
      // Update dropdown
      const options = [...mapSelect.options];
      options.forEach(o => {
        if (o.value === currentMapId) o.textContent = newName;
      });
      saveStatus.textContent = 'Renamed';
      setTimeout(() => { saveStatus.textContent = ''; }, 3000);
    }).catch(() => {
      alert('Error renaming map');
    });
  }

  function deleteCurrentMap() {
    if (!currentMapId) return;
    if (!confirm('Delete this map? This cannot be undone.')) return;
    deleteDoc(doc(db, 'mindmaps', currentMapId)).then(() => {
      mapsCache.delete(currentMapId);
      // Remove option from select
      const options = [...mapSelect.options];
      const idx = options.findIndex(o => o.value === currentMapId);
      if (idx !== -1) mapSelect.remove(idx);
      if (mapSelect.options.length > 0) {
        currentMapId = mapSelect.options[0].value;
        mapSelect.value = currentMapId;
        loadMap(currentMapId);
      } else {
        currentMapId = null;
        clearCanvas();
      }
      saveStatus.textContent = 'Deleted';
      setTimeout(() => { saveStatus.textContent = ''; }, 3000);
    }).catch(() => {
      alert('Error deleting map');
    });
  }

  mapSelect.addEventListener('change', () => {
    const val = mapSelect.value;
    if (val === currentMapId) return;
    loadMap(val);
  });
  saveMapBtn.addEventListener('click', saveCurrentMap);
  renameMapBtn.addEventListener('click', renameCurrentMap);
  deleteMapBtn.addEventListener('click', deleteCurrentMap);
  newMapBtn.addEventListener('click', createNewMap);

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    last.boxes.forEach(b => {
      if (boxesMap.has(b.id)) {
        const info = boxesMap.get(b.id);
        canvas.removeChild(info.box);
        boxesMap.delete(b.id);
      }
      createBox(b.id, b.x, b.y, b.w, b.h, b.text, b.fontSize);
    });
    last.connections.forEach(c => {
      if (!connections.some(conn => conn.from === c.from && conn.to === c.to)) {
        connections.push(c);
      }
    });
    drawConnections();
    undoBtn.disabled = undoStack.length === 0;
    saveCurrentMap();
  });

  goCenterBtn.addEventListener('click', () => {
    panX = 0;
    panY = 0;
    scale = 1;
    updateTransform();
  });

  let markedCenter = null;
  markCenterBtn.addEventListener('click', () => {
    markedCenter = { panX, panY, scale };
    alert('Center marked. Use "Go to Center" to return.');
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    boxesMap.forEach(info => {
      info.content.contentEditable = editMode;
      info.connectBtn.disabled = !editMode;
      info.delBtn.disabled = !editMode;
      if (!editMode) {
        clearSelectedBoxes();
      }
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Double click to create new box
  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target.closest('.box') || e.target.closest('#topMenu')) return;
    const rect = viewport.getBoundingClientRect();
    const cx = (e.clientX - rect.left - panX) / scale;
    const cy = (e.clientY - rect.top - panY) / scale;
    const id = generateId();
    createBox(id, cx, cy);
    saveCurrentMap();
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', e => {
    if (e.key === 'Delete' && editMode) {
      selectedBoxes.forEach(box => deleteBox(box.dataset.id));
      clearSelectedBoxes();
    }
  });

  // Initial load
  loadMapsList();

</script>
</body>
</html>
