<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv22</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  // Double-click to add box

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn,
         saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      // double click detected
      const rect = viewport.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const x = (clickX - panX) / scale;
      const y = (clickY - panY) / scale;
      createBox({ x, y, w: 120, h: 50, content: '', id: generateId() }, true);
      lastTap = 0;
    } else {
      lastTap = now;
    }
  });

  // Box creation, rendering

  function createBox(data, saveAfterCreate = false) {
    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = data.x + 'px';
    box.style.top = data.y + 'px';
    box.style.width = data.w + 'px';
    box.style.height = data.h + 'px';
    box.dataset.id = data.id;

    // header
    const header = document.createElement('div');
    header.className = 'box-header';

    // drag handle
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // connect toggle button
    const connectBtn = document.createElement('button');
    connectBtn.className = 'connect-toggle';
    connectBtn.title = 'Toggle connect mode';
    header.appendChild(connectBtn);

    // delete button
    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.title = 'Delete box';
    delBtn.textContent = '×';
    header.appendChild(delBtn);

    box.appendChild(header);

    // content editable area
    const contentDiv = document.createElement('div');
    contentDiv.className = 'box-content';
    contentDiv.contentEditable = editMode;
    contentDiv.spellcheck = false;
    contentDiv.textContent = data.content || '';
    box.appendChild(contentDiv);

    // resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const rh = document.createElement('div');
      rh.className = 'resize-handle ' + corner;
      box.appendChild(rh);
    });

    canvas.appendChild(box);

    // Store box data
    boxesMap.set(data.id, { box, data });

    // Setup events

    // Dragging
    let dragging = false, dragStartX, dragStartY, origX, origY;

    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.preventDefault();
      if (e.shiftKey) {
        // Shift+click drag handle - multi-select toggle
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
        return;
      }
      dragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      origX = parseFloat(box.style.left);
      origY = parseFloat(box.style.top);
      viewport.setPointerCapture(e.pointerId);
    });

    viewport.addEventListener('pointermove', e => {
      if (!dragging) return;
      e.preventDefault();
      const dx = (e.clientX - dragStartX) / scale;
      const dy = (e.clientY - dragStartY) / scale;

      if (selectedBoxes.size > 1 && selectedBoxes.has(box)) {
        // Move all selected boxes together
        selectedBoxes.forEach(b => {
          const info = boxesMap.get(b.dataset.id);
          const newX = info.data.x + dx;
          const newY = info.data.y + dy;
          b.style.left = newX + 'px';
          b.style.top = newY + 'px';
          info.data.x = newX;
          info.data.y = newY;
        });
      } else {
        // Move single box
        const newX = origX + dx;
        const newY = origY + dy;
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';
        boxesMap.get(box.dataset.id).data.x = newX;
        boxesMap.get(box.dataset.id).data.y = newY;
      }
      drawConnections();
    });

    viewport.addEventListener('pointerup', e => {
      if (dragging) {
        dragging = false;
        viewport.releasePointerCapture(e.pointerId);
        saveCurrentMap();
      }
    });

    // Delete button
    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(box.dataset.id);
    });

    // Connect button
    connectBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === box.dataset.id) {
        // cancel connection
        connectionStartBoxId = null;
        connectBtn.classList.remove('active');
      } else if (connectionStartBoxId === null) {
        connectionStartBoxId = box.dataset.id;
        connectBtn.classList.add('active');
      } else {
        // Create connection from connectionStartBoxId to this box
        connections.push({ from: connectionStartBoxId, to: box.dataset.id });
        // Clear all connect buttons
        document.querySelectorAll('.connect-toggle').forEach(b => b.classList.remove('active'));
        connectionStartBoxId = null;
        saveCurrentMap();
        drawConnections();
      }
    });

    // Resize handling
    const resizeHandles = box.querySelectorAll('.resize-handle');
    resizeHandles.forEach(handle => {
      let resizing = false;
      let resizeStartX, resizeStartY;
      let origW, origH, origX, origY;

      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.preventDefault();
        resizing = true;
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        origW = box.offsetWidth;
        origH = box.offsetHeight;
        origX = parseFloat(box.style.left);
        origY = parseFloat(box.style.top);
        viewport.setPointerCapture(e.pointerId);
      });

      viewport.addEventListener('pointermove', e => {
        if (!resizing) return;
        e.preventDefault();
        const dx = (e.clientX - resizeStartX) / scale;
        const dy = (e.clientY - resizeStartY) / scale;
        let newW = origW;
        let newH = origH;
        let newX = origX;
        let newY = origY;

        switch (handle.classList[1]) {
          case 'nw':
            newW = origW - dx;
            newH = origH - dy;
            newX = origX + dx;
            newY = origY + dy;
            break;
          case 'ne':
            newW = origW + dx;
            newH = origH - dy;
            newY = origY + dy;
            break;
          case 'sw':
            newW = origW - dx;
            newH = origH + dy;
            newX = origX + dx;
            break;
          case 'se':
            newW = origW + dx;
            newH = origH + dy;
            break;
        }
        if (newW < 50) newW = 50;
        if (newH < 30) newH = 30;

        box.style.width = newW + 'px';
        box.style.height = newH + 'px';
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';

        const info = boxesMap.get(box.dataset.id);
        info.data.w = newW;
        info.data.h = newH;
        info.data.x = newX;
        info.data.y = newY;
        drawConnections();
      });

      viewport.addEventListener('pointerup', e => {
        if (resizing) {
          resizing = false;
          viewport.releasePointerCapture(e.pointerId);
          saveCurrentMap();
        }
      });
    });

    // Content editing save
    contentDiv.addEventListener('input', e => {
      const info = boxesMap.get(box.dataset.id);
      info.data.content = contentDiv.textContent;
      saveCurrentMapDebounced();
    });

    // Shift+click header toggles selection (excluding drag handle)
    header.addEventListener('click', e => {
      if (e.target === dragHandle) return;
      if (!editMode) return;
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else {
        // clear selection except this box
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });

    if (saveAfterCreate) {
      saveCurrentMap();
    }
  }

  // Draw all connections as SVG lines
  function drawConnections() {
    const svg = connectionLayer;
    while (svg.firstChild) svg.removeChild(svg.firstChild);
    connections.forEach(conn => {
      const fromBoxInfo = boxesMap.get(conn.from);
      const toBoxInfo = boxesMap.get(conn.to);
      if (!fromBoxInfo || !toBoxInfo) return;

      const fromBox = fromBoxInfo.box;
      const toBox = toBoxInfo.box;

      const fromRect = fromBox.getBoundingClientRect();
      const toRect = toBox.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();

      // Calculate center points relative to SVG
      const fromX = (fromBoxInfo.data.x + fromBoxInfo.data.w / 2) * scale + panX;
      const fromY = (fromBoxInfo.data.y + fromBoxInfo.data.h / 2) * scale + panY;
      const toX = (toBoxInfo.data.x + toBoxInfo.data.w / 2) * scale + panX;
      const toY = (toBoxInfo.data.y + toBoxInfo.data.h / 2) * scale + panY;

      // Create SVG path - smooth curve
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const dx = Math.abs(toX - fromX);
      const dy = Math.abs(toY - fromY);
      const delta = Math.min(100, dx / 2);

      const d = `M${fromX},${fromY} C${fromX + delta},${fromY} ${toX - delta},${toY} ${toX},${toY}`;
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');

      svg.appendChild(path);
    });
  }

  // Delete box by id
  function deleteBox(id) {
    const info = boxesMap.get(id);
    if (!info) return;
    canvas.removeChild(info.box);
    boxesMap.delete(id);
    // Remove connections with this box
    for (let i = connections.length -1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    undoStack.push({ type: 'deleteBox', data: info.data });
    undoBtn.disabled = false;
    saveCurrentMap();
    drawConnections();
  }

  // Undo delete
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    if (last.type === 'deleteBox') {
      createBox(last.data, true);
    }
    undoBtn.disabled = undoStack.length === 0;
  });

  // Go to center and mark center

  let centerMark = { x: 0, y: 0 };

  function goToCenter() {
    panX = viewport.clientWidth / 2 - centerMark.x * scale;
    panY = viewport.clientHeight / 2 - centerMark.y * scale;
    updateTransform();
  }

  goCenterBtn.addEventListener('click', () => {
    goToCenter();
  });

  markCenterBtn.addEventListener('click', () => {
    centerMark.x = (viewport.clientWidth / 2 - panX) / scale;
    centerMark.y = (viewport.clientHeight / 2 - panY) / scale;
    saveCurrentMap();
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'Edit Disabled';
    boxesMap.forEach(({ box }) => {
      box.querySelector('.box-content').contentEditable = editMode;
      box.querySelector('.drag-handle').style.pointerEvents = editMode ? 'auto' : 'none';
      box.querySelectorAll('.resize-handle').forEach(h => h.style.pointerEvents = editMode ? 'auto' : 'none');
      box.querySelector('.delete-btn').style.pointerEvents = editMode ? 'auto' : 'none';
      box.querySelector('.connect-toggle').style.pointerEvents = editMode ? 'auto' : 'none';
    });
  });

  // How to modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Map loading/saving

  async function loadMaps() {
    mapSelect.innerHTML = '';
    mapsCache.clear();
    const mapsCol = collection(db, 'mindmaps');
    const snapshot = await getDocs(mapsCol);
    snapshot.forEach(docSnap => {
      const data = docSnap.data();
      mapsCache.set(docSnap.id, data);
      const opt = document.createElement('option');
      opt.value = docSnap.id;
      opt.textContent = data.name || docSnap.id;
      mapSelect.appendChild(opt);
    });
    if (mapSelect.options.length > 0) {
      mapSelect.selectedIndex = 0;
      currentMapId = mapSelect.value;
      loadMap(currentMapId);
    } else {
      // Create default map
      await createNewMap();
    }
  }

  async function createNewMap() {
    const id = generateId();
    const defaultMap = {
      name: 'New Map',
      boxes: [],
      connections: [],
      center: { x: 0, y: 0 }
    };
    await setDoc(doc(db, 'mindmaps', id), defaultMap);
    mapsCache.set(id, defaultMap);
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = defaultMap.name;
    mapSelect.appendChild(opt);
    mapSelect.value = id;
    currentMapId = id;
    loadMap(id);
  }

  async function loadMap(id) {
    clearCanvas();
    const mapData = mapsCache.get(id);
    if (!mapData) return;
    panX = viewport.clientWidth / 2 - (mapData.center?.x || 0) * scale;
    panY = viewport.clientHeight / 2 - (mapData.center?.y || 0) * scale;
    connections.length = 0;
    mapData.connections?.forEach(c => connections.push(c));
    mapData.boxes?.forEach(b => createBox(b, false));
    updateTransform();
    drawConnections();
  }

  function clearCanvas() {
    connections.length = 0;
    boxesMap.forEach(({ box }) => {
      canvas.removeChild(box);
    });
    boxesMap.clear();
    selectedBoxes.clear();
    undoStack.length = 0;
    undoBtn.disabled = true;
  }

  async function saveCurrentMap() {
    if (!currentMapId) return;
    const boxes = [];
    boxesMap.forEach(({ data }) => {
      boxes.push({...data});
    });
    const center = centerMark;
    const data = {
      name: mapsCache.get(currentMapId)?.name || 'Untitled',
      boxes,
      connections,
      center
    };
    try {
      await setDoc(doc(db, 'mindmaps', currentMapId), data);
      mapsCache.set(currentMapId, data);
      saveStatus.textContent = 'Saved';
      setTimeout(() => {
        saveStatus.textContent = '';
      }, 2000);
    } catch (e) {
      saveStatus.textContent = 'Save failed';
    }
  }

  const saveCurrentMapDebounced = debounce(saveCurrentMap, 1000);

  // debounce utility
  function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => fn.apply(this, args), delay);
    }
  }

  // Map select change
  mapSelect.addEventListener('change', e => {
    const val = mapSelect.value;
    if (val !== currentMapId) {
      currentMapId = val;
      loadMap(val);
    }
  });

  // Save button
  saveMapBtn.addEventListener('click', () => {
    saveCurrentMap();
  });

  // Rename button
  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    const currentName = mapsCache.get(currentMapId)?.name || '';
    const newName = prompt('Enter new map name:', currentName);
    if (newName && newName.trim() !== '') {
      const mapData = mapsCache.get(currentMapId);
      mapData.name = newName.trim();
      await setDoc(doc(db, 'mindmaps', currentMapId), mapData);
      mapsCache.set(currentMapId, mapData);
      // Update select option text
      const opt = Array.from(mapSelect.options).find(o => o.value === currentMapId);
      if (opt) opt.textContent = newName.trim();
    }
  });

  // Delete button
  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    if (!confirm(`Delete map "${mapsCache.get(currentMapId)?.name}"? This cannot be undone.`)) return;
    await deleteDoc(doc(db, 'mindmaps', currentMapId));
    mapsCache.delete(currentMapId);
    // Remove option from select
    const opt = Array.from(mapSelect.options).find(o => o.value === currentMapId);
    if (opt) mapSelect.removeChild(opt);
    if (mapSelect.options.length > 0) {
      currentMapId = mapSelect.options[0].value;
      mapSelect.value = currentMapId;
      loadMap(currentMapId);
    } else {
      currentMapId = null;
      clearCanvas();
    }
  });

  // New map button
  newMapBtn.addEventListener('click', async () => {
    await createNewMap();
  });

  // Init
  loadMaps();

</script>

</body>
</html>
