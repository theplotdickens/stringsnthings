<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv5</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
  });

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomIntensity = 0.1;
    const wheel = e.deltaY < 0 ? 1 : -1;
    const mouseX = e.clientX - panX;
    const mouseY = e.clientY - panY;
    const newScale = Math.min(5, Math.max(0.1, scale + wheel * zoomIntensity * scale));
    panX -= (mouseX / scale) * (newScale - scale);
    panY -= (mouseY / scale) * (newScale - scale);
    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Box creation and editing

  function createBox(data = {}) {
    const id = data.id || generateId();
    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = (data.x || 100) + 'px';
    box.style.top = (data.y || 100) + 'px';
    box.style.width = (data.width || 120) + 'px';
    box.style.height = (data.height || 60) + 'px';
    box.dataset.id = id;
    box.dataset.fontSize = data.fontSize || 14;

    // Header
    const header = document.createElement('div');
    header.classList.add('box-header');

    // Drag handle with ✥ symbol
    const dragHandle = document.createElement('div');
    dragHandle.classList.add('drag-handle');
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectToggle = document.createElement('button');
    connectToggle.classList.add('connect-toggle');
    header.appendChild(connectToggle);

    // Font size decrease button
    const fontDecBtn = document.createElement('button');
    fontDecBtn.classList.add('font-size-btn');
    fontDecBtn.textContent = '−';
    header.appendChild(fontDecBtn);

    // Font size increase button
    const fontIncBtn = document.createElement('button');
    fontIncBtn.classList.add('font-size-btn');
    fontIncBtn.textContent = '+';
    header.appendChild(fontIncBtn);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content editable div for text content
    const content = document.createElement('div');
    content.classList.add('box-content');
    content.contentEditable = editMode ? 'true' : 'false';
    content.spellcheck = false;
    content.style.fontSize = box.dataset.fontSize + 'px';
    content.style.userSelect = editMode ? 'text' : 'none';
    content.style.cursor = editMode ? 'text' : 'default';

    content.textContent = data.text || '';
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.classList.add('resize-handle', pos);
      box.appendChild(handle);
    });

    // Add to DOM
    canvas.appendChild(box);
    boxesMap.set(id, {
      id,
      element: box,
      x: data.x || 100,
      y: data.y || 100,
      width: data.width || 120,
      height: data.height || 60,
      text: data.text || '',
      fontSize: parseInt(box.dataset.fontSize, 10),
      connectionsFrom: new Set(),
      connectionsTo: new Set()
    });

    // Event listeners
    setupBoxEvents(box);

    return id;
  }

  function setupBoxEvents(box) {
    const id = box.dataset.id;
    const state = boxesMap.get(id);
    const header = box.querySelector('.box-header');
    const dragHandle = header.querySelector('.drag-handle');
    const connectToggle = header.querySelector('.connect-toggle');
    const deleteBtn = header.querySelector('.delete-btn');
    const fontDecBtn = header.querySelector('.font-size-btn:nth-of-type(1)');
    const fontIncBtn = header.querySelector('.font-size-btn:nth-of-type(2)');
    const content = box.querySelector('.box-content');

    // Dragging the box
    let dragging = false;
    let dragOffsetX, dragOffsetY;

    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      dragging = true;
      const rect = box.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      e.preventDefault();
    });

    document.addEventListener('pointermove', e => {
      if (!dragging) return;
      const newX = (e.clientX - dragOffsetX - panX) / scale;
      const newY = (e.clientY - dragOffsetY - panY) / scale;
      box.style.left = newX + 'px';
      box.style.top = newY + 'px';
      state.x = newX;
      state.y = newY;
      drawConnections();
    });

    document.addEventListener('pointerup', e => {
      if (dragging) {
        dragging = false;
        // No automatic save here
      }
    });

    // Header multi-select on Shift+click anywhere in header
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      }
    });

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (connectionStartBoxId === null) {
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else {
        // Add connection from connectionStartBoxId to this box
        connections.push({ fromId: connectionStartBoxId, toId: id, label: "" });
        // Remove active state from old toggle
        const oldBox = boxesMap.get(connectionStartBoxId).element;
        oldBox.querySelector('.connect-toggle').classList.remove('active');
        connectionStartBoxId = null;
        drawConnections();
        // No automatic save here
      }
    });

    // Delete button
    deleteBtn.addEventListener('click', e => {
      if (!editMode) return;
      e.stopPropagation();
      deleteBox(id);
    });

    // Font size buttons
    fontDecBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      adjustFontSize(id, -1);
    });
    fontIncBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      adjustFontSize(id, 1);
    });

    // Content editable events
    content.addEventListener('input', e => {
      state.text = content.textContent;
      // No automatic save here
    });

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = box.querySelector('.resize-handle.' + pos);
      let resizing = false;
      let startX, startY, startWidth, startHeight, startLeft, startTop;

      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        resizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = box.offsetWidth;
        startHeight = box.offsetHeight;
        startLeft = parseFloat(box.style.left);
        startTop = parseFloat(box.style.top);
        e.preventDefault();
      });

      document.addEventListener('pointermove', e => {
        if (!resizing) return;
        let dx = (e.clientX - startX) / scale;
        let dy = (e.clientY - startY) / scale;
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;

        if (pos.includes('n')) {
          newHeight = startHeight - dy;
          newTop = startTop + dy;
        }
        if (pos.includes('w')) {
          newWidth = startWidth - dx;
          newLeft = startLeft + dx;
        }
        if (pos.includes('e')) {
          newWidth = startWidth + dx;
        }
        if (pos.includes('s')) {
          newHeight = startHeight + dy;
        }

        newWidth = Math.max(50, newWidth);
        newHeight = Math.max(30, newHeight);

        box.style.width = newWidth + 'px';
        box.style.height = newHeight + 'px';
        box.style.left = newLeft + 'px';
        box.style.top = newTop + 'px';

        state.width = newWidth;
        state.height = newHeight;
        state.x = newLeft;
        state.y = newTop;

        drawConnections();
      });

      document.addEventListener('pointerup', e => {
        if (resizing) {
          resizing = false;
          // No automatic save here
        }
      });
    });
  }

  function adjustFontSize(id, delta) {
    const box = boxesMap.get(id);
    if (!box) return;
    let newSize = box.fontSize + delta;
    newSize = Math.min(30, Math.max(8, newSize));
    box.fontSize = newSize;
    box.element.dataset.fontSize = newSize;
    const content = box.element.querySelector('.box-content');
    content.style.fontSize = newSize + 'px';
  }

  function deleteBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    canvas.removeChild(box.element);

    // Remove connections involving this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].fromId === id || connections[i].toId === id) {
        connections.splice(i, 1);
      }
    }

    boxesMap.delete(id);
    undoStack.push({ action: 'delete', box: box, connections: [] });
    drawConnections();
    undoBtn.disabled = false;
    // No automatic save here
  }

  function undoDelete() {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    if (last.action === 'delete') {
      // Restore box
      const box = last.box;
      canvas.appendChild(box.element);
      boxesMap.set(box.id, box);
      // Restore connections
      last.connections.forEach(c => connections.push(c));
      drawConnections();
      undoBtn.disabled = undoStack.length === 0;
    }
  }

  undoBtn.addEventListener('click', () => {
    undoDelete();
  });

  // Drawing connections as SVG paths

  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.firstChild.remove();

    connections.forEach(conn => {
      const fromBox = boxesMap.get(conn.fromId);
      const toBox = boxesMap.get(conn.toId);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.element.getBoundingClientRect();
      const toRect = toBox.element.getBoundingClientRect();

      // Convert viewport client coords to canvas coords
      const svgRect = connectionLayer.getBoundingClientRect();

      const startX = (fromRect.left + fromRect.width / 2 - svgRect.left - panX) / scale;
      const startY = (fromRect.top + fromRect.height / 2 - svgRect.top - panY) / scale;
      const endX = (toRect.left + toRect.width / 2 - svgRect.left - panX) / scale;
      const endY = (toRect.top + toRect.height / 2 - svgRect.top - panY) / scale;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '1');
      path.setAttribute('fill', 'none');

      // Simple curved path
      const dx = endX - startX;
      const dy = endY - startY;
      const curveOffset = Math.min(100, Math.max(20, Math.abs(dx) / 2));
      const control1X = startX + curveOffset;
      const control1Y = startY;
      const control2X = endX - curveOffset;
      const control2Y = endY;

      const d = `M${startX},${startY} C${control1X},${control1Y} ${control2X},${control2Y} ${endX},${endY}`;
      path.setAttribute('d', d);

      connectionLayer.appendChild(path);

      // Optionally add label in the middle of the curve (not implemented here)
    });
  }

  // Map management: load maps list, load map data, save map data

  async function loadMapsList() {
    try {
      const snapshot = await getDocs(collection(db, 'mindmaps'));
      mapSelect.innerHTML = '';
      mapsCache.clear();
      let firstId = null;
      snapshot.forEach(docSnap => {
        const data = docSnap.data();
        const id = docSnap.id;
        mapsCache.set(id, data);
        const option = document.createElement('option');
        option.value = id;
        option.textContent = data.name || 'Untitled';
        mapSelect.appendChild(option);
        if (!firstId) firstId = id;
      });
      if (firstId) {
        currentMapId = firstId;
        mapSelect.value = firstId;
        loadMapById(firstId);
      } else {
        // No maps, create one
        createNewMap();
      }
    } catch (e) {
      alert('Failed to load map list: ' + e);
    }
  }

  async function loadMapById(id) {
    const cached = mapsCache.get(id);
    if (!cached) return;
    clearCanvas();
    currentMapId = id;
    document.title = cached.name || "stringsnthings";
    // Load boxes
    if (cached.boxes && Array.isArray(cached.boxes)) {
      cached.boxes.forEach(b => {
        createBox(b);
      });
    }
    // Load connections
    connections.length = 0;
    if (cached.connections && Array.isArray(cached.connections)) {
      cached.connections.push(...cached.connections || []);
      cached.connections.length = 0;
      cached.connections.push(...cached.connections || []);
      cached.connections.push(...cached.connections || []);
      connections.push(...cached.connections);
      connections.length = cached.connections.length;
      connections.splice(0, connections.length, ...cached.connections);
      // Actually just push them safely:
      cached.connections.forEach(c => connections.push(c));
    }
    // Center and zoom
    if (cached.center) {
      panX = cached.center.panX || 0;
      panY = cached.center.panY || 0;
      scale = cached.center.scale || 1;
    } else {
      panX = 0; panY = 0; scale = 1;
    }
    updateTransform();
    drawConnections();
    saveStatus.textContent = '';
  }

  function clearCanvas() {
    boxesMap.forEach(box => {
      if (box.element.parentNode) {
        canvas.removeChild(box.element);
      }
    });
    boxesMap.clear();
    connections.length = 0;
    drawConnections();
  }

  async function createNewMap() {
    const newId = generateId();
    const newName = 'New Map';
    const mapDocRef = doc(db, 'mindmaps', newId);
    const initialData = {
      name: newName,
      boxes: [],
      connections: [],
      center: { panX: 0, panY: 0, scale: 1 }
    };
    try {
      await setDoc(mapDocRef, initialData);
      mapsCache.set(newId, initialData);
      currentMapId = newId;
      const option = document.createElement('option');
      option.value = newId;
      option.textContent = newName;
      mapSelect.appendChild(option);
      mapSelect.value = newId;
      clearCanvas();
      panX = 0; panY = 0; scale = 1;
      updateTransform();
      drawConnections();
      saveStatus.textContent = 'Created new map';
      setTimeout(() => { saveStatus.textContent = ''; }, 2000);
    } catch (e) {
      alert('Failed to create new map: ' + e);
    }
  }

  mapSelect.addEventListener('change', e => {
    const val = e.target.value;
    if (val !== currentMapId) {
      loadMapById(val);
    }
  });

  // Save only when pressing Save button

  async function saveCurrentMapToFirebase() {
    if (!currentMapId) {
      alert('No map selected to save!');
      return;
    }
    const mapDocRef = doc(db, 'mindmaps', currentMapId);
    const boxesArray = Array.from(boxesMap.values()).map(box => ({
      id: box.id,
      x: box.x,
      y: box.y,
      width: box.width,
      height: box.height,
      text: box.text,
      fontSize: box.fontSize
    }));
    const data = {
      name: mapsCache.get(currentMapId)?.name || "Untitled",
      boxes: boxesArray,
      connections: connections.map(c => ({
        fromId: c.fromId,
        toId: c.toId,
        label: c.label || ""
      })),
      center: { panX, panY, scale }
    };
    try {
      await setDoc(mapDocRef, data);
      saveStatus.textContent = 'Saved at ' + new Date().toLocaleTimeString();
      setTimeout(() => { saveStatus.textContent = ''; }, 3000);
      mapsCache.set(currentMapId, data);
    } catch (e) {
      console.error('Save failed:', e);
      saveStatus.textContent = 'Save failed!';
    }
  }

  saveMapBtn.addEventListener('click', saveCurrentMapToFirebase);

  // Rename map

  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    const newName = prompt('Enter new map name:', mapsCache.get(currentMapId)?.name || '');
    if (!newName) return;
    const mapDocRef = doc(db, 'mindmaps', currentMapId);
    try {
      const data = mapsCache.get(currentMapId) || {};
      data.name = newName;
      await setDoc(mapDocRef, data);
      mapsCache.set(currentMapId, data);
      mapSelect.querySelector(`option[value="${currentMapId}"]`).textContent = newName;
      saveStatus.textContent = 'Renamed';
      setTimeout(() => { saveStatus.textContent = ''; }, 2000);
    } catch (e) {
      alert('Rename failed: ' + e);
    }
  });

  // Delete map

  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    if (!confirm('Delete this mind map? This cannot be undone.')) return;
    try {
      await deleteDoc(doc(db, 'mindmaps', currentMapId));
      mapsCache.delete(currentMapId);
      const optionToRemove = mapSelect.querySelector(`option[value="${currentMapId}"]`);
      if (optionToRemove) optionToRemove.remove();
      if (mapSelect.options.length > 0) {
        currentMapId = mapSelect.options[0].value;
        mapSelect.value = currentMapId;
        loadMapById(currentMapId);
      } else {
        currentMapId = null;
        clearCanvas();
      }
      saveStatus.textContent = 'Deleted';
      setTimeout(() => { saveStatus.textContent = ''; }, 2000);
    } catch (e) {
      alert('Delete failed: ' + e);
    }
  });

  // New map button

  newMapBtn.addEventListener('click', createNewMap);

  // Keyboard shortcuts

  window.addEventListener('keydown', e => {
    if (e.key === 'Delete' && editMode) {
      // Delete selected boxes
      selectedBoxes.forEach(box => {
        const id = box.dataset.id;
        deleteBox(id);
      });
      selectedBoxes.clear();
      undoBtn.disabled = undoStack.length === 0;
    }
    if (e.ctrlKey && e.key.toLowerCase() === 'z') {
      e.preventDefault();
      undoDelete();
    }
  });

  // Toggle edit mode

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode (On)' : 'Toggle Edit Mode (Off)';
    boxesMap.forEach(box => {
      const content = box.element.querySelector('.box-content');
      content.contentEditable = editMode ? 'true' : 'false';
      content.style.userSelect = editMode ? 'text' : 'none';
      content.style.cursor = editMode ? 'text' : 'default';
      box.element.querySelector('.connect-toggle').disabled = !editMode;
      box.element.querySelector('.delete-btn').disabled = !editMode;
      box.element.querySelectorAll('.font-size-btn').forEach(btn => btn.disabled = !editMode);
      box.element.querySelectorAll('.resize-handle').forEach(h => h.style.pointerEvents = editMode ? 'auto' : 'none');
    });
  });

  // How To modal

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Center and Mark center

  let markedCenter = { panX: 0, panY: 0, scale: 1 };

  goCenterBtn.addEventListener('click', () => {
    panX = markedCenter.panX;
    panY = markedCenter.panY;
    scale = markedCenter.scale;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    markedCenter.panX = panX;
    markedCenter.panY = panY;
    markedCenter.scale = scale;
    saveStatus.textContent = 'Center marked';
    setTimeout(() => { saveStatus.textContent = ''; }, 1500);
  });

  // Initialization

  window.onload = () => {
    loadMapsList();
    toggleEditModeBtn.textContent = 'Toggle Edit Mode (On)';
    updateTransform();
  };

</script>
</body>
</html>
