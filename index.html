<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tryingfirebaseagain</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      z-index: 1000;
      max-width: 95vw;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
      flex-shrink: 0;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
    <button id="saveBtn" class="floatingBtn">Save</button>
    <button id="loadBtn" class="floatingBtn">Load</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      **New:** Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the Save and Load buttons to persist your data to Firebase.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const howToContent = document.getElementById('howToContent');
  const connectionLayer = document.getElementById('connectionLayer');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // deselect on background click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  markCenterBtn.addEventListener('click', async () => {
    const rect = viewport.getBoundingClientRect();
    const centerX = (rect.width / 2 - panX) / scale;
    const centerY = (rect.height / 2 - panY) / scale;
    panX = rect.width / 2 - centerX * scale;
    panY = rect.height / 2 - centerY * scale;
    updateTransform();

    try {
      await setDoc(doc(db, 'userData', 'center'), { x: centerX, y: centerY });
      alert('Center marked at: ' + Math.round(centerX) + ', ' + Math.round(centerY));
    } catch (err) {
      console.error('Error saving center:', err);
      alert('Failed to save center');
    }
  });

  goCenterBtn.addEventListener('click', async () => {
    try {
      const centerDoc = await getDoc(doc(db, 'userData', 'center'));
      if (centerDoc.exists()) {
        const c = centerDoc.data();
        const rect = viewport.getBoundingClientRect();
        panX = rect.width / 2 - c.x * scale;
        panY = rect.height / 2 - c.y * scale;
        updateTransform();
      } else {
        alert('No center saved yet');
      }
    } catch (err) {
      console.error('Error loading center:', err);
      alert('Failed to load center');
    }
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    document.querySelectorAll('.box-header').forEach(header => {
      header.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.connect-toggle').forEach(toggle => {
      toggle.style.display = editMode ? 'inline-block' : 'none';
    });
    document.querySelectorAll('.font-size-btn').forEach(btn => {
      btn.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.drag-handle').forEach(handle => {
      handle.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.box-content').forEach(content => {
      content.contentEditable = editMode;
      content.style.cursor = editMode ? 'text' : 'default';
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(({ fromId, toId }) => {
      const boxA = boxesMap.get(fromId);
      const boxB = boxesMap.get(toId);
      if (!boxA || !boxB) return;
      const ax = parseFloat(boxA.style.left) + boxA.offsetWidth / 2;
      const ay = parseFloat(boxA.style.top) + boxA.offsetHeight / 2;
      const bx = parseFloat(boxB.style.left) + boxB.offsetWidth / 2;
      const by = parseFloat(boxB.style.top) + boxB.offsetHeight / 2;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", ax);
      line.setAttribute("y1", ay);
      line.setAttribute("x2", bx);
      line.setAttribute("y2", by);
      line.setAttribute("stroke", "black");
      line.setAttribute("stroke-width", "1");
      connectionLayer.appendChild(line);
    });
  }

  function addBox(x, y, text = '', id = null, width = 150, height = 80, selectNew = true, fontSize = '16px') {
    if (!id) id = 'box-' + Math.random().toString(36).slice(2, 10);

    if (boxesMap.has(id)) {
      console.warn('Box with this ID already exists:', id);
      return;
    }

    const box = document.createElement('div');
    box.classList.add('box');
    box.dataset.id = id;
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';

    const header = document.createElement('div');
    header.classList.add('box-header');
    header.title = 'Drag header. Shift+click for multi-select';

    const dragHandle = document.createElement('div');
    dragHandle.classList.add('drag-handle');
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    const connectToggle = document.createElement('button');
    connectToggle.classList.add('connect-toggle');
    connectToggle.title = 'Click to start/finish connection';
    connectToggle.tabIndex = -1;
    header.appendChild(connectToggle);

    const minusBtn = document.createElement('button');
    minusBtn.classList.add('font-size-btn');
    minusBtn.textContent = '−';
    minusBtn.title = 'Decrease font size';
    header.appendChild(minusBtn);

    const plusBtn = document.createElement('button');
    plusBtn.classList.add('font-size-btn');
    plusBtn.textContent = '+';
    plusBtn.title = 'Increase font size';
    header.appendChild(plusBtn);

    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Delete box';
    header.appendChild(deleteBtn);

    const content = document.createElement('div');
    content.classList.add('box-content');
    content.contentEditable = editMode;
    content.textContent = text;
    content.style.fontSize = fontSize;
    content.style.justifyContent = 'center';
    content.style.alignItems = 'center';
    content.style.textAlign = 'center';

    box.appendChild(header);
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const resizeHandle = document.createElement('div');
      resizeHandle.classList.add('resize-handle', corner);
      box.appendChild(resizeHandle);
    });

    canvas.appendChild(box);
    boxesMap.set(id, box);

    // Select logic for multi-select (Shift+click on header)
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (e.target === deleteBtn) return; // delete handled separately
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
      e.stopPropagation();
    });

    // Dragging boxes by drag handle or header with shift+click
    let dragOffsetX, dragOffsetY, draggingBoxes = false;

    function onDragStart(e) {
      if (!editMode) return;
      if (e.button !== 0) return;
      if (e.target.closest('.resize-handle')) return;

      if (e.target === dragHandle || e.target.closest('.drag-handle') || e.currentTarget === header) {
        if (!selectedBoxes.has(box)) {
          selectedBoxes.forEach(b => b.classList.remove('selected'));
          selectedBoxes.clear();
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
        draggingBoxes = true;
        const coords = getClientCoords(e);
        dragOffsetX = coords.x;
        dragOffsetY = coords.y;
        e.preventDefault();
      }
    }
    function onDragMove(e) {
      if (!draggingBoxes) return;
      e.preventDefault();
      const coords = getClientCoords(e);
      const dx = (coords.x - dragOffsetX) / scale;
      const dy = (coords.y - dragOffsetY) / scale;
      dragOffsetX = coords.x;
      dragOffsetY = coords.y;

      selectedBoxes.forEach(b => {
        const newX = parseFloat(b.style.left) + dx;
        const newY = parseFloat(b.style.top) + dy;
        b.style.left = newX + 'px';
        b.style.top = newY + 'px';
      });
      drawConnections();
    }
    function onDragEnd(e) {
      if (!draggingBoxes) return;
      draggingBoxes = false;
    }

    header.addEventListener('pointerdown', onDragStart);
    window.addEventListener('pointermove', onDragMove);
    window.addEventListener('pointerup', onDragEnd);

    // Delete button
    deleteBtn.addEventListener('click', () => {
      undoStack.push({
        boxes: Array.from(boxesMap.entries()).map(([id, b]) => ({
          id,
          x: parseFloat(b.style.left),
          y: parseFloat(b.style.top),
          width: b.offsetWidth,
          height: b.offsetHeight,
          text: b.querySelector('.box-content').textContent,
          fontSize: window.getComputedStyle(b.querySelector('.box-content')).fontSize
        })),
        connections: [...connections]
      });
      undoBtn.disabled = false;

      // Remove connections related to this box
      for (let i = connections.length - 1; i >= 0; i--) {
        if (connections[i].fromId === id || connections[i].toId === id) connections.splice(i, 1);
      }
      canvas.removeChild(box);
      boxesMap.delete(id);
      drawConnections();
    });

    // Connect toggle
    connectToggle.addEventListener('click', () => {
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (connectionStartBoxId) {
        if (connectionStartBoxId !== id) {
          connections.push({ fromId: connectionStartBoxId, toId: id });
          connectionStartBoxId = null;
          document.querySelectorAll('.connect-toggle').forEach(t => t.classList.remove('active'));
          drawConnections();
        }
      } else {
        connectionStartBoxId = id;
        document.querySelectorAll('.connect-toggle').forEach(t => t.classList.remove('active'));
        connectToggle.classList.add('active');
      }
    });

    // Font size buttons
    minusBtn.addEventListener('click', () => {
      const currSize = parseInt(window.getComputedStyle(content).fontSize);
      if (currSize > 8) content.style.fontSize = (currSize - 1) + 'px';
    });
    plusBtn.addEventListener('click', () => {
      const currSize = parseInt(window.getComputedStyle(content).fontSize);
      if (currSize < 48) content.style.fontSize = (currSize + 1) + 'px';
    });

    // Resizing
    let resizing = false;
    let resizeDir = null;
    let resizeStartX, resizeStartY;
    let startWidth, startHeight;
    let startLeft, startTop;

    function onResizeStart(e) {
      if (!editMode) return;
      resizing = true;
      resizeDir = e.target.classList.contains('nw') ? 'nw' :
                  e.target.classList.contains('ne') ? 'ne' :
                  e.target.classList.contains('sw') ? 'sw' : 'se';
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      startWidth = box.offsetWidth;
      startHeight = box.offsetHeight;
      startLeft = parseFloat(box.style.left);
      startTop = parseFloat(box.style.top);
      e.preventDefault();
      e.stopPropagation();
    }
    function onResizeMove(e) {
      if (!resizing) return;
      e.preventDefault();
      const dx = (e.clientX - resizeStartX) / scale;
      const dy = (e.clientY - resizeStartY) / scale;

      let newWidth = startWidth;
      let newHeight = startHeight;
      let newLeft = startLeft;
      let newTop = startTop;

      if (resizeDir.includes('n')) {
        newHeight = startHeight - dy;
        newTop = startTop + dy;
        if (newHeight < 40) {
          newHeight = 40;
          newTop = startTop + (startHeight - 40);
        }
      }
      if (resizeDir.includes('s')) {
        newHeight = startHeight + dy;
        if (newHeight < 40) newHeight = 40;
      }
      if (resizeDir.includes('w')) {
        newWidth = startWidth - dx;
        newLeft = startLeft + dx;
        if (newWidth < 80) {
          newWidth = 80;
          newLeft = startLeft + (startWidth - 80);
        }
      }
      if (resizeDir.includes('e')) {
        newWidth = startWidth + dx;
        if (newWidth < 80) newWidth = 80;
      }

      box.style.width = newWidth + 'px';
      box.style.height = newHeight + 'px';
      box.style.left = newLeft + 'px';
      box.style.top = newTop + 'px';
      drawConnections();
    }
    function onResizeEnd(e) {
      if (!resizing) return;
      resizing = false;
    }

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', onResizeStart);
    });
    window.addEventListener('pointermove', onResizeMove);
    window.addEventListener('pointerup', onResizeEnd);

    if (selectNew) {
      selectedBoxes.forEach(b => b.classList.remove('selected'));
      selectedBoxes.clear();
      selectedBoxes.add(box);
      box.classList.add('selected');
    }

    drawConnections();

    return box;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastState = undoStack.pop();
    // Clear current
    boxesMap.forEach(box => canvas.removeChild(box));
    boxesMap.clear();
    connections.length = 0;

    lastState.boxes.forEach(b => {
      addBox(b.x, b.y, b.text, b.id, b.width, b.height, false, b.fontSize);
    });
    connections.push(...lastState.connections);
    drawConnections();
    undoBtn.disabled = undoStack.length === 0;
  });

  // SAVE function to Firebase
  saveBtn.addEventListener('click', async () => {
    try {
      const boxesData = [];
      boxesMap.forEach(box => {
        const contentDiv = box.querySelector('.box-content');
        boxesData.push({
          id: box.dataset.id,
          x: parseFloat(box.style.left),
          y: parseFloat(box.style.top),
          width: box.offsetWidth,
          height: box.offsetHeight,
          text: contentDiv.textContent,
          fontSize: window.getComputedStyle(contentDiv).fontSize
        });
      });

      await setDoc(doc(db, 'userData', 'boxesData'), { boxes: boxesData });
      await setDoc(doc(db, 'userData', 'connectionsData'), { connections: connections });
      alert('Saved successfully!');
      console.log('Save successful');
    } catch (error) {
      console.error('Error saving data:', error);
      alert('Error saving data. See console.');
    }
  });

  // LOAD function from Firebase
  loadBtn.addEventListener('click', async () => {
    try {
      const boxesDoc = await getDoc(doc(db, 'userData', 'boxesData'));
      if (boxesDoc.exists()) {
        // Clear existing
        boxesMap.forEach(box => canvas.removeChild(box));
        boxesMap.clear();
        connections.length = 0;

        const boxesData = boxesDoc.data().boxes || [];
        boxesData.forEach(b => {
          addBox(b.x, b.y, b.text, b.id, b.width, b.height, false, b.fontSize);
        });
      } else {
        alert('No saved boxes data found');
        return;
      }

      const connectionsDoc = await getDoc(doc(db, 'userData', 'connectionsData'));
      if (connectionsDoc.exists()) {
        connections.length = 0;
        connections.push(...(connectionsDoc.data().connections || []));
        drawConnections();
      } else {
        alert('No saved connections data found');
      }

      // Load center and update view
      const centerDoc = await getDoc(doc(db, 'userData', 'center'));
      if (centerDoc.exists()) {
        const c = centerDoc.data();
        const rect = viewport.getBoundingClientRect();
        panX = rect.width / 2 - c.x * scale;
        panY = rect.height / 2 - c.y * scale;
        updateTransform();
      }

      alert('Load successful!');
      console.log('Load successful');
    } catch (error) {
      console.error('Error loading data:', error);
      alert('Error loading data. See console.');
    }
  });

  // Initial UI setup
  toggleEditModeBtn.click(); // set edit mode true by default (shows controls)

  // Load data on start (optional)
  // Uncomment below if you want to auto load on page load:
  // loadBtn.click();

</script>
</body>
</html>
