<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthingsv8</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
  }
  #canvas {
    position: absolute; top: 0; left: 0; transform-origin: 0 0;
    z-index: 10;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    min-width: 80px;
    min-height: 40px;
    user-select: none;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    cursor: text;
    overflow: hidden;
    transition: width 0.1s ease, height 0.1s ease;
  }
  .box.selected {
    outline: 2px dashed blue;
  }
  .box-header {
    background: #ddd;
    padding-left: 24px;
    min-width: 40px;
    min-height: 18px;
    height: 18px;
    box-sizing: border-box;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 4px;
    position: relative;
    user-select: none;
    cursor: default;
    border-bottom: 1px solid #bbb;
    font-size: 12px;
    flex-shrink: 0;
  }
  /* Hide header immediately in view mode */
  .box.viewmode-header-hidden > .box-header {
    display: none !important;
  }
  .drag-handle {
    position: absolute;
    left: 4px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 14px;
    cursor: move;
    user-select: none;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #333;
    white-space: nowrap;
    z-index: 5;
  }
  .delete-btn {
    color: red;
    font-weight: bold;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    user-select: none;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .connect-toggle {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: none;
    background-color: blue;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.25s ease;
    padding: 0;
    margin: 0;
    flex-shrink: 0;
  }
  .connect-toggle.active {
    background-color: green;
  }
  .font-size-btn {
    font-size: 14px;
    width: 18px;
    height: 18px;
    line-height: 1;
    cursor: pointer;
    user-select: none;
    background: transparent;
    border: none;
    color: black;
    padding: 0;
    margin: 0 2px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .box-content {
    flex: 1;
    padding: 2px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    overflow-wrap: break-word;
    outline: none;
    cursor: text;
    user-select: text;
    line-height: 1.1;
    min-height: 24px;
    box-sizing: border-box;
    resize: none;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    word-break: break-word;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

  #topMenu {
    position: fixed;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(240, 240, 240, 0.95);
    border: 1px solid #bbb;
    border-radius: 6px;
    padding: 6px 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: monospace;
    z-index: 10000;
    box-shadow: 0 0 8px rgba(0,0,0,0.1);
    user-select: none;
  }
  #mapSelect {
    font-family: monospace;
    font-size: 14px;
    padding: 2px 4px;
    border-radius: 4px;
    border: 1px solid #888;
    cursor: pointer;
    min-width: 150px;
  }
  #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
    background: #555;
    color: #eee;
    border: none;
    border-radius: 4px;
    padding: 4px 10px;
    cursor: pointer;
    font-family: monospace;
    font-size: 14px;
    user-select: none;
    transition: background-color 0.2s ease;
  }
  #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
    background: #333;
  }
  #saveStatus {
    font-size: 13px;
    color: green;
    min-width: 90px;
    user-select: none;
  }

  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
    user-select: none;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }
  #zoomDisplay {
    position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.5); color: white; font-family: monospace;
    padding: 4px 8px; border-radius: 4px;
    user-select: none; pointer-events: none; z-index: 1001;
  }
  #connectionLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 1;
  }
  #footerInfo {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    font-family: monospace, monospace;
    font-size: 14px;
    color: #555;
    user-select: none;
    z-index: 1002;
    background: rgba(255,255,255,0.9);
    padding: 4px 8px;
    border-radius: 4px;
    box-shadow: 0 0 5px rgba(0,0,0,0.1);
    pointer-events: none;
    width: max-content;
    max-width: 90vw;
    text-align: center;
  }
  #howToModal {
    display:none;
    position:fixed; top:50%; left:50%;
    transform: translate(-50%, -50%);
    background:white;
    border: 2px solid black;
    padding: 20px;
    z-index: 2000;
    width: 80vw;
    max-width: 600px;
    max-height: 70vh;
    overflow-y: auto;
    font-family: monospace;
  }
  #howToModal h2 {
    margin-top: 0;
  }
  #howToContent {
    white-space: pre-wrap;
    user-select: text;
  }
  #closeHowToBtn {
    margin-top: 12px;
    padding: 6px 12px;
    cursor: pointer;
  }
</style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer" xmlns="http://www.w3.org/2000/svg"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
Double click anywhere to create a new text box.
Toggle edit mode on and off to make or prevent changes.
Use the ✥ symbol in the top left corner to move boxes.
Use the red x to delete boxes.
Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
Use the resize handles at the corners to resize boxes.
On the bottom of the screen, use "mark center" to fix yourself a return point.
Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x = 100, y = 100, width = 150, height = 60, text = '', fontSize = 14) {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    const minusBtn = document.createElement('button');
    minusBtn.className = 'font-size-btn';
    minusBtn.textContent = '−';
    header.appendChild(minusBtn);

    const plusBtn = document.createElement('button');
    plusBtn.className = 'font-size-btn';
    plusBtn.textContent = '+';
    header.appendChild(plusBtn);

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    header.appendChild(connectToggle);

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content editable
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = 'true';
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    canvas.appendChild(box);

    // Store box info
    boxesMap.set(id, {
      id,
      box,
      header,
      dragHandle,
      minusBtn,
      plusBtn,
      connectToggle,
      deleteBtn,
      content,
      fontSize,
      x,
      y,
      width,
      height,
      resizing: false,
      dragging: false,
      connections: new Set(),
    });

    // Event listeners
    initBoxEvents(id);

    return id;
  }

  // Get box center coordinates relative to canvas (not viewport)
  function getBoxCenter(boxInfo) {
    return {
      x: boxInfo.x + boxInfo.width / 2,
      y: boxInfo.y + boxInfo.height / 2
    };
  }

  // Draw connections as smooth cubic Bezier curves with SVG

  function drawConnections() {
    // Clear SVG
    while (connectionLayer.firstChild) {
      connectionLayer.removeChild(connectionLayer.firstChild);
    }
    // Draw each connection
    connections.forEach(({ fromId, toId }) => {
      const fromBox = boxesMap.get(fromId);
      const toBox = boxesMap.get(toId);
      if (!fromBox || !toBox) return;

      // Calculate positions in canvas coordinates
      const fromX = fromBox.x + fromBox.width;
      const fromY = fromBox.y + fromBox.height / 2;
      const toX = toBox.x;
      const toY = toBox.y + toBox.height / 2;

      // Control points for smooth curve
      const dx = toX - fromX;
      const dy = toY - fromY;
      const controlX1 = fromX + dx * 0.25;
      const controlY1 = fromY;
      const controlX2 = fromX + dx * 0.75;
      const controlY2 = toY;

      // Create SVG path
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', `M${fromX} ${fromY} C${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      connectionLayer.appendChild(path);
    });
  }

  // Update box style and position after move/resize

  function updateBoxPosition(boxInfo) {
    const { box, x, y, width, height } = boxInfo;
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
  }

  // Update box content font size

  function updateFontSize(boxInfo, delta) {
    const newSize = Math.min(40, Math.max(8, boxInfo.fontSize + delta));
    boxInfo.fontSize = newSize;
    boxInfo.content.style.fontSize = newSize + 'px';
  }

  // Box events initialization

  function initBoxEvents(id) {
    const boxInfo = boxesMap.get(id);
    const { box, dragHandle, content, deleteBtn, connectToggle, minusBtn, plusBtn, header } = boxInfo;

    // Dragging box

    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.stopPropagation();
      boxInfo.dragging = true;
      const rect = box.getBoundingClientRect();
      const startPos = { x: rect.left, y: rect.top };
      const pointerStart = { x: e.clientX, y: e.clientY };

      // Multi-select drag start: if shift is held, add or remove from selected
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else if (!selectedBoxes.has(box)) {
        // Clear selection and select only this box
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }

      function onPointerMove(ev) {
        if (!boxInfo.dragging) return;
        const dx = (ev.clientX - pointerStart.x) / scale;
        const dy = (ev.clientY - pointerStart.y) / scale;

        if (selectedBoxes.size > 1) {
          selectedBoxes.forEach(b => {
            const info = boxesMap.get(b.dataset.id);
            info.x += dx;
            info.y += dy;
            updateBoxPosition(info);
          });
        } else {
          boxInfo.x = startPos.x - viewport.getBoundingClientRect().left + dx;
          boxInfo.y = startPos.y - viewport.getBoundingClientRect().top + dy;
          updateBoxPosition(boxInfo);
        }
        pointerStart.x = ev.clientX;
        pointerStart.y = ev.clientY;
        drawConnections();
      }

      function onPointerUp() {
        boxInfo.dragging = false;
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);
        saveMapDebounced();
      }

      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
    });

    // Delete box

    deleteBtn.addEventListener('click', e => {
      if (!editMode) return;
      e.stopPropagation();
      deleteBox(id);
    });

    // Connect toggle

    connectToggle.addEventListener('click', e => {
      if (!editMode) return;
      e.stopPropagation();
      if (connectionStartBoxId === null) {
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        // Create connection from start to this box
        addConnection(connectionStartBoxId, id);
        // Remove active state from previous start box connectToggle
        const startBox = boxesMap.get(connectionStartBoxId);
        if (startBox) startBox.connectToggle.classList.remove('active');
        connectionStartBoxId = null;
        drawConnections();
        saveMapDebounced();
      }
    });

    // Font size plus and minus

    plusBtn.addEventListener('click', e => {
      if (!editMode) return;
      e.stopPropagation();
      updateFontSize(boxInfo, 2);
      saveMapDebounced();
    });

    minusBtn.addEventListener('click', e => {
      if (!editMode) return;
      e.stopPropagation();
      updateFontSize(boxInfo, -2);
      saveMapDebounced();
    });

    // Content editable input saves

    content.addEventListener('input', () => {
      boxInfo.text = content.textContent;
      saveMapDebounced();
    });

    // Prevent ripple/outline on buttons - remove focus ring

    [deleteBtn, connectToggle, plusBtn, minusBtn].forEach(btn => {
      btn.addEventListener('mousedown', e => e.preventDefault());
    });

    // Resize handles

    const resizeHandles = box.querySelectorAll('.resize-handle');

    resizeHandles.forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        boxInfo.resizing = true;
        const startRect = { x: boxInfo.x, y: boxInfo.y, width: boxInfo.width, height: boxInfo.height };
        const pointerStart = { x: e.clientX, y: e.clientY };
        const pos = handle.classList[1]; // nw, ne, sw, se

        function onPointerMove(ev) {
          if (!boxInfo.resizing) return;
          const dx = (ev.clientX - pointerStart.x) / scale;
          const dy = (ev.clientY - pointerStart.y) / scale;
          let newX = startRect.x;
          let newY = startRect.y;
          let newWidth = startRect.width;
          let newHeight = startRect.height;

          switch (pos) {
            case 'nw':
              newX = startRect.x + dx;
              newY = startRect.y + dy;
              newWidth = startRect.width - dx;
              newHeight = startRect.height - dy;
              break;
            case 'ne':
              newY = startRect.y + dy;
              newWidth = startRect.width + dx;
              newHeight = startRect.height - dy;
              break;
            case 'sw':
              newX = startRect.x + dx;
              newWidth = startRect.width - dx;
              newHeight = startRect.height + dy;
              break;
            case 'se':
              newWidth = startRect.width + dx;
              newHeight = startRect.height + dy;
              break;
          }
          newWidth = Math.max(40, newWidth);
          newHeight = Math.max(24, newHeight);
          boxInfo.x = newX;
          boxInfo.y = newY;
          boxInfo.width = newWidth;
          boxInfo.height = newHeight;
          updateBoxPosition(boxInfo);
          drawConnections();
        }

        function onPointerUp() {
          boxInfo.resizing = false;
          window.removeEventListener('pointermove', onPointerMove);
          window.removeEventListener('pointerup', onPointerUp);
          saveMapDebounced();
        }

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      });
    });

    // Focus content on double click on box (not header)

    box.addEventListener('dblclick', e => {
      if (e.target === box || e.target === box.querySelector('.box-content')) {
        e.stopPropagation();
        if (!editMode) return;
        content.focus();
      }
    });

    // Select box on click on header (including drag handle)

    header.addEventListener('click', e => {
      e.stopPropagation();
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      } else if (!selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });
  }

  // Connections management

  function addConnection(fromId, toId) {
    if (fromId === toId) return;
    if (connections.find(c => c.fromId === fromId && c.toId === toId)) return; // no duplicates
    connections.push({ fromId, toId });
  }

  function deleteBox(id) {
    const boxInfo = boxesMap.get(id);
    if (!boxInfo) return;
    undoStack.push({
      boxes: [{ ...boxInfo }],
      connections: connections.filter(c => c.fromId === id || c.toId === id)
    });
    undoBtn.disabled = false;

    // Remove connections related
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].fromId === id || connections[i].toId === id) connections.splice(i, 1);
    }
    // Remove box from DOM
    boxInfo.box.remove();
    boxesMap.delete(id);
    selectedBoxes.delete(boxInfo.box);
    drawConnections();
    saveMapDebounced();
  }

  function undoDelete() {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    last.boxes.forEach(b => {
      createBox(b.id, b.x, b.y, b.width, b.height, b.text || '', b.fontSize || 14);
    });
    last.connections.forEach(c => connections.push(c));
    undoBtn.disabled = undoStack.length === 0;
    drawConnections();
    saveMapDebounced();
  }

  // Save & Load maps

  async function loadMapsList() {
    const col = collection(db, 'mindmaps');
    const docs = await getDocs(col);
    mapsCache.clear();
    mapSelect.innerHTML = '';
    docs.forEach(docSnap => {
      const data = docSnap.data();
      mapsCache.set(docSnap.id, {
        name: data.name || docSnap.id,
        boxes: data.boxes || {},
        connections: data.connections || [],
        center: data.center || { panX: 0, panY: 0, scale: 1 }
      });
      const option = document.createElement('option');
      option.value = docSnap.id;
      option.textContent = data.name || docSnap.id;
      mapSelect.appendChild(option);
    });
    if (mapSelect.options.length === 0) {
      await createNewMap('Welcome Map!');
    }
    else {
      currentMapId = mapSelect.value || mapSelect.options[0].value;
      await loadMap(currentMapId);
    }
  }

  async function loadMap(id) {
    clearAllBoxes();
    connections.length = 0;
    const mapData = mapsCache.get(id);
    if (!mapData) return;
    // Load boxes
    for (const [bid, bdata] of Object.entries(mapData.boxes)) {
      createBox(bid, bdata.x, bdata.y, bdata.width, bdata.height, bdata.text || '', bdata.fontSize || 14);
    }
    // Load connections
    mapData.connections.forEach(c => connections.push(c));
    panX = mapData.center?.panX || 0;
    panY = mapData.center?.panY || 0;
    scale = mapData.center?.scale || 1;
    updateTransform();
    drawConnections();
    currentMapId = id;
    mapSelect.value = id;
    saveStatus.textContent = '';
  }

  function clearAllBoxes() {
    boxesMap.forEach(b => b.box.remove());
    boxesMap.clear();
    selectedBoxes.clear();
    drawConnections();
  }

  async function createNewMap(name) {
    const newId = generateId();
    mapsCache.set(newId, {
      name,
      boxes: {},
      connections: [],
      center: { panX: 0, panY: 0, scale: 1 }
    });
    currentMapId = newId;
    await saveMap(); // save empty new map
    await loadMapsList();
    mapSelect.value = newId;
    await loadMap(newId);
  }

  async function saveMap() {
    if (!currentMapId) return;
    saveStatus.textContent = 'Saving...';
    const boxesObj = {};
    boxesMap.forEach(b => {
      boxesObj[b.id] = {
        x: b.x,
        y: b.y,
        width: b.width,
        height: b.height,
        text: b.content.textContent,
        fontSize: b.fontSize
      };
    });
    try {
      await setDoc(doc(db, 'mindmaps', currentMapId), {
        name: mapsCache.get(currentMapId)?.name || currentMapId,
        boxes: boxesObj,
        connections: connections,
        center: { panX, panY, scale }
      });
      mapsCache.set(currentMapId, {
        name: mapsCache.get(currentMapId)?.name || currentMapId,
        boxes: boxesObj,
        connections: [...connections],
        center: { panX, panY, scale }
      });
      saveStatus.textContent = 'Saved';
      setTimeout(() => { saveStatus.textContent = ''; }, 1500);
      await loadMapsList(); // update select options
    } catch (e) {
      saveStatus.textContent = 'Save failed';
      console.error(e);
    }
  }

  // Debounce save map on rapid changes

  let saveTimeout;
  function saveMapDebounced() {
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(saveMap, 800);
  }

  // Rename map

  async function renameMap() {
    if (!currentMapId) return;
    const newName = prompt('Enter new name for this mind map:', mapsCache.get(currentMapId)?.name || '');
    if (!newName) return;
    mapsCache.get(currentMapId).name = newName;
    await saveMap();
    await loadMapsList();
    mapSelect.value = currentMapId;
  }

  // Delete map

  async function deleteMap() {
    if (!currentMapId) return;
    if (!confirm('Delete this mind map? This cannot be undone.')) return;
    try {
      await deleteDoc(doc(db, 'mindmaps', currentMapId));
      mapsCache.delete(currentMapId);
      currentMapId = null;
      await loadMapsList();
      saveStatus.textContent = 'Deleted map';
      clearAllBoxes();
    } catch (e) {
      saveStatus.textContent = 'Delete failed';
      console.error(e);
    }
  }

  // Multi-select dragging

  // (Handled in dragHandle pointerdown and move)

  // Keyboard shortcuts

  window.addEventListener('keydown', e => {
    if (!editMode) return;
    if (e.key === 'Delete' || e.key === 'Backspace') {
      selectedBoxes.forEach(box => {
        deleteBox(box.dataset.id);
      });
      selectedBoxes.clear();
    }
    if (e.ctrlKey && e.key.toLowerCase() === 'z') {
      undoDelete();
    }
  });

  // Undo button

  undoBtn.addEventListener('click', undoDelete);

  // Go to center & mark center

  let centerMark = { panX: 0, panY: 0, scale: 1 };

  goCenterBtn.addEventListener('click', () => {
    panX = centerMark.panX;
    panY = centerMark.panY;
    scale = centerMark.scale;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    centerMark = { panX, panY, scale };
  });

  // Toggle edit mode

  function updateEditModeUI() {
    toggleEditModeBtn.textContent = editMode ? 'View Mode' : 'Edit Mode';

    boxesMap.forEach(({ box, header, dragHandle, minusBtn, plusBtn, connectToggle, deleteBtn, content }) => {
      content.contentEditable = editMode.toString();
      dragHandle.style.display = editMode ? 'flex' : 'none';
      minusBtn.style.display = editMode ? 'inline-block' : 'none';
      plusBtn.style.display = editMode ? 'inline-block' : 'none';
      connectToggle.style.display = editMode ? 'inline-block' : 'none';
      deleteBtn.style.display = editMode ? 'inline-block' : 'none';
      const boxElement = box;
      if (!editMode) {
        boxElement.classList.add('box', 'viewmode-header-hidden');
      } else {
        boxElement.classList.remove('viewmode-header-hidden');
      }
    });

    if (!editMode) {
      selectedBoxes.forEach(box => box.classList.remove('selected'));
      selectedBoxes.clear();
    }
  }

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    updateEditModeUI();
  });

  // How To Modal

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });

  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Map selection change

  mapSelect.addEventListener('change', async () => {
    const val = mapSelect.value;
    if (!val) return;
    if (editMode) {
      if (!confirm('Switching maps will discard unsaved changes. Continue?')) {
        mapSelect.value = currentMapId;
        return;
      }
    }
    currentMapId = val;
    await loadMap(val);
  });

  // New map

  newMapBtn.addEventListener('click', async () => {
    const name = prompt('Enter name for new mind map:', 'New Map');
    if (!name) return;
    await createNewMap(name);
  });

  // On double click on viewport create new box

  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target.closest('.box')) return; // ignore if dblclick inside box
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / scale;
    const y = (e.clientY - rect.top) / scale;
    const id = generateId();
    createBox(id, x, y);
    saveMapDebounced();
  });

  // Initialization

  async function init() {
    await loadMapsList();
    updateTransform();
    updateEditModeUI();
  }

  init();

</script>

</body>
</html>
