<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
      user-select: none;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: text;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 3px solid #3377ff;
      outline-offset: -3px;
    }
    .box-header {
      background: #ddd;
      padding: 1px 4px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      height: 18px;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .box-content {
      flex: 1;
      padding: 6px 8px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow: auto;
      outline: none;
      cursor: text;
      font-size: 16px;
      line-height: 1.2;
      min-height: 24px;
      word-break: break-word;
      box-sizing: border-box;
      resize: none;
      user-select: text;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: auto;
      z-index: 5;
    }
    path.connection {
      stroke: black;
      stroke-width: 2;
      fill: none;
      cursor: pointer;
      transition: stroke 0.2s ease;
    }
    path.connection.selected {
      stroke: #3377ff;
      stroke-width: 3;
    }

    /* Selection rectangle */
    #selectionRect {
      position: fixed;
      border: 1px dashed #3377ff;
      background: rgba(50, 120, 255, 0.15);
      display: none;
      pointer-events: none;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <div id="viewport" tabindex="0">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
    <div id="selectionRect"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="selectModeBtn" class="floatingBtn">Select Mode: OFF</button>
    <button id="deleteSelectedBtn" class="floatingBtn" disabled>Delete Selected</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
  </div>

  <div id="zoomDisplay">Zoom: 100%</div>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

  <script>
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
      authDomain: "stringsnthings-65aa0.firebaseapp.com",
      projectId: "stringsnthings-65aa0",
      storageBucket: "stringsnthings-65aa0.firebasestorage.app",
      messagingSenderId: "35780192306",
      appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    const canvas = document.getElementById('canvas');
    const viewport = document.getElementById('viewport');
    const undoBtn = document.getElementById('undoBtn');
    const selectModeBtn = document.getElementById('selectModeBtn');
    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    const goCenterBtn = document.getElementById('goCenterBtn');
    const markCenterBtn = document.getElementById('markCenterBtn');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const connectionLayer = document.getElementById('connectionLayer');
    const selectionRect = document.getElementById('selectionRect');

    let scale = 1, panX = 0, panY = 0;
    let isPanning = false, startX, startY;

    let undoStack = [];

    let connections = [];

    let selectedBoxes = new Set();
    let selectedConnections = new Set();

    let selectMode = false; // Toggle select mode on/off

    // Utilities
    function generateId() {
      return 'id_' + Math.random().toString(36).substr(2, 9);
    }

    // Pan and zoom with limits
    const MIN_SCALE = 0.5;
    const MAX_SCALE = 3;

    function updateTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      connectionLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      zoomDisplay.textContent = `Zoom: ${Math.round(scale*100)}%`;
      drawConnections();
    }

    // Panning handlers
    viewport.addEventListener('pointerdown', e => {
      if (selectMode) return; // Disable pan if select mode active
      if (e.target.closest('.box') || e.target.closest('button') || e.target === connectionLayer) return;
      isPanning = true;
      const coords = {x: e.clientX, y: e.clientY};
      startX = coords.x;
      startY = coords.y;
      viewport.setPointerCapture(e.pointerId);
      viewport.style.cursor = 'grabbing';
    });
    viewport.addEventListener('pointermove', e => {
      if (!isPanning) return;
      const coords = {x: e.clientX, y: e.clientY};
      panX += coords.x - startX;
      panY += coords.y - startY;
      startX = coords.x;
      startY = coords.y;
      updateTransform();
    });
    viewport.addEventListener('pointerup', e => {
      if (!isPanning) return;
      isPanning = false;
      viewport.releasePointerCapture(e.pointerId);
      viewport.style.cursor = 'grab';
    });
    viewport.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
      let newScale = scale * dir;
      newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const wx = (mouseX - panX) / scale;
      const wy = (mouseY - panY) / scale;
      scale = newScale;
      panX = mouseX - wx * scale;
      panY = mouseY - wy * scale;
      updateTransform();
    });

    // Boxes and selection management
    function createBox(x, y, text='Text box', id=null, width=180, height=80, fontSize='16px') {
      const box = document.createElement('div');
      box.className = 'box';
      box.style.left = x + 'px';
      box.style.top = y + 'px';
      box.style.width = width + 'px';
      box.style.height = height + 'px';
      box.spellcheck = false;

      const header = document.createElement('div');
      header.className = 'box-header';

      const connectToggle = document.createElement('button');
      connectToggle.className = 'connect-toggle';
      connectToggle.title = 'Connect';

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = 'Ã—';

      header.appendChild(connectToggle);
      header.appendChild(delBtn);

      const content = document.createElement('div');
      content.contentEditable = true;
      content.className = 'box-content';
      content.textContent = text;
      content.style.fontSize = fontSize;

      box.appendChild(header);
      box.appendChild(content);

      // Resize handles
      const handles = {};
      ['nw','ne','sw','se'].forEach(pos => {
        const h = document.createElement('div');
        h.className = 'resize-handle ' + pos;
        box.appendChild(h);
        handles[pos] = h;
      });

      // State vars
      let dragging = false;
      let resizing = false;
      let resizeDir = null;
      let offsetX = 0, offsetY = 0;
      let startWidth, startHeight, startXpos, startYpos, startClientX, startClientY;

      // Drag box by header (only if not select mode)
      header.addEventListener('pointerdown', e => {
        if (selectMode) return;
        if (e.target === delBtn || e.target === connectToggle) return;
        dragging = true;
        offsetX = e.clientX - box.offsetLeft;
        offsetY = e.clientY - box.offsetTop;
        startXpos = box.offsetLeft;
        startYpos = box.offsetTop;
        e.preventDefault();
        box.setPointerCapture(e.pointerId);
      });
      header.addEventListener('pointermove', e => {
        if (!dragging) return;
        e.preventDefault();
        let newX = e.clientX - offsetX;
        let newY = e.clientY - offsetY;
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';
        drawConnections();
      });
      header.addEventListener('pointerup', e => {
        if (!dragging) return;
        dragging = false;
        box.releasePointerCapture(e.pointerId);
        saveAll();
      });

      // Resize handles logic
      Object.entries(handles).forEach(([dir, handle]) => {
        handle.addEventListener('pointerdown', e => {
          if (selectMode) return;
          e.stopPropagation();
          resizing = true;
          resizeDir = dir;
          startWidth = box.offsetWidth;
          startHeight = box.offsetHeight;
          startXpos = box.offsetLeft;
          startYpos = box.offsetTop;
          startClientX = e.clientX;
          startClientY = e.clientY;
          handle.setPointerCapture(e.pointerId);
          e.preventDefault();
        });
        handle.addEventListener('pointermove', e => {
          if (!resizing || !handle.hasPointerCapture(e.pointerId)) return;
          e.preventDefault();
          const dx = e.clientX - startClientX;
          const dy = e.clientY - startClientY;
          let newLeft = startXpos;
          let newTop = startYpos;
          let newWidth = startWidth;
          let newHeight = startHeight;
          if (resizeDir.includes('e')) newWidth = Math.max(80, startWidth + dx);
          if (resizeDir.includes('s')) newHeight = Math.max(40, startHeight + dy);
          if (resizeDir.includes('w')) {
            newWidth = Math.max(80, startWidth - dx);
            newLeft = startXpos + dx;
          }
          if (resizeDir.includes('n')) {
            newHeight = Math.max(40, startHeight - dy);
            newTop = startYpos + dy;
          }
          box.style.width = newWidth + 'px';
          box.style.height = newHeight + 'px';
          box.style.left = newLeft + 'px';
          box.style.top = newTop + 'px';
          smoothAdjustFontSize(content, box);
          drawConnections();
        });
        handle.addEventListener('pointerup', e => {
          if (!resizing) return;
          resizing = false;
          resizeDir = null;
          handle.releasePointerCapture(e.pointerId);
          saveAll();
        });
      });

      // Connect toggle
      connectToggle.addEventListener('click', e => {
        e.stopPropagation();
        if (!selectMode) return; // only allow connections in select mode
        if (selectedBoxes.has(box.dataset.id)) {
          selectedBoxes.delete(box.dataset.id);
          connectToggle.classList.remove('active');
          updateSelectionVisuals();
          return;
        }
        selectedBoxes.add(box.dataset.id);
        updateSelectionVisuals();
      });

      // Delete button on box (only in select mode)
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (!selectMode) return;
        deleteBox(box.dataset.id);
      });

      // Click on box for selection (only in select mode)
      box.addEventListener('click', e => {
        if (!selectMode) return;
        e.stopPropagation();
        if (e.shiftKey) {
          if (selectedBoxes.has(box.dataset.id)) selectedBoxes.delete(box.dataset.id);
          else selectedBoxes.add(box.dataset.id);
        } else {
          selectedBoxes.clear();
          selectedConnections.clear();
          selectedBoxes.add(box.dataset.id);
        }
        updateSelectionVisuals();
      });

      // Text content input updates save & font size
      content.addEventListener('input', () => {
        smoothAdjustFontSize(content, box);
        saveAll();
      });

      // Assign id or generate
      box.dataset.id = id || generateId();

      canvas.appendChild(box);
      smoothAdjustFontSize(content, box);
      updateSelectionVisuals();

      return box;
    }

    // Adjust font size to fill box nicely
    function smoothAdjustFontSize(contentDiv, box) {
      const padding = 14;
      const maxWidth = box.clientWidth - padding;
      const maxHeight = box.clientHeight - padding;
      let minSize = 8;
      let maxSize = 72;
      let fontSize = 16;
      while (minSize <= maxSize) {
        const mid = Math.floor((minSize + maxSize) / 2);
        contentDiv.style.fontSize = mid + 'px';
        if (contentDiv.scrollWidth <= maxWidth && contentDiv.scrollHeight <= maxHeight) {
          fontSize = mid;
          minSize = mid + 1;
        } else {
          maxSize = mid - 1;
        }
      }
      contentDiv.style.fontSize = fontSize + 'px';
    }

    // Draw connections
    function drawConnections() {
      while(connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);
      connections.forEach(conn => {
        const fromBox = document.querySelector(`.box[data-id="${conn.from}"]`);
        const toBox = document.querySelector(`.box[data-id="${conn.to}"]`);
        if (!fromBox || !toBox) return;
        const fromRect = fromBox.getBoundingClientRect();
        const toRect = toBox.getBoundingClientRect();
        const vpRect = viewport.getBoundingClientRect();

        // Calculate center points relative to viewport and scaled
        const startX = (fromBox.offsetLeft + fromBox.offsetWidth / 2);
        const startY = (fromBox.offsetTop + fromBox.offsetHeight / 2);
        const endX = (toBox.offsetLeft + toBox.offsetWidth / 2);
        const endY = (toBox.offsetTop + toBox.offsetHeight / 2);

        // Control points for cubic Bezier curve
        const dx = Math.abs(endX - startX);
        const controlOffset = Math.min(100, dx / 2);

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.classList.add('connection');
        path.setAttribute('data-from', conn.from);
        path.setAttribute('data-to', conn.to);
        path.setAttribute('d', `M${startX},${startY} C${startX + controlOffset},${startY} ${endX - controlOffset},${endY} ${endX},${endY}`);

        // Selection visual
        if (selectedConnections.has(conn.from + '->' + conn.to)) {
          path.classList.add('selected');
        }

        // Click on connection (only select mode)
        path.addEventListener('click', e => {
          if (!selectMode) return;
          e.stopPropagation();
          const key = conn.from + '->' + conn.to;
          if (e.shiftKey) {
            if (selectedConnections.has(key)) selectedConnections.delete(key);
            else selectedConnections.add(key);
          } else {
            selectedBoxes.clear();
            selectedConnections.clear();
            selectedConnections.add(key);
          }
          updateSelectionVisuals();
        });

        connectionLayer.appendChild(path);
      });
    }

    // Update selection visuals on boxes and connections
    function updateSelectionVisuals() {
      // Boxes
      document.querySelectorAll('.box').forEach(box => {
        if (selectedBoxes.has(box.dataset.id)) {
          box.classList.add('selected');
          box.querySelector('.connect-toggle').classList.add('active');
        } else {
          box.classList.remove('selected');
          box.querySelector('.connect-toggle').classList.remove('active');
        }
      });
      // Connections
      document.querySelectorAll('path.connection').forEach(path => {
        const key = path.getAttribute('data-from') + '->' + path.getAttribute('data-to');
        if (selectedConnections.has(key)) path.classList.add('selected');
        else path.classList.remove('selected');
      });

      deleteSelectedBtn.disabled = selectedBoxes.size === 0 && selectedConnections.size === 0;
    }

    // Delete boxes and connections by id(s)
    function deleteSelected() {
      if (selectedBoxes.size === 0 && selectedConnections.size === 0) return;
      // Save state for undo
      const deletedData = {
        boxes: [],
        connections: []
      };
      // Delete connections
      connections = connections.filter(conn => {
        const key = conn.from + '->' + conn.to;
        if (selectedConnections.has(key)) {
          deletedData.connections.push(conn);
          return false;
        }
        if (selectedBoxes.has(conn.from) || selectedBoxes.has(conn.to)) {
          deletedData.connections.push(conn);
          return false;
        }
        return true;
      });
      // Delete boxes
      selectedBoxes.forEach(id => {
        const box = document.querySelector(`.box[data-id="${id}"]`);
        if (box) {
          deletedData.boxes.push({
            id: id,
            x: box.offsetLeft,
            y: box.offsetTop,
            width: box.offsetWidth,
            height: box.offsetHeight,
            text: box.querySelector('.box-content').textContent,
            fontSize: box.querySelector('.box-content').style.fontSize
          });
          box.remove();
        }
      });
      undoStack.push(deletedData);
      selectedBoxes.clear();
      selectedConnections.clear();
      updateSelectionVisuals();
      drawConnections();
      undoBtn.disabled = false;
      saveAll();
    }

    function undoDelete() {
      if (undoStack.length === 0) return;
      const last = undoStack.pop();
      last.boxes.forEach(b => {
        createBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize);
      });
      last.connections.forEach(c => {
        connections.push(c);
      });
      drawConnections();
      updateSelectionVisuals();
      undoBtn.disabled = undoStack.length === 0;
      saveAll();
    }

    // Save all boxes and connections to Firestore
    async function saveAll() {
      try {
        const boxesData = [];
        document.querySelectorAll('.box').forEach(box => {
          boxesData.push({
            id: box.dataset.id,
            x: box.offsetLeft,
            y: box.offsetTop,
            width: box.offsetWidth,
            height: box.offsetHeight,
            text: box.querySelector('.box-content').textContent,
            fontSize: box.querySelector('.box-content').style.fontSize
          });
        });
        const data = {
          boxes: boxesData,
          connections: connections,
          panX,
          panY,
          scale,
          updated: Date.now()
        };
        await db.collection('stringsnthings').doc('state').set(data);
      } catch(e) {
        console.warn('Save error:', e);
      }
    }

    // Load from Firestore
    async function loadAll() {
      try {
        const doc = await db.collection('stringsnthings').doc('state').get();
        if (!doc.exists) return;
        const data = doc.data();
        panX = data.panX || 0;
        panY = data.panY || 0;
        scale = data.scale || 1;
        updateTransform();
        connections = data.connections || [];
        canvas.innerHTML = '';
        selectedBoxes.clear();
        selectedConnections.clear();
        data.boxes.forEach(b => {
          createBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize);
        });
        drawConnections();
        updateSelectionVisuals();
      } catch(e) {
        console.warn('Load error:', e);
      }
    }

    // Select mode toggle
    selectModeBtn.addEventListener('click', () => {
      selectMode = !selectMode;
      selectModeBtn.textContent = `Select Mode: ${selectMode ? 'ON' : 'OFF'}`;
      if (!selectMode) {
        selectedBoxes.clear();
        selectedConnections.clear();
        updateSelectionVisuals();
      }
    });

    // Delete selected button
    deleteSelectedBtn.addEventListener('click', () => {
      deleteSelected();
    });

    // Undo button
    undoBtn.addEventListener('click', () => {
      undoDelete();
    });

    // Mark center and Go to center
    let centerMarker = null;
    markCenterBtn.addEventListener('click', () => {
      const rect = viewport.getBoundingClientRect();
      const centerX = (rect.width / 2 - panX) / scale;
      const centerY = (rect.height / 2 - panY) / scale;
      if (!centerMarker) {
        centerMarker = document.createElement('div');
        centerMarker.style.position = 'absolute';
        centerMarker.style.width = '12px';
        centerMarker.style.height = '12px';
        centerMarker.style.background = 'red';
        centerMarker.style.borderRadius = '50%';
        centerMarker.style.zIndex = 9999;
        centerMarker.style.pointerEvents = 'none';
        canvas.appendChild(centerMarker);
      }
      centerMarker.style.left = centerX - 6 + 'px';
      centerMarker.style.top = centerY - 6 + 'px';
      alert(`Center marked at x: ${centerX.toFixed(1)}, y: ${centerY.toFixed(1)}`);
    });

    goCenterBtn.addEventListener('click', () => {
      if (!centerMarker) return;
      const rect = viewport.getBoundingClientRect();
      const centerX = parseFloat(centerMarker.style.left) + 6;
      const centerY = parseFloat(centerMarker.style.top) + 6;
      panX = rect.width / 2 - centerX * scale;
      panY = rect.height / 2 - centerY * scale;
      updateTransform();
    });

    // Double click creates new box at mouse pos adjusted for pan/zoom
    viewport.addEventListener('dblclick', e => {
      if (selectMode) return;
      const rect = viewport.getBoundingClientRect();
      const x = (e.clientX - rect.left - panX) / scale - 90;
      const y = (e.clientY - rect.top - panY) / scale - 40;
      createBox(x, y);
      saveAll();
    });

    // Keyboard delete key deletes selected boxes/connections
    window.addEventListener('keydown', e => {
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectMode && (selectedBoxes.size > 0 || selectedConnections.size > 0)) {
          e.preventDefault();
          deleteSelected();
        }
      }
    });

    // Selection rectangle for multi-select in select mode
    let selecting = false;
    let selStartX = 0;
    let selStartY = 0;

    viewport.addEventListener('pointerdown', e => {
      if (!selectMode) return;
      if (e.target.closest('.box') || e.target.closest('path.connection') || e.target.closest('button')) return;
      selecting = true;
      selStartX = e.clientX;
      selStartY = e.clientY;
      selectionRect.style.left = selStartX + 'px';
      selectionRect.style.top = selStartY + 'px';
      selectionRect.style.width = '0px';
      selectionRect.style.height = '0px';
      selectionRect.style.display = 'block';
      viewport.setPointerCapture(e.pointerId);
    });

    viewport.addEventListener('pointermove', e => {
      if (!selecting) return;
      e.preventDefault();
      const curX = e.clientX;
      const curY = e.clientY;
      const x = Math.min(selStartX, curX);
      const y = Math.min(selStartY, curY);
      const w = Math.abs(selStartX - curX);
      const h = Math.abs(selStartY - curY);
      selectionRect.style.left = x + 'px';
      selectionRect.style.top = y + 'px';
      selectionRect.style.width = w + 'px';
      selectionRect.style.height = h + 'px';
    });

    viewport.addEventListener('pointerup', e => {
      if (!selecting) return;
      selecting = false;
      selectionRect.style.display = 'none';
      viewport.releasePointerCapture(e.pointerId);

      const rect = selectionRect.getBoundingClientRect();

      // Select boxes inside rect
      selectedBoxes.clear();
      selectedConnections.clear();

      document.querySelectorAll('.box').forEach(box => {
        const boxRect = box.getBoundingClientRect();
        if (
          boxRect.left >= rect.left &&
          boxRect.right <= rect.right &&
          boxRect.top >= rect.top &&
          boxRect.bottom <= rect.bottom
        ) {
          selectedBoxes.add(box.dataset.id);
        }
      });

      // Select connections if both ends inside selection box
      connections.forEach(conn => {
        if (selectedBoxes.has(conn.from) && selectedBoxes.has(conn.to)) {
          selectedConnections.add(conn.from + '->' + conn.to);
        }
      });

      updateSelectionVisuals();
    });

    // Save connections helper
    function addConnection(fromId, toId) {
      if (connections.find(c => c.from === fromId && c.to === toId)) return; // prevent duplicates
      connections.push({from: fromId, to: toId});
      drawConnections();
      saveAll();
    }
    function removeConnection(fromId, toId) {
      connections = connections.filter(c => !(c.from === fromId && c.to === toId));
      drawConnections();
      saveAll();
    }

    // When in select mode and 2 boxes selected with connect toggles active, connect them
    // If a connection exists, clicking connect toggle will deselect, then remove connection
    // We'll listen on connectToggle click above for selection; here handle connections:
    // On selectModeBtn toggle or box connectToggle click, check if exactly 2 boxes selected, then toggle connection
    function checkConnectBoxes() {
      if (!selectMode) return;
      if (selectedBoxes.size !== 2) return;
      const ids = Array.from(selectedBoxes);
      const [id1, id2] = ids;
      const connKey1 = connections.find(c => c.from === id1 && c.to === id2);
      const connKey2 = connections.find(c => c.from === id2 && c.to === id1);
      if (connKey1) {
        removeConnection(id1, id2);
      } else if (connKey2) {
        removeConnection(id2, id1);
      } else {
        addConnection(id1, id2);
      }
      selectedBoxes.clear();
      updateSelectionVisuals();
    }

    // Listen for changes to selectionBoxes for connection toggling
    const observer = new MutationObserver(() => {
      checkConnectBoxes();
    });
    observer.observe(canvas, {subtree: true, attributes: true, attributeFilter: ['class']});

    // Initialization
    updateTransform();
    loadAll();

  </script>
</body>
</html>
