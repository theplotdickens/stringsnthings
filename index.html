<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings with Curvy Lines</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  /* Keep your existing styles (boxes, viewport, buttons) unchanged */
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
  }
  #canvas {
    position: absolute; top: 0; left: 0; transform-origin: 0 0;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    padding: 8px;
    min-width: 80px;
    min-height: 40px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    user-select: text;
    touch-action: none;
    cursor: text;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    z-index: 10;
  }
  .box > div[contenteditable="true"] {
    outline: none;
    white-space: pre-wrap;
    word-break: break-word;
    font-family: monospace, monospace;
    user-select: text;
    cursor: text;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: 1.2;
  }
  .delete-btn {
    position: absolute;
    top: 2px; right: 4px;
    cursor: pointer;
    color: red;
    font-weight: bold;
    user-select: none;
    pointer-events: auto;
    z-index: 20;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn.active {
    background: rgba(50, 150, 200, 0.8);
    color: white;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }

  /* SVG styling */
  #lineLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    overflow: visible;
    z-index: 5;
  }
  .line-path {
    fill: none;
    stroke: black;
    stroke-width: 2;
  }
  .line-label {
    font-family: monospace, monospace;
    font-size: 14px;
    fill: black;
    pointer-events: none;
    user-select: none;
  }
</style>
</head>
<body>
<div id="viewport">
  <svg id="lineLayer"></svg>
  <div id="canvas"></div>
</div>

<div id="buttonContainer">
  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
  <button id="drawLineToggle" class="floatingBtn">Draw Line OFF</button>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.firebasestorage.app",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const lineLayer = document.getElementById('lineLayer');

  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const drawLineToggle = document.getElementById('drawLineToggle');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;
  const undoStack = [];

  // For line drawing mode
  let drawLineMode = false;
  let selectedBoxes = []; // Store start and end box elements for the line
  let currentPathPoints = []; // Points while drawing freehand
  let isDrawingPath = false;

  // Collection references
  const boxesCollection = db.collection('boxes');
  const linesCollection = db.collection('lines');

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    lineLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  // Panning & zooming
  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }
  viewport.addEventListener('pointerdown', e => {
    if (drawLineMode) return; // disable pan in draw mode
    if (e.target.closest('.box') || e.target === goCenterBtn || e.target === undoBtn || e.target === drawLineToggle) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
  });
  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });
  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    scale *= dir;
    updateTransform();
  });

  // Boxes code (simplified for brevity, use your last working version with resizing, dragging, saving, deleting)
  function adjustFontSizeToFit(contentDiv, box) {
    const padding = 8; // padding in px inside box
    const maxFontSize = 100;
    const minFontSize = 8;

    contentDiv.style.fontSize = maxFontSize + 'px';

    const boxWidth = box.clientWidth - padding * 2;
    const boxHeight = box.clientHeight - padding * 2;

    let fontSize = maxFontSize;

    while (fontSize >= minFontSize) {
      contentDiv.style.fontSize = fontSize + 'px';
      if (contentDiv.scrollWidth <= boxWidth && contentDiv.scrollHeight <= boxHeight) {
        break;
      }
      fontSize -= 1;
    }
    if (fontSize < minFontSize) fontSize = minFontSize;
    contentDiv.style.fontSize = fontSize + 'px';
  }

  function addBox(x, y, text = 'Text box', id = null, width=180, height=80, fontSize='16px') {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = width + 'px';
    box.style.height = height + 'px';

    const content = document.createElement('div');
    content.contentEditable = true;
    content.style.minWidth = '80px';
    content.style.minHeight = '24px';
    content.style.whiteSpace = 'pre-wrap';
    content.style.wordBreak = 'break-word';
    content.style.outline = 'none';
    content.style.fontFamily = 'monospace, monospace';
    content.textContent = text;
    content.style.userSelect = 'text';
    content.style.cursor = 'text';
    content.style.height = '100%';
    content.style.width = '100%';
    content.style.boxSizing = 'border-box';
    content.style.padding = '0';
    content.style.margin = '0';
    content.style.overflow = 'visible';
    content.style.lineHeight = '1.2';
    content.style.fontSize = fontSize || '16px';

    if (fontSize === '16px' || !fontSize) {
      adjustFontSizeToFit(content, box);
    }

    content.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.execCommand('insertHTML', false, '\n');
      }
    });

    const delBtn = document.createElement('span');
    delBtn.className = 'delete-btn';
    delBtn.textContent = 'Ã—';

    box.appendChild(content);
    box.appendChild(delBtn);

    // skipping resize handles here for brevity, but you can add back your code from before

    // Dragging logic simplified
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    box.addEventListener('pointerdown', e => {
      if (e.target === delBtn) return;
      if (drawLineMode) {
        // If drawLineMode is on, handle box selection for lines
        e.stopPropagation();
        handleBoxSelection(box);
        return;
      }
      dragging = true;
      offsetX = e.clientX - box.getBoundingClientRect().left;
      offsetY = e.clientY - box.getBoundingClientRect().top;
      box.setPointerCapture(e.pointerId);
      box.style.cursor = 'grabbing';
    });
    box.addEventListener('pointermove', e => {
      if (!dragging) return;
      const newX = (e.clientX - offsetX - panX) / scale;
      const newY = (e.clientY - offsetY - panY) / scale;
      box.style.left = `${newX}px`;
      box.style.top = `${newY}px`;
      saveBox();
      updateLinesForBox(idMap.get(box));
    });
    box.addEventListener('pointerup', e => {
      dragging = false;
      box.style.cursor = 'text';
      box.releasePointerCapture(e.pointerId);
    });

    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      undoStack.push({
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        text: content.textContent,
        width: box.offsetWidth,
        height: box.offsetHeight,
        fontSize: content.style.fontSize,
        id: idMap.get(box)
      });
      if (undoStack.length > 5) undoStack.shift();
      undoBtn.disabled = false;
      if (idMap.has(box)) {
        linesToRemoveForBox(idMap.get(box));
        boxesCollection.doc(idMap.get(box)).delete();
      }
      box.remove();
    });

    content.addEventListener('input', () => {
      adjustFontSizeToFit(content, box);
      saveBox();
    });

    function saveBox() {
      const data = {
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        width: box.offsetWidth,
        height: box.offsetHeight,
        text: content.textContent,
        fontSize: content.style.fontSize || '16px'
      };
      const boxId = idMap.get(box);
      if (boxId) {
        boxesCollection.doc(boxId).set(data);
      } else {
        boxesCollection.add(data).then(docRef => {
          idMap.set(box, docRef.id);
        });
      }
    }

    canvas.appendChild(box);
    if (!id) {
      boxesCollection.add({
        x, y, width, height,
        text, fontSize
      }).then(docRef => {
        idMap.set(box, docRef.id);
      });
    } else {
      idMap.set(box, id);
    }

    return box;
  }

  // Map box element => firestore doc id
  const idMap = new Map();
  // Map line doc id => {path, label, startBoxId, endBoxId, svg elements}
  const linesMap = new Map();

  // Undo and go center buttons
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastBox = undoStack.pop();
    const box = addBox(lastBox.x, lastBox.y, lastBox.text, null, lastBox.width, lastBox.height, lastBox.fontSize);
    if (undoStack.length === 0) undoBtn.disabled = true;
  });

  goCenterBtn.addEventListener('click', () => {
    panX = 0; panY = 0; updateTransform();
  });

  drawLineToggle.addEventListener('click', () => {
    drawLineMode = !drawLineMode;
    drawLineToggle.textContent = drawLineMode ? 'Draw Line ON' : 'Draw Line OFF';
    if (!drawLineMode) {
      selectedBoxes = [];
      if (isDrawingPath) {
        stopDrawingPath();
      }
    }
  });

  // Box selection for line start/end
  function handleBoxSelection(box) {
    if (selectedBoxes.length === 0) {
      selectedBoxes.push(box);
      box.style.borderColor = 'blue';
    } else if (selectedBoxes.length === 1 && box !== selectedBoxes[0]) {
      selectedBoxes.push(box);
      box.style.borderColor = 'blue';
      startFreehandDrawing();
    }
  }

  // Drawing freehand path variables
  let pathSvg, pathElement, labelElement;

  function startFreehandDrawing() {
    isDrawingPath = true;
    currentPathPoints = [];

    // Create SVG path & label elements
    pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathElement.classList.add('line-path');
    lineLayer.appendChild(pathElement);

    labelElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelElement.classList.add('line-label');
    lineLayer.appendChild(labelElement);

    viewport.style.cursor = 'crosshair';

    viewport.addEventListener('pointerdown', pointerDownDraw);
    viewport.addEventListener('pointermove', pointerMoveDraw);
    viewport.addEventListener('pointerup', pointerUpDraw);
  }

  function pointerDownDraw(e) {
    if (!isDrawingPath) return;
    currentPathPoints = [];
    const pt = screenToCanvas(e.clientX, e.clientY);
    currentPathPoints.push(pt);
  }
  function pointerMoveDraw(e) {
    if (!isDrawingPath || currentPathPoints.length === 0) return;
    const pt = screenToCanvas(e.clientX, e.clientY);
    currentPathPoints.push(pt);
    redrawPath();
  }
  function pointerUpDraw(e) {
    if (!isDrawingPath) return;
    const label = prompt("Enter label for the line:", "");
    if (label === null) {
      cancelLineDrawing();
      return;
    }
    saveLine(label);
    stopDrawingPath();
  }

  function stopDrawingPath() {
    isDrawingPath = false;
    viewport.style.cursor = 'grab';
    viewport.removeEventListener('pointerdown', pointerDownDraw);
    viewport.removeEventListener('pointermove', pointerMoveDraw);
    viewport.removeEventListener('pointerup', pointerUpDraw);
    // Reset box borders
    selectedBoxes.forEach(box => box.style.borderColor = '');
    selectedBoxes = [];
  }

  // Convert screen coords to canvas coords (accounting pan/zoom)
  function screenToCanvas(x, y) {
    return {
      x: (x - panX) / scale,
      y: (y - panY) / scale
    };
  }

  // Smooth path redraw using simple Catmull-Rom spline interpolation
  function redrawPath() {
    if (currentPathPoints.length < 2) return;
    const d = catmullRomSpline(currentPathPoints);
    pathElement.setAttribute('d', d);
    // Update label position roughly halfway on path
    const midPoint = getPathMidPoint(d);
    if (midPoint) {
      labelElement.setAttribute('x', midPoint.x);
      labelElement.setAttribute('y', midPoint.y);
      labelElement.textContent = currentPathPoints.length > 5 ? labelElement.textContent : '';
    }
  }

  // Catmull-Rom spline for smooth curves
  function catmullRomSpline(points) {
    if (points.length < 2) return '';
    let d = `M ${points[0].x} ${points[0].y}`;
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i === 0 ? i : i - 1];
      const p1 = points[i];
      const p2 = points[i + 1];
      const p3 = points[i + 2 < points.length ? i + 2 : points.length - 1];

      const cp1x = p1.x + (p2.x - p0.x) / 6;
      const cp1y = p1.y + (p2.y - p0.y) / 6;

      const cp2x = p2.x - (p3.x - p1.x) / 6;
      const cp2y = p2.y - (p3.y - p1.y) / 6;

      d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
    }
    return d;
  }

  // Get midpoint of SVG path string (approximate)
  function getPathMidPoint(d) {
    try {
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', d);
      const length = path.getTotalLength();
      const pt = path.getPointAtLength(length / 2);
      return { x: pt.x, y: pt.y };
    } catch (e) {
      return null;
    }
  }

  function saveLine(label) {
    if (selectedBoxes.length !== 2) return;
    const startBoxId = idMap.get(selectedBoxes[0]);
    const endBoxId = idMap.get(selectedBoxes[1]);
    if (!startBoxId || !endBoxId) return;

    // Save the points and label
    const pointsToSave = currentPathPoints.map(p => ({x: p.x, y: p.y}));
    linesCollection.add({
      startBoxId,
      endBoxId,
      points: pointsToSave,
      label
    }).then(docRef => {
      // Store line in map and clear temp elements
      linesMap.set(docRef.id, { points: pointsToSave, label, startBoxId, endBoxId, svgPath: pathElement, svgLabel: labelElement });
      pathElement = null;
      labelElement = null;
      currentPathPoints = [];
    });

    // Clear box borders
    selectedBoxes.forEach(box => box.style.borderColor = '');
    selectedBoxes = [];
  }

  // Update lines positions if boxes move
  function updateLinesForBox(boxId) {
    linesMap.forEach((line, lineId) => {
      if (line.startBoxId === boxId || line.endBoxId === boxId) {
        const startBox = [...idMap.entries()].find(([el, id]) => id === line.startBoxId)[0];
        const endBox = [...idMap.entries()].find(([el, id]) => id === line.endBoxId)[0];
        if (!startBox || !endBox) return;

        // Calculate offset between old points and new endpoints
        const oldStart = line.points[0];
        const oldEnd = line.points[line.points.length - 1];
        const newStart = { x: parseFloat(startBox.style.left) + startBox.offsetWidth / 2, y: parseFloat(startBox.style.top) + startBox.offsetHeight / 2 };
        const newEnd = { x: parseFloat(endBox.style.left) + endBox.offsetWidth / 2, y: parseFloat(endBox.style.top) + endBox.offsetHeight / 2 };

        // Compute translation deltas
        const dx = newStart.x - oldStart.x;
        const dy = newStart.y - oldStart.y;
        const dxEnd = newEnd.x - oldEnd.x;
        const dyEnd = newEnd.y - oldEnd.y;

        // Move all intermediate points proportionally (simple linear)
        const newPoints = line.points.map((pt, i) => {
          if (i === 0) return newStart;
          if (i === line.points.length - 1) return newEnd;
          const t = i / (line.points.length - 1);
          return {
            x: pt.x + dx * (1 - t) + dxEnd * t,
            y: pt.y + dy * (1 - t) + dyEnd * t
          };
        });

        // Update line data and SVG path
        line.points = newPoints;
        const d = catmullRomSpline(newPoints);
        line.svgPath.setAttribute('d', d);

        // Update label pos
        const midPoint = getPathMidPoint(d);
        if (midPoint) {
          line.svgLabel.setAttribute('x', midPoint.x);
          line.svgLabel.setAttribute('y', midPoint.y);
          line.svgLabel.textContent = line.label;
        }

        // Save updated points to Firestore
        linesCollection.doc(lineId).set({
          startBoxId: line.startBoxId,
          endBoxId: line.endBoxId,
          points: newPoints,
          label: line.label
        });
      }
    });
  }

  // Load boxes and lines from Firestore
  function loadFromFirestore() {
    boxesCollection.onSnapshot(snapshot => {
      snapshot.docChanges().forEach(change => {
        const data = change.doc.data();
        if (change.type === 'added') {
          addBox(data.x, data.y, data.text, change.doc.id, data.width, data.height, data.fontSize);
        } else if (change.type === 'modified') {
          // Update existing box
          const boxEntry = [...idMap.entries()].find(([el, id]) => id === change.doc.id);
          if (boxEntry) {
            const [boxEl] = boxEntry;
            boxEl.style.left = data.x + 'px';
            boxEl.style.top = data.y + 'px';
            boxEl.style.width = data.width + 'px';
            boxEl.style.height = data.height + 'px';
            const contentDiv = boxEl.querySelector('div[contenteditable]');
            contentDiv.textContent = data.text;
            contentDiv.style.fontSize = data.fontSize;
            adjustFontSizeToFit(contentDiv, boxEl);
            updateLinesForBox(change.doc.id);
          }
        } else if (change.type === 'removed') {
          const boxEntry = [...idMap.entries()].find(([el, id]) => id === change.doc.id);
          if (boxEntry) {
            const [boxEl] = boxEntry;
            boxEl.remove();
            idMap.delete(boxEl);
          }
        }
      });
    });

    linesCollection.onSnapshot(snapshot => {
      snapshot.docChanges().forEach(change => {
        const data = change.doc.data();
        if (change.type === 'added') {
          drawSavedLine(change.doc.id, data);
        } else if (change.type === 'modified') {
          updateSavedLine(change.doc.id, data);
        } else if (change.type === 'removed') {
          removeSavedLine(change.doc.id);
        }
      });
    });
  }

  function drawSavedLine(id, data) {
    if (linesMap.has(id)) return; // Already drawn

    const startBoxEntry = [...idMap.entries()].find(([el, bid]) => bid === data.startBoxId);
    const endBoxEntry = [...idMap.entries()].find(([el, bid]) => bid === data.endBoxId);
    if (!startBoxEntry || !endBoxEntry) return;

    const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathEl.classList.add('line-path');
    lineLayer.appendChild(pathEl);

    const labelEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelEl.classList.add('line-label');
    lineLayer.appendChild(labelEl);

    linesMap.set(id, {
      points: data.points,
      label: data.label,
      startBoxId: data.startBoxId,
      endBoxId: data.endBoxId,
      svgPath: pathEl,
      svgLabel: labelEl
    });

    updateLinesForBox(data.startBoxId);
    updateLinesForBox(data.endBoxId);
  }

  function updateSavedLine(id, data) {
    if (!linesMap.has(id)) return;
    const line = linesMap.get(id);
    line.points = data.points;
    line.label = data.label;
    updateLinesForBox(line.startBoxId);
  }

  function removeSavedLine(id) {
    if (!linesMap.has(id)) return;
    const line = linesMap.get(id);
    line.svgPath.remove();
    line.svgLabel.remove();
    linesMap.delete(id);
  }

  // Create initial box for testing if none exist
  boxesCollection.get().then(snapshot => {
    if (snapshot.empty) {
      addBox(100, 100, 'Hello World');
    }
  });

  loadFromFirestore();
</script>
</body>
</html>
