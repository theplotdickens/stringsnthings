<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV4-fixed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(200,200,200,0.8);
      padding: 6px 12px;
      border-radius: 6px;
      display: flex;
      gap: 12px;
      z-index: 1500;
      font-family: monospace, monospace;
      user-select: none;
      align-items: center;
    }
    #topMenu select, #topMenu button {
      font-family: monospace, monospace;
      font-size: 14px;
      padding: 4px 8px;
      cursor: pointer;
    }
    #statusMessage {
      font-size: 12px;
      color: green;
      min-width: 120px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1;"></svg>
    <div id="canvas"></div>
  </div>

  <div id="topMenu">
    <select id="mapSelect"></select>
    <button id="saveBtn">Save Map</button>
    <button id="deleteBtn">Delete Map</button>
    <button id="renameBtn">Rename Map</button>
    <span id="statusMessage"></span>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons in box headers to change font size.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-app.js";
    import { getFirestore, collection, doc, getDoc, getDocs, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-firestore.js";

    // Your Firebase config here
    const firebaseConfig = {
      apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
      authDomain: "stringsnthings-65aa0.firebaseapp.com",
      projectId: "stringsnthings-65aa0",
      storageBucket: "stringsnthings-65aa0.appspot.com",
      messagingSenderId: "35780192306",
      appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const canvas = document.getElementById('canvas');
    const viewport = document.getElementById('viewport');
    const undoBtn = document.getElementById('undoBtn');
    const goCenterBtn = document.getElementById('goCenterBtn');
    const markCenterBtn = document.getElementById('markCenterBtn');
    const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
    const howToBtn = document.getElementById('howToBtn');
    const howToModal = document.getElementById('howToModal');
    const closeHowToBtn = document.getElementById('closeHowToBtn');
    const mapSelect = document.getElementById('mapSelect');
    const saveBtn = document.getElementById('saveBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const renameBtn = document.getElementById('renameBtn');
    const statusMessage = document.getElementById('statusMessage');
    const connectionLayer = document.getElementById('connectionLayer');

    let scale = 1, panX = 0, panY = 0;
    let isPanning = false, startX, startY;

    const undoStack = [];
    const connections = [];
    const boxesMap = new Map();

    let editMode = true;
    let connectionStartBoxId = null;
    const selectedBoxes = new Set();

    let currentMapId = null;
    let currentMapName = null;

    function getClientCoords(e) {
      if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      return { x: e.clientX, y: e.clientY };
    }

    viewport.addEventListener('pointerdown', e => {
      if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) || e.target.closest('#topMenu')) return;
      isPanning = true;
      const coords = getClientCoords(e);
      startX = coords.x;
      startY = coords.y;
      viewport.setPointerCapture(e.pointerId);
      // deselect on background click
      selectedBoxes.forEach(b => b.classList.remove('selected'));
      selectedBoxes.clear();
    });

    viewport.addEventListener('pointermove', e => {
      if (!isPanning) return;
      const coords = getClientCoords(e);
      panX += coords.x - startX;
      panY += coords.y - startY;
      startX = coords.x;
      startY = coords.y;
      updateTransform();
      drawConnections();
    });

    viewport.addEventListener('pointerup', e => {
      isPanning = false;
      viewport.releasePointerCapture(e.pointerId);
    });

    const MIN_SCALE = 0.5;
    const MAX_SCALE = 3;

    viewport.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
      let newScale = scale * dir;
      newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const wx = (mouseX - panX) / scale;
      const wy = (mouseY - panY) / scale;
      scale = newScale;
      panX = mouseX - wx * scale;
      panY = mouseY - wy * scale;
      updateTransform();
      drawConnections();
    });

    function updateTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    let lastTap = 0;
    viewport.addEventListener('pointerdown', e => {
      if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) || e.target.closest('#topMenu')) return;
      const now = Date.now();
      if (now - lastTap < 400 && !e.target.closest('.box')) {
        const x = (e.clientX - panX) / scale;
        const y = (e.clientY - panY) / scale;
        addBox(x, y);
      }
      lastTap = now;
    });

    markCenterBtn.addEventListener('click', async () => {
      if (!currentMapId) return;
      try {
        await setDoc(doc(db, 'mindmaps', currentMapId), {
          center: { panX, panY, scale }
        }, { merge: true });
        showStatus('Center position marked and saved.');
      } catch (e) {
        showStatus('Error saving center.', true);
      }
    });

    goCenterBtn.addEventListener('click', () => {
      panX = 0; panY = 0; scale = 1;
      updateTransform();
      drawConnections();
    });

    toggleEditModeBtn.addEventListener('click', () => {
      editMode = !editMode;
      updateEditMode();
    });

    howToBtn.addEventListener('click', () => {
      howToModal.style.display = 'block';
    });

    closeHowToBtn.addEventListener('click', () => {
      howToModal.style.display = 'none';
    });

    saveBtn.addEventListener('click', saveCurrentMap);
    deleteBtn.addEventListener('click', deleteCurrentMap);
    renameBtn.addEventListener('click', renameCurrentMap);

    mapSelect.addEventListener('change', () => {
      if (!mapSelect.value) return;
      loadMap(mapSelect.value);
    });

    undoBtn.addEventListener('click', undoDelete);

    function showStatus(msg, isError = false) {
      statusMessage.textContent = msg;
      statusMessage.style.color = isError ? 'red' : 'green';
      setTimeout(() => {
        statusMessage.textContent = '';
      }, 3000);
    }

    function generateId() {
      return 'id-' + Math.random().toString(36).slice(2, 10);
    }

    function addBox(x, y, text = '', id = null, fontSize = 14, width = 120, height = 60) {
      if (!id) id = generateId();
      const box = document.createElement('div');
      box.className = 'box';
      box.style.left = x + 'px';
      box.style.top = y + 'px';
      box.style.width = width + 'px';
      box.style.height = height + 'px';
      box.dataset.id = id;

      // header for drag + delete + connect + font size
      const header = document.createElement('div');
      header.className = 'box-header';

      // drag handle ✥
      const dragHandle = document.createElement('div');
      dragHandle.className = 'drag-handle';
      dragHandle.textContent = '✥';
      header.appendChild(dragHandle);

      // connect toggle button
      const connectToggle = document.createElement('button');
      connectToggle.className = 'connect-toggle';
      connectToggle.title = 'Connect this box';
      header.appendChild(connectToggle);

      // font size minus button
      const fontMinus = document.createElement('button');
      fontMinus.className = 'font-size-btn';
      fontMinus.textContent = '−';
      fontMinus.title = 'Decrease font size';
      header.appendChild(fontMinus);

      // font size plus button
      const fontPlus = document.createElement('button');
      fontPlus.className = 'font-size-btn';
      fontPlus.textContent = '+';
      fontPlus.title = 'Increase font size';
      header.appendChild(fontPlus);

      // delete button
      const deleteBtnBox = document.createElement('button');
      deleteBtnBox.className = 'delete-btn';
      deleteBtnBox.textContent = '×';
      deleteBtnBox.title = 'Delete box';
      header.appendChild(deleteBtnBox);

      box.appendChild(header);

      // content editable text
      const content = document.createElement('div');
      content.className = 'box-content';
      content.contentEditable = editMode;
      content.spellcheck = false;
      content.style.fontSize = fontSize + 'px';
      content.textContent = text;
      box.appendChild(content);

      // resize handles
      ['nw','ne','sw','se'].forEach(pos => {
        const handle = document.createElement('div');
        handle.className = 'resize-handle ' + pos;
        box.appendChild(handle);
      });

      canvas.appendChild(box);

      boxesMap.set(id, {
        box, content, header, dragHandle, connectToggle, fontMinus, fontPlus, deleteBtnBox,
        fontSize, width, height
      });

      // Setup event listeners
      setupBoxEvents(id);

      return id;
    }

    function setupBoxEvents(id) {
      const { box, content, header, dragHandle, connectToggle, fontMinus, fontPlus, deleteBtnBox } = boxesMap.get(id);

      // Dragging
      let dragging = false, dragStartX, dragStartY, origX, origY;
      dragHandle.addEventListener('pointerdown', e => {
        e.preventDefault();
        dragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        origX = parseFloat(box.style.left);
        origY = parseFloat(box.style.top);
        document.addEventListener('pointermove', dragMove);
        document.addEventListener('pointerup', dragEnd);
      });
      function dragMove(e) {
        if (!dragging) return;
        let dx = (e.clientX - dragStartX) / scale;
        let dy = (e.clientY - dragStartY) / scale;
        // If multi-selected move all selected
        if (selectedBoxes.has(box)) {
          selectedBoxes.forEach(b => {
            let bx = parseFloat(b.style.left);
            let by = parseFloat(b.style.top);
            b.style.left = (bx + dx) + 'px';
            b.style.top = (by + dy) + 'px';
          });
        } else {
          box.style.left = (origX + dx) + 'px';
          box.style.top = (origY + dy) + 'px';
        }
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        drawConnections();
      }
      function dragEnd(e) {
        dragging = false;
        document.removeEventListener('pointermove', dragMove);
        document.removeEventListener('pointerup', dragEnd);
      }

      // Shift+click to multi-select on header or drag handle
      header.addEventListener('click', e => {
        if (!e.shiftKey) return;
        e.preventDefault();
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      });

      // Connect toggle
      connectToggle.addEventListener('click', () => {
        if (connectionStartBoxId === id) {
          connectionStartBoxId = null;
          connectToggle.classList.remove('active');
        } else if (connectionStartBoxId === null) {
          connectionStartBoxId = id;
          connectToggle.classList.add('active');
        } else {
          // Connect start to this box, if different
          if (connectionStartBoxId !== id) {
            connections.push({ from: connectionStartBoxId, to: id });
            connectionStartBoxId = null;
            // Reset all connect buttons
            boxesMap.forEach(({ connectToggle }) => connectToggle.classList.remove('active'));
            drawConnections();
          }
        }
      });

      // Delete box
      deleteBtnBox.addEventListener('click', () => {
        deleteBox(id);
      });

      // Font size buttons
      fontMinus.addEventListener('click', () => {
        if (boxesMap.get(id).fontSize > 6) {
          boxesMap.get(id).fontSize -= 1;
          content.style.fontSize = boxesMap.get(id).fontSize + 'px';
        }
      });
      fontPlus.addEventListener('click', () => {
        if (boxesMap.get(id).fontSize < 48) {
          boxesMap.get(id).fontSize += 1;
          content.style.fontSize = boxesMap.get(id).fontSize + 'px';
        }
      });

      // Content editable toggle on editMode change
      content.contentEditable = editMode;

      // Resize logic
      let resizing = false;
      let resizeDir = null;
      let startResizeX, startResizeY, startWidth, startHeight, startLeft, startTop;

      const resizeHandles = box.querySelectorAll('.resize-handle');
      resizeHandles.forEach(handle => {
        handle.addEventListener('pointerdown', e => {
          e.preventDefault();
          resizing = true;
          resizeDir = handle.classList[1];
          startResizeX = e.clientX;
          startResizeY = e.clientY;
          startWidth = box.offsetWidth;
          startHeight = box.offsetHeight;
          startLeft = parseFloat(box.style.left);
          startTop = parseFloat(box.style.top);
          document.addEventListener('pointermove', resizeMove);
          document.addEventListener('pointerup', resizeEnd);
        });
      });

      function resizeMove(e) {
        if (!resizing) return;
        let dx = (e.clientX - startResizeX) / scale;
        let dy = (e.clientY - startResizeY) / scale;

        if (resizeDir.includes('e')) {
          box.style.width = Math.max(40, startWidth + dx) + 'px';
        }
        if (resizeDir.includes('s')) {
          box.style.height = Math.max(30, startHeight + dy) + 'px';
        }
        if (resizeDir.includes('w')) {
          let newWidth = Math.max(40, startWidth - dx);
          let newLeft = startLeft + dx;
          if (newWidth > 40) {
            box.style.width = newWidth + 'px';
            box.style.left = newLeft + 'px';
          }
        }
        if (resizeDir.includes('n')) {
          let newHeight = Math.max(30, startHeight - dy);
          let newTop = startTop + dy;
          if (newHeight > 30) {
            box.style.height = newHeight + 'px';
            box.style.top = newTop + 'px';
          }
        }
        drawConnections();
      }
      function resizeEnd(e) {
        resizing = false;
        document.removeEventListener('pointermove', resizeMove);
        document.removeEventListener('pointerup', resizeEnd);
      }
    }

    function deleteBox(id) {
      const boxObj = boxesMap.get(id);
      if (!boxObj) return;
      // Remove box element
      canvas.removeChild(boxObj.box);
      // Remove box data
      boxesMap.delete(id);
      // Remove connections to/from this box
      for (let i = connections.length - 1; i >= 0; i--) {
        if (connections[i].from === id || connections[i].to === id) {
          connections.splice(i, 1);
        }
      }
      undoStack.push({ type: 'deleteBox', id, box: boxObj, connections: [] });
      drawConnections();
      updateUndoButton();
    }

    function updateUndoButton() {
      undoBtn.disabled = undoStack.length === 0;
    }

    function undoDelete() {
      if (undoStack.length === 0) return;
      const action = undoStack.pop();
      if (action.type === 'deleteBox') {
        const { id, box, connections: deletedConnections } = action;
        canvas.appendChild(box.box);
        boxesMap.set(id, box);
        deletedConnections.forEach(c => connections.push(c));
        setupBoxEvents(id);
      }
      drawConnections();
      updateUndoButton();
    }

    function clearCanvas() {
      boxesMap.forEach(({ box }) => {
        if (canvas.contains(box)) canvas.removeChild(box);
      });
      boxesMap.clear();
      connections.length = 0;
      selectedBoxes.clear();
      drawConnections();
    }

    function drawConnections() {
      while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);
      connections.forEach(({ from, to }) => {
        const fromObj = boxesMap.get(from);
        const toObj = boxesMap.get(to);
        if (!fromObj || !toObj) return;
        const fromBox = fromObj.box;
        const toBox = toObj.box;
        // Box centers in unscaled coords
        const fromX = parseFloat(fromBox.style.left) + fromBox.offsetWidth / 2;
        const fromY = parseFloat(fromBox.style.top) + fromBox.offsetHeight / 2;
        const toX = parseFloat(toBox.style.left) + toBox.offsetWidth / 2;
        const toY = parseFloat(toBox.style.top) + toBox.offsetHeight / 2;

        // Apply pan and scale to coordinates for svg line
        const startX = fromX * scale + panX;
        const startY = fromY * scale + panY;
        const endX = toX * scale + panX;
        const endY = toY * scale + panY;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute('x1', startX);
        line.setAttribute('y1', startY);
        line.setAttribute('x2', endX);
        line.setAttribute('y2', endY);
        line.setAttribute('stroke', 'black');
        line.setAttribute('stroke-width', '1.5');
        connectionLayer.appendChild(line);
      });
    }

    async function saveCurrentMap() {
      if (!currentMapId) {
        // New map: ask for name
        let newName = prompt('Enter name for new map');
        if (!newName) {
          showStatus('Save cancelled', true);
          return;
        }
        currentMapId = generateId();
        currentMapName = newName;
      }
      const boxesToSave = [];
      boxesMap.forEach(({ box, content, fontSize }) => {
        boxesToSave.push({
          id: box.dataset.id,
          x: parseFloat(box.style.left),
          y: parseFloat(box.style.top),
          text: content.textContent,
          fontSize: fontSize,
          width: box.offsetWidth,
          height: box.offsetHeight
        });
      });
      try {
        await setDoc(doc(db, 'mindmaps', currentMapId), {
          name: currentMapName,
          boxes: boxesToSave,
          connections,
          center: { panX, panY, scale }
        });
        await refreshMapList();
        mapSelect.value = currentMapId;
        showStatus('Save successful');
      } catch (e) {
        showStatus('Save failed', true);
      }
    }

    async function deleteCurrentMap() {
      if (!currentMapId) return;
      if (!confirm(`Delete map "${currentMapName}"? This cannot be undone.`)) return;
      try {
        await deleteDoc(doc(db, 'mindmaps', currentMapId));
        currentMapId = null;
        currentMapName = null;
        clearCanvas();
        await refreshMapList();
        mapSelect.value = '';
        showStatus('Deleted map');
      } catch (e) {
        showStatus('Delete failed', true);
      }
    }

    async function renameCurrentMap() {
      if (!currentMapId) return;
      const newName = prompt('Enter new name', currentMapName);
      if (!newName) return;
      currentMapName = newName;
      try {
        await setDoc(doc(db, 'mindmaps', currentMapId), { name: newName }, { merge: true });
        await refreshMapList();
        mapSelect.value = currentMapId;
        showStatus('Rename successful');
      } catch (e) {
        showStatus('Rename failed', true);
      }
    }

    async function refreshMapList() {
      mapSelect.innerHTML = '<option value="">-- Select Map --</option>';
      const querySnapshot = await getDocs(collection(db, 'mindmaps'));
      querySnapshot.forEach(docSnap => {
        const data = docSnap.data();
        const opt = document.createElement('option');
        opt.value = docSnap.id;
        opt.textContent = data.name || docSnap.id;
        mapSelect.appendChild(opt);
      });
    }

    async function loadMap(id) {
      try {
        const docSnap = await getDoc(doc(db, 'mindmaps', id));
        if (!docSnap.exists()) {
          alert('Map not found');
          return;
        }
        currentMapId = id;
        const data = docSnap.data();
        currentMapName = data.name || id;
        clearCanvas();

        if (Array.isArray(data.boxes)) {
          data.boxes.forEach(b => {
            addBox(b.x, b.y, b.text, b.id, b.fontSize || 14, b.width || 120, b.height || 60);
          });
        }
        connections.length = 0;
        if (Array.isArray(data.connections)) {
          data.connections.forEach(c => connections.push(c));
        }
        panX = data.center?.panX ?? 0;
        panY = data.center?.panY ?? 0;
        scale = data.center?.scale ?? 1;
        updateTransform();
        drawConnections();
        mapSelect.value = id;
        updateEditMode();
        showStatus(`Loaded "${currentMapName}"`);
      } catch (e) {
        alert('Load failed');
      }
    }

    function updateEditMode() {
      boxesMap.forEach(({ content, header }) => {
        content.contentEditable = editMode;
        header.style.display = editMode ? 'flex' : 'none';
      });
      toggleEditModeBtn.textContent = editMode ? 'View Mode' : 'Edit Mode';
    }

    // Initialize on load
    (async () => {
      await refreshMapList();
      if (mapSelect.options.length > 1) {
        loadMap(mapSelect.options[1].value);
      }
      updateEditMode();
    })();
  </script>
</body>
</html>
