<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV3thisonewasgood</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #mindmapSelectorContainer {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1100;
      background: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 8px rgba(0,0,0,0.2);
      font-family: monospace;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #mindmapSelector {
      min-width: 150px;
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
    }
    #newMindmapName {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      width: 150px;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="mindmapSelectorContainer">
    <label for="mindmapSelector">Mind Map:</label>
    <select id="mindmapSelector"></select>
    <input type="text" id="newMindmapName" placeholder="New mind map name" />
    <button id="createMindmapBtn" class="floatingBtn" style="min-width: auto; padding: 2px 6px;">Create</button>
    <button id="saveBtn" class="floatingBtn">Save</button>
    <button id="loadBtn" class="floatingBtn">Load</button>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      **New:** Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the Mind Map selector at top to switch between saved mind maps or create a new one.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
  import {
    getFirestore,
    collection,
    doc,
    getDoc,
    getDocs,
    setDoc,
    updateDoc,
    deleteDoc
  } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // Elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mindmapSelector = document.getElementById('mindmapSelector');
  const newMindmapNameInput = document.getElementById('newMindmapName');
  const createMindmapBtn = document.getElementById('createMindmapBtn');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const connectionLayer = document.getElementById('connectionLayer');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMindmapId = null;
  let mindmapsList = [];

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn, createMindmapBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // deselect on background click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn, createMindmapBtn].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  markCenterBtn.addEventListener('click', () => {
    const rect = viewport.getBoundingClientRect();
    const centerX = (rect.width / 2 - panX) / scale;
    const centerY = (rect.height / 2 - panY) / scale;
    saveCenter(centerX, centerY);
    alert('Center marked at: ' + Math.round(centerX) + ', ' + Math.round(centerY));
  });

  goCenterBtn.addEventListener('click', () => {
    loadCenter().then(center => {
      const rect = viewport.getBoundingClientRect();
      if (center) {
        panX = rect.width / 2 - center.x * scale;
        panY = rect.height / 2 - center.y * scale;
      } else {
        panX = window.innerWidth / 2;
        panY = window.innerHeight / 2;
      }
      updateTransform();
    });
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    document.querySelectorAll('.box-header').forEach(header => {
      header.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.connect-toggle').forEach(toggle => {
      toggle.style.display = editMode ? 'inline-block' : 'none';
    });
    document.querySelectorAll('.font-size-btn').forEach(btn => {
      btn.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.drag-handle').forEach(handle => {
      handle.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.box-content').forEach(content => {
      content.contentEditable = editMode;
      content.style.cursor = editMode ? 'text' : 'default';
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Boxes and connections

  function createBoxElement(boxData) {
    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = boxData.x + 'px';
    box.style.top = boxData.y + 'px';
    box.style.width = boxData.width + 'px';
    box.style.height = boxData.height + 'px';
    box.dataset.id = boxData.id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    // Drag handle
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Font size controls
    const fontMinus = document.createElement('button');
    fontMinus.className = 'font-size-btn';
    fontMinus.textContent = '-';
    const fontPlus = document.createElement('button');
    fontPlus.className = 'font-size-btn';
    fontPlus.textContent = '+';
    header.appendChild(fontMinus);
    header.appendChild(fontPlus);

    // Connect toggle
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect';
    header.appendChild(connectToggle);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.style.fontSize = boxData.fontSize + 'px';
    content.textContent = boxData.text || '';
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle ' + pos;
      box.appendChild(resizeHandle);
    });

    // Events

    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.stopPropagation();
      const startX = e.clientX;
      const startY = e.clientY;
      const startLeft = parseFloat(box.style.left);
      const startTop = parseFloat(box.style.top);

      // For multi-selection drag
      let selected = [box];
      if (selectedBoxes.has(box)) {
        selected = Array.from(selectedBoxes);
      } else {
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }

      function onMove(ev) {
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;
        selected.forEach(b => {
          const bStartLeft = parseFloat(b.style.left);
          const bStartTop = parseFloat(b.style.top);
          b.style.left = bStartLeft + dx + 'px';
          b.style.top = bStartTop + dy + 'px';
        });
        drawConnections();
      }
      function onUp() {
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      }
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
    });

    // Shift+click on header to select/deselect multiple boxes
    header.addEventListener('click', e => {
      if (!e.shiftKey) return;
      e.preventDefault();
      if (selectedBoxes.has(box)) {
        selectedBoxes.delete(box);
        box.classList.remove('selected');
      } else {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });

    fontMinus.addEventListener('click', e => {
      e.stopPropagation();
      const currentSize = parseInt(content.style.fontSize);
      if (currentSize > 6) {
        content.style.fontSize = (currentSize - 1) + 'px';
      }
    });
    fontPlus.addEventListener('click', e => {
      e.stopPropagation();
      const currentSize = parseInt(content.style.fontSize);
      if (currentSize < 40) {
        content.style.fontSize = (currentSize + 1) + 'px';
      }
    });

    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      undoStack.push(cloneCurrentBoxes());
      removeBox(box.dataset.id);
      drawConnections();
      updateUndoBtn();
    });

    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === box.dataset.id) {
        // Toggle off
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (!connectionStartBoxId) {
        // Start connection
        connectionStartBoxId = box.dataset.id;
        connectToggle.classList.add('active');
      } else {
        // Connect to this box
        connections.push([connectionStartBoxId, box.dataset.id]);
        connectionStartBoxId = null;
        document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
        drawConnections();
      }
    });

    // Resize
    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        const rect = box.getBoundingClientRect();
        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = rect.width;
        const startHeight = rect.height;
        const startLeft = parseFloat(box.style.left);
        const startTop = parseFloat(box.style.top);

        function onMove(ev) {
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          let newWidth = startWidth;
          let newHeight = startHeight;
          let newLeft = startLeft;
          let newTop = startTop;

          switch (handle.classList[1]) {
            case 'nw':
              newWidth = startWidth - dx;
              newHeight = startHeight - dy;
              newLeft = startLeft + dx;
              newTop = startTop + dy;
              break;
            case 'ne':
              newWidth = startWidth + dx;
              newHeight = startHeight - dy;
              newTop = startTop + dy;
              break;
            case 'sw':
              newWidth = startWidth - dx;
              newHeight = startHeight + dy;
              newLeft = startLeft + dx;
              break;
            case 'se':
              newWidth = startWidth + dx;
              newHeight = startHeight + dy;
              break;
          }
          if (newWidth >= 80) {
            box.style.width = newWidth + 'px';
            box.style.left = newLeft + 'px';
          }
          if (newHeight >= 40) {
            box.style.height = newHeight + 'px';
            box.style.top = newTop + 'px';
          }
          drawConnections();
        }
        function onUp() {
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
        }
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      });
    });

    content.addEventListener('input', e => {
      drawConnections();
    });

    return box;
  }

  function addBox(x, y) {
    const id = crypto.randomUUID();
    const boxData = {
      id,
      x,
      y,
      width: 120,
      height: 60,
      text: '',
      fontSize: 14
    };
    boxesMap.set(id, boxData);
    const box = createBoxElement(boxData);
    canvas.appendChild(box);
    drawConnections();
  }

  function removeBox(id) {
    boxesMap.delete(id);
    const el = canvas.querySelector(`.box[data-id="${id}"]`);
    if (el) {
      el.remove();
    }
    // Remove related connections
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i][0] === id || connections[i][1] === id) {
        connections.splice(i, 1);
      }
    }
  }

  function cloneCurrentBoxes() {
    const clone = [];
    boxesMap.forEach(box => {
      clone.push({ ...box });
    });
    return clone;
  }

  function updateUndoBtn() {
    undoBtn.disabled = undoStack.length === 0;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastState = undoStack.pop();
    boxesMap.clear();
    canvas.innerHTML = '';
    lastState.forEach(b => {
      boxesMap.set(b.id, b);
      canvas.appendChild(createBoxElement(b));
    });
    drawConnections();
    updateUndoBtn();
  });

  // Connections drawing
  function drawConnections() {
    while (connectionLayer.firstChild) {
      connectionLayer.firstChild.remove();
    }
    connections.forEach(pair => {
      const [fromId, toId] = pair;
      const fromBox = canvas.querySelector(`.box[data-id="${fromId}"]`);
      const toBox = canvas.querySelector(`.box[data-id="${toId}"]`);
      if (!fromBox || !toBox) return;
      const fromRect = fromBox.getBoundingClientRect();
      const toRect = toBox.getBoundingClientRect();
      const svgRect = connectionLayer.getBoundingClientRect();

      // Convert screen coords to canvas coords
      const fromX = (fromRect.left + fromRect.width / 2 - svgRect.left) / scale;
      const fromY = (fromRect.top + fromRect.height / 2 - svgRect.top) / scale;
      const toX = (toRect.left + toRect.width / 2 - svgRect.left) / scale;
      const toY = (toRect.top + toRect.height / 2 - svgRect.top) / scale;

      // Draw line
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", fromX);
      line.setAttribute("y1", fromY);
      line.setAttribute("x2", toX);
      line.setAttribute("y2", toY);
      line.setAttribute("stroke", "black");
      line.setAttribute("stroke-width", "2");
      connectionLayer.appendChild(line);
    });
  }

  // Save/load mindmaps Firebase

  async function saveMindmap() {
    if (!currentMindmapId) {
      alert('Select or create a mind map first.');
      return;
    }
    const mindmapRef = doc(db, 'mindmaps', currentMindmapId);
    const boxDataArr = [];
    canvas.querySelectorAll('.box').forEach(box => {
      const id = box.dataset.id;
      const x = parseFloat(box.style.left);
      const y = parseFloat(box.style.top);
      const width = parseFloat(box.style.width);
      const height = parseFloat(box.style.height);
      const text = box.querySelector('.box-content').textContent;
      const fontSize = parseInt(box.querySelector('.box-content').style.fontSize);
      boxDataArr.push({ id, x, y, width, height, text, fontSize });
    });
    try {
      await setDoc(mindmapRef, {
        boxes: boxDataArr,
        connections,
        center: await loadCenter() || { x: 0, y: 0 }
      });
      alert('Save successful');
    } catch (e) {
      alert('Save failed: ' + e.message);
    }
  }

  async function loadMindmap(id) {
    const mindmapRef = doc(db, 'mindmaps', id);
    const docSnap = await getDoc(mindmapRef);
    if (docSnap.exists()) {
      const data = docSnap.data();
      boxesMap.clear();
      canvas.innerHTML = '';
      connections.length = 0;
      if (data.boxes) {
        data.boxes.forEach(b => {
          boxesMap.set(b.id, b);
          canvas.appendChild(createBoxElement(b));
        });
      }
      if (data.connections) {
        data.connections.forEach(c => connections.push(c));
      }
      drawConnections();
      if (data.center) {
        panX = window.innerWidth / 2 - data.center.x * scale;
        panY = window.innerHeight / 2 - data.center.y * scale;
        updateTransform();
      }
      currentMindmapId = id;
      mindmapSelector.value = id;
    } else {
      alert('No such mind map found');
    }
  }

  // Load mindmaps list from Firebase
  async function loadMindmapsList() {
    mindmapSelector.innerHTML = '';
    mindmapsList = [];
    try {
      const querySnapshot = await getDocs(collection(db, 'mindmaps'));
      querySnapshot.forEach(doc => {
        mindmapsList.push({ id: doc.id });
      });
      mindmapsList.sort((a, b) => a.id.localeCompare(b.id));
      mindmapsList.forEach(m => {
        const option = document.createElement('option');
        option.value = m.id;
        option.textContent = m.id;
        mindmapSelector.appendChild(option);
      });
    } catch (e) {
      alert('Failed to load mind maps list: ' + e.message);
    }
  }

  mindmapSelector.addEventListener('change', () => {
    if (mindmapSelector.value) {
      loadMindmap(mindmapSelector.value);
    }
  });

  createMindmapBtn.addEventListener('click', async () => {
    const name = newMindmapNameInput.value.trim();
    if (!name) {
      alert('Enter a name for the new mind map');
      return;
    }
    if (mindmapsList.some(m => m.id === name)) {
      alert('A mind map with that name already exists');
      return;
    }
    currentMindmapId = name;
    mindmapSelector.value = name;
    boxesMap.clear();
    canvas.innerHTML = '';
    connections.length = 0;
    panX = window.innerWidth / 2;
    panY = window.innerHeight / 2;
    updateTransform();
    drawConnections();
    undoStack.length = 0;
    updateUndoBtn();
    newMindmapNameInput.value = '';
    await saveMindmap();
    await loadMindmapsList();
  });

  saveBtn.addEventListener('click', saveMindmap);
  loadBtn.addEventListener('click', () => {
    if (!currentMindmapId) {
      alert('Select or create a mind map first.');
      return;
    }
    loadMindmap(currentMindmapId);
  });

  // Center storage (localStorage for convenience)
  async function saveCenter(x, y) {
    localStorage.setItem('center', JSON.stringify({ x, y }));
  }
  async function loadCenter() {
    const c = localStorage.getItem('center');
    if (c) {
      try {
        return JSON.parse(c);
      } catch {
        return null;
      }
    }
    return null;
  }

  // Initialize
  loadMindmapsList().then(() => {
    if (mindmapsList.length > 0) {
      currentMindmapId = mindmapsList[0].id;
      mindmapSelector.value = currentMindmapId;
      loadMindmap(currentMindmapId);
    } else {
      currentMindmapId = null;
    }
  });

  // Initial transform update
  updateTransform();
  updateUndoBtn();

</script>
</body>
</html>
