<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV8</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(200,200,200,0.8);
      padding: 6px 12px;
      border-radius: 6px;
      display: flex;
      gap: 12px;
      z-index: 1500;
      font-family: monospace, monospace;
      user-select: none;
      align-items: center;
    }
    #topMenu select, #topMenu button {
      font-family: monospace, monospace;
      font-size: 14px;
      padding: 4px 8px;
      cursor: pointer;
    }
    #statusMessage {
      font-size: 12px;
      color: green;
      min-width: 120px;
      user-select: none;
    }
    #zoomDisplay {
      font-family: monospace, monospace;
      font-size: 14px;
      user-select: none;
      min-width: 50px;
      text-align: center;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1;"></svg>
    <div id="canvas"></div>
  </div>

  <div id="topMenu">
    <select id="mapSelect"></select>
    <button id="saveBtn">Save Map</button>
    <button id="deleteBtn">Delete Map</button>
    <button id="renameBtn">Rename Map</button>
    <span id="zoomDisplay">100%</span>
    <span id="statusMessage"></span>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed;top:20%;left:50%;transform:translateX(-50%);background:white;padding:12px;box-shadow:0 0 10px #999;max-width:400px;z-index:2000;user-select:none;">
    <h3>How to Use</h3>
    <ul>
      <li>Double-click anywhere on the canvas to create a new text box.</li>
      <li>Drag the box header to move boxes.</li>
      <li>Drag the corner handles to resize boxes.</li>
      <li>Click the blue circle on a box header to start/end connections.</li>
      <li>Use Undo Delete to restore last deleted box.</li>
      <li>Save Map to save to Firebase. Select map to load automatically.</li>
      <li>Mark Center sets the viewport's center point to your current view.</li>
      <li>Go to Center moves the view back to the marked center.</li>
      <li>Toggle Edit Mode enables/disables editing and dragging.</li>
      <li>Font size plus/minus buttons adjust text size inside boxes.</li>
    </ul>
    <button id="closeHowToBtn">Close</button>
  </div>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
<script>
  // Your Firebase config (replace with your actual config)
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // DOM elements
  const viewport = document.getElementById('viewport');
  const canvas = document.getElementById('canvas');
  const connectionLayer = document.getElementById('connectionLayer');
  const mapSelect = document.getElementById('mapSelect');
  const saveBtn = document.getElementById('saveBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const renameBtn = document.getElementById('renameBtn');
  const statusMessage = document.getElementById('statusMessage');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const zoomDisplay = document.getElementById('zoomDisplay');

  // State
  let boxes = {};
  let connections = [];
  let isEditMode = true;
  let selectedBoxes = new Set();
  let undoStack = [];
  let activeConnectionBoxId = null;

  let scale = 1;
  let panX = 0;
  let panY = 0;
  let isPanning = false;
  let panStart = {x:0,y:0};
  let panOrigin = {x:0,y:0};

  let centerPosition = {x:0,y:0};

  // Utility functions
  function generateId() {
    return 'id-'+Math.random().toString(36).substr(2,9);
  }

  // Rendering connections
  function drawConnections() {
    while (connectionLayer.firstChild) {
      connectionLayer.removeChild(connectionLayer.firstChild);
    }
    connections.forEach(conn => {
      const fromBox = boxes[conn.from];
      const toBox = boxes[conn.to];
      if (!fromBox || !toBox) return;
      const fromRect = fromBox.element.getBoundingClientRect();
      const toRect = toBox.element.getBoundingClientRect();
      // Convert viewport coords to canvas coords
      const fromX = (fromBox.x + fromBox.width / 2) * scale + panX + viewport.offsetLeft;
      const fromY = (fromBox.y + fromBox.height / 2) * scale + panY + viewport.offsetTop;
      const toX = (toBox.x + toBox.width / 2) * scale + panX + viewport.offsetLeft;
      const toY = (toBox.y + toBox.height / 2) * scale + panY + viewport.offsetTop;

      // Create SVG line
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', fromBox.x*scale + panX);
      line.setAttribute('y1', fromBox.y*scale + panY);
      line.setAttribute('x2', toBox.x*scale + panX);
      line.setAttribute('y2', toBox.y*scale + panY);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', 2);
      connectionLayer.appendChild(line);
    });
  }

  // Update transform of canvas
  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
    zoomDisplay.textContent = Math.round(scale*100) + '%';
  }

  // Create a new box object and element
  function createBox(x,y,text='',id=null,fontSize=14) {
    if (!id) id = generateId();
    const box = {
      id,
      x,
      y,
      width: 150,
      height: 60,
      text,
      fontSize,
      connections: [],
      element: null,
    };
    boxes[id] = box;

    const el = document.createElement('div');
    el.className = 'box';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.width = box.width + 'px';
    el.style.height = box.height + 'px';

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '☰';
    header.appendChild(dragHandle);

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    header.appendChild(connectToggle);

    const fontMinusBtn = document.createElement('button');
    fontMinusBtn.className = 'font-size-btn';
    fontMinusBtn.textContent = '−'; // minus sign
    header.appendChild(fontMinusBtn);

    const fontPlusBtn = document.createElement('button');
    fontPlusBtn.className = 'font-size-btn';
    fontPlusBtn.textContent = '+';
    header.appendChild(fontPlusBtn);

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    el.appendChild(header);

    // Content (editable)
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = isEditMode ? "true" : "false";
    content.spellcheck = false;
    content.style.fontSize = box.fontSize + 'px';
    content.textContent = text;
    el.appendChild(content);

    // Resize handles
    ['nw','ne','sw','se'].forEach(pos => {
      const rh = document.createElement('div');
      rh.className = 'resize-handle ' + pos;
      el.appendChild(rh);
    });

    box.element = el;

    // Events

    // Dragging the box by drag handle
    let dragging = false;
    let dragStart = {x:0,y:0};
    dragHandle.addEventListener('mousedown', (e) => {
      if (!isEditMode) return;
      dragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });
    window.addEventListener('mouseup', () => {
      dragging = false;
      document.body.style.userSelect = '';
    });
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = (e.clientX - dragStart.x) / scale;
      const dy = (e.clientY - dragStart.y) / scale;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      box.x += dx;
      box.y += dy;
      el.style.left = box.x + 'px';
      el.style.top = box.y + 'px';
      drawConnections();
    });

    // Resize handles
    let resizing = false;
    let resizeDir = null;
    let resizeStart = {x:0,y:0,w:0,h:0};
    el.querySelectorAll('.resize-handle').forEach(rh => {
      rh.addEventListener('mousedown', (e) => {
        if (!isEditMode) return;
        resizing = true;
        resizeDir = rh.classList[1];
        resizeStart.x = e.clientX;
        resizeStart.y = e.clientY;
        resizeStart.w = box.width;
        resizeStart.h = box.height;
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });
    });
    window.addEventListener('mouseup', () => {
      resizing = false;
      resizeDir = null;
      document.body.style.userSelect = '';
    });
    window.addEventListener('mousemove', (e) => {
      if (!resizing) return;
      const dx = (e.clientX - resizeStart.x) / scale;
      const dy = (e.clientY - resizeStart.y) / scale;
      let newW = resizeStart.w;
      let newH = resizeStart.h;
      if (resizeDir.includes('e')) newW = Math.max(80, resizeStart.w + dx);
      if (resizeDir.includes('w')) {
        newW = Math.max(80, resizeStart.w - dx);
        if (newW > 80) {
          box.x += dx;
          el.style.left = box.x + 'px';
        }
      }
      if (resizeDir.includes('s')) newH = Math.max(40, resizeStart.h + dy);
      if (resizeDir.includes('n')) {
        newH = Math.max(40, resizeStart.h - dy);
        if (newH > 40) {
          box.y += dy;
          el.style.top = box.y + 'px';
        }
      }
      box.width = newW;
      box.height = newH;
      el.style.width = newW + 'px';
      el.style.height = newH + 'px';
      drawConnections();
    });

    // Delete button
    deleteBtn.addEventListener('click', () => {
      if (!isEditMode) return;
      deleteBox(box.id);
    });

    // Connect toggle
    connectToggle.addEventListener('click', () => {
      if (!isEditMode) return;
      if (activeConnectionBoxId === null) {
        activeConnectionBoxId = box.id;
        connectToggle.classList.add('active');
      } else if (activeConnectionBoxId === box.id) {
        activeConnectionBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        // Add connection
        connections.push({from: activeConnectionBoxId, to: box.id});
        // Remove active from old box toggle
        const oldBox = boxes[activeConnectionBoxId];
        if (oldBox) {
          oldBox.element.querySelector('.connect-toggle').classList.remove('active');
        }
        activeConnectionBoxId = null;
        drawConnections();
      }
    });

    // Font size buttons
    fontMinusBtn.addEventListener('click', () => {
      if (!isEditMode) return;
      box.fontSize = Math.max(6, box.fontSize - 1);
      content.style.fontSize = box.fontSize + 'px';
    });
    fontPlusBtn.addEventListener('click', () => {
      if (!isEditMode) return;
      box.fontSize = Math.min(72, box.fontSize + 1);
      content.style.fontSize = box.fontSize + 'px';
    });

    // Content editable changes
    content.addEventListener('input', () => {
      box.text = content.textContent;
    });

    canvas.appendChild(el);

    return box;
  }

  // Delete box and store undo info
  function deleteBox(id) {
    const box = boxes[id];
    if (!box) return;
    undoStack.push({
      action: 'delete',
      box: JSON.parse(JSON.stringify(box)),
      connections: connections.filter(c => c.from === id || c.to === id)
    });
    undoBtn.disabled = false;

    // Remove connections related
    connections = connections.filter(c => c.from !== id && c.to !== id);

    // Remove element
    box.element.remove();
    delete boxes[id];
    drawConnections();
  }

  // Undo last delete
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    if (last.action === 'delete') {
      const b = last.box;
      const newBox = createBox(b.x, b.y, b.text, b.id, b.fontSize);
      newBox.width = b.width;
      newBox.height = b.height;
      newBox.element.style.width = b.width + 'px';
      newBox.element.style.height = b.height + 'px';
      connections = connections.concat(last.connections);
      drawConnections();
    }
    if (undoStack.length === 0) undoBtn.disabled = true;
  });

  // Save/load maps in Firebase
  let currentMapId = null;
  let mapsList = [];

  function saveCurrentMap() {
    if (!currentMapId) {
      alert('Please select or create a map first.');
      return;
    }
    const mapData = {
      boxes: Object.values(boxes).map(b => ({
        id: b.id,
        x: b.x,
        y: b.y,
        width: b.width,
        height: b.height,
        text: b.text,
        fontSize: b.fontSize
      })),
      connections,
      centerPosition,
      timestamp: Date.now(),
    };
    db.collection('mindmaps').doc(currentMapId).set(mapData).then(() => {
      statusMessage.textContent = 'Save successful';
      setTimeout(() => { statusMessage.textContent = ''; }, 3000);
      loadMapsList();
    }).catch(err => {
      alert('Save failed: ' + err.message);
    });
  }

  function loadMap(id) {
    if (!id) return;
    db.collection('mindmaps').doc(id).get().then(doc => {
      if (!doc.exists) {
        alert('Map not found!');
        return;
      }
      clearCanvas();
      const data = doc.data();
      data.boxes.forEach(b => {
        const box = createBox(b.x, b.y, b.text, b.id, b.fontSize);
        box.width = b.width;
        box.height = b.height;
        box.element.style.width = b.width + 'px';
        box.element.style.height = b.height + 'px';
      });
      connections = data.connections || [];
      centerPosition = data.centerPosition || {x:0,y:0};
      updateTransform();
      drawConnections();
      currentMapId = id;
      mapSelect.value = currentMapId;
      statusMessage.textContent = 'Map loaded';
      setTimeout(() => { statusMessage.textContent = ''; }, 3000);
    }).catch(err => {
      alert('Load failed: ' + err.message);
    });
  }

  function clearCanvas() {
    Object.values(boxes).forEach(b => b.element.remove());
    boxes = {};
    connections = [];
    undoStack = [];
    undoBtn.disabled = true;
  }

  function loadMapsList() {
    db.collection('mindmaps').orderBy('timestamp', 'desc').get().then(snapshot => {
      mapsList = [];
      mapSelect.innerHTML = '';
      snapshot.forEach(doc => {
        mapsList.push({id: doc.id, data: doc.data()});
        const opt = document.createElement('option');
        opt.value = doc.id;
        opt.textContent = doc.id;
        mapSelect.appendChild(opt);
      });
      if (!currentMapId && mapsList.length > 0) {
        currentMapId = mapsList[0].id;
        loadMap(currentMapId);
      }
      // Keep current selected map if exists
      else if (currentMapId) {
        mapSelect.value = currentMapId;
      }
    });
  }

  // Create new map
  function createNewMap() {
    const newId = prompt('Enter new map ID (unique):');
    if (!newId) return;
    // Check if exists
    if (mapsList.find(m => m.id === newId)) {
      alert('Map ID already exists!');
      return;
    }
    currentMapId = newId;
    clearCanvas();
    loadMapsList();
    statusMessage.textContent = 'New map created: ' + newId;
    setTimeout(() => { statusMessage.textContent = ''; }, 3000);
  }

  // Delete current map
  deleteBtn.addEventListener('click', () => {
    if (!currentMapId) return;
    if (!confirm('Delete map "' + currentMapId + '"? This cannot be undone.')) return;
    db.collection('mindmaps').doc(currentMapId).delete().then(() => {
      statusMessage.textContent = 'Map deleted';
      currentMapId = null;
      clearCanvas();
      loadMapsList();
      setTimeout(() => { statusMessage.textContent = ''; }, 3000);
    }).catch(err => {
      alert('Delete failed: ' + err.message);
    });
  });

  // Rename current map
  renameBtn.addEventListener('click', () => {
    if (!currentMapId) return;
    const newName = prompt('Enter new name for map:', currentMapId);
    if (!newName || newName === currentMapId) return;
    if (mapsList.find(m => m.id === newName)) {
      alert('Map ID already exists!');
      return;
    }
    // Copy data to new doc, delete old
    db.collection('mindmaps').doc(currentMapId).get().then(doc => {
      if (!doc.exists) throw new Error('Map not found');
      const data = doc.data();
      return db.collection('mindmaps').doc(newName).set(data).then(() => {
        return db.collection('mindmaps').doc(currentMapId).delete();
      });
    }).then(() => {
      statusMessage.textContent = 'Map renamed to ' + newName;
      currentMapId = newName;
      loadMapsList();
      setTimeout(() => { statusMessage.textContent = ''; }, 3000);
    }).catch(err => {
      alert('Rename failed: ' + err.message);
    });
  });

  // Map select change loads selected map
  mapSelect.addEventListener('change', () => {
    if (!mapSelect.value) return;
    loadMap(mapSelect.value);
  });

  // Save button
  saveBtn.addEventListener('click', () => {
    saveCurrentMap();
  });

  // Undo button handled above

  // Go to Center button - ONLY pans, no zoom change
  goCenterBtn.addEventListener('click', () => {
    panX = viewport.clientWidth / 2 - centerPosition.x * scale;
    panY = viewport.clientHeight / 2 - centerPosition.y * scale;
    updateTransform();
    drawConnections();
  });

  // Mark Center button
  markCenterBtn.addEventListener('click', () => {
    // The center in canvas coords = (-panX / scale, -panY / scale)
    centerPosition.x = (-panX + viewport.clientWidth / 2) / scale;
    centerPosition.y = (-panY + viewport.clientHeight / 2) / scale;
    statusMessage.textContent = 'Center marked';
    setTimeout(() => { statusMessage.textContent = ''; }, 3000);
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    isEditMode = !isEditMode;
    toggleEditModeBtn.textContent = isEditMode ? 'Toggle View Mode' : 'Toggle Edit Mode';
    Object.values(boxes).forEach(b => {
      b.element.querySelector('.box-content').contentEditable = isEditMode ? "true" : "false";
      // Show or hide headers in view mode
      b.element.querySelector('.box-header').style.display = isEditMode ? 'flex' : 'none';
      // Enable/disable drag handle cursor
      b.element.querySelector('.drag-handle').style.cursor = isEditMode ? 'move' : 'default';
    });
  });

  // How to use modal
  howToBtn.addEventListener('click', () => {
    document.getElementById('howToModal').style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    document.getElementById('howToModal').style.display = 'none';
  });

  // Panning on viewport drag
  viewport.addEventListener('mousedown', (e) => {
    if (e.target !== viewport) return;
    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
    panOrigin.x = panX;
    panOrigin.y = panY;
    viewport.style.cursor = 'grabbing';
  });
  window.addEventListener('mouseup', () => {
    isPanning = false;
    viewport.style.cursor = 'grab';
  });
  window.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    panX = panOrigin.x + dx;
    panY = panOrigin.y + dy;
    updateTransform();
  });

  // Zoom with mouse wheel (ctrl+wheel)
  viewport.addEventListener('wheel', (e) => {
    if (!e.ctrlKey) return;
    e.preventDefault();
    const oldScale = scale;
    if (e.deltaY < 0) {
      scale = Math.min(4, scale * 1.1);
    } else {
      scale = Math.max(0.25, scale / 1.1);
    }
    // Zoom on mouse pointer location
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - ((mx - panX) * (scale / oldScale));
    panY = my - ((my - panY) * (scale / oldScale));
    updateTransform();
  }, {passive: false});

  // Double click to create new box
  viewport.addEventListener('dblclick', (e) => {
    if (!isEditMode) return;
    // Position relative to canvas coords
    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    createBox(x, y, '');
    drawConnections();
  });

  // Init
  loadMapsList();
  updateTransform();
</script>

</body>
</html>
