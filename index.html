<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
    background: #f0f0f0;
    user-select: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
  }
  #canvas {
    position: absolute; top: 0; left: 0; transform-origin: 0 0;
    z-index: 10;
  }
  #connectionLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 5;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    min-width: 80px;
    min-height: 40px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    cursor: text;
    overflow: hidden;
  }
  .box.selected {
    border-color: blue;
    box-shadow: 0 0 4px 2px rgba(0,0,255,0.4);
  }
  .box-header {
    background: #ddd;
    padding: 1px 4px;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 4px;
    user-select: none;
    cursor: default;
    border-bottom: 1px solid #bbb;
    font-size: 12px;
    height: 18px;
    box-sizing: border-box;
    flex-shrink: 0;
  }
  .delete-btn {
    color: red;
    font-weight: bold;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    user-select: none;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .connect-toggle {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: none;
    background-color: blue;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.25s ease;
    padding: 0;
    margin: 0;
    flex-shrink: 0;
  }
  .connect-toggle.active {
    background-color: green;
  }
  .box-content {
    flex: 1;
    padding: 6px 8px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    overflow: auto;
    outline: none;
    cursor: text;
    user-select: text;
    font-size: 16px;
    line-height: 1.2;
    min-height: 24px;
    word-break: break-word;
    box-sizing: border-box;
    resize: none;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }
  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }
  #zoomDisplay {
    position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.5); color: white; font-family: monospace;
    padding: 4px 8px; border-radius: 4px;
    user-select: none; pointer-events: none; z-index: 1001;
  }
  #selectionRect {
    position: absolute;
    border: 1px dashed blue;
    background: rgba(0,0,255,0.15);
    pointer-events: none;
    display: none;
    z-index: 50;
  }
</style>
</head>
<body>
  <div id="viewport" tabindex="0">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
    <div id="selectionRect"></div>
  </div>
  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="selectModeBtn" class="floatingBtn">Select Mode: OFF</button>
    <button id="deleteSelectedBtn" class="floatingBtn" disabled>Delete Selected</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
  </div>
  <div id="zoomDisplay">Zoom: 100%</div>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<script>
(() => {
  // Firebase init
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.firebasestorage.app",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // Elements
  const viewport = document.getElementById('viewport');
  const canvas = document.getElementById('canvas');
  const connectionLayer = document.getElementById('connectionLayer');
  const selectionRect = document.getElementById('selectionRect');
  const undoBtn = document.getElementById('undoBtn');
  const selectModeBtn = document.getElementById('selectModeBtn');
  const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const zoomDisplay = document.getElementById('zoomDisplay');

  // State
  let scale = 1, panX = 0, panY = 0;
  const MIN_SCALE = 0.5, MAX_SCALE = 3;
  let isPanning = false, panStartX, panStartY;
  let undoStack = [];
  let connections = [];
  let selectedBoxes = new Set();
  let selectedConnections = new Set();
  let selectMode = false;

  let draggingBox = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  let resizingBox = null;
  let resizeDir = null;
  let resizeStart = null;

  let connectingBox = null;

  let selectionStart = null;
  let isSelecting = false;

  let centerMark = { x: 0, y: 0 };

  // Helpers
  function generateId() {
    return 'id_' + Math.random().toString(36).substr(2, 9);
  }
  function screenToCanvas(x, y) {
    return { x: (x - panX) / scale, y: (y - panY) / scale };
  }
  function canvasToScreen(x, y) {
    return { x: x * scale + panX, y: y * scale + panY };
  }

  // Persist boxes
  const boxesCollection = db.collection('boxes');
  const connectionsCollection = db.collection('connections');

  async function saveBox(box) {
    const contentDiv = box.querySelector('.box-content');
    const data = {
      x: parseFloat(box.style.left),
      y: parseFloat(box.style.top),
      text: contentDiv.textContent,
      width: box.offsetWidth,
      height: box.offsetHeight,
      fontSize: contentDiv.style.fontSize || '16px'
    };
    if (!box.dataset.id) {
      const docRef = await boxesCollection.add(data);
      box.dataset.id = docRef.id;
    } else {
      await boxesCollection.doc(box.dataset.id).set(data);
    }
  }

  async function deleteBox(box) {
    if (!box.dataset.id) return;
    undoStack.push({
      box: {
        id: box.dataset.id,
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        text: box.querySelector('.box-content').textContent,
        width: box.offsetWidth,
        height: box.offsetHeight,
        fontSize: box.querySelector('.box-content').style.fontSize
      },
      connections: connections.filter(c => c.fromId === box.dataset.id || c.toId === box.dataset.id)
    });
    undoBtn.disabled = false;

    // Remove related connections
    connections = connections.filter(c => c.fromId !== box.dataset.id && c.toId !== box.dataset.id);
    await saveConnections();

    await boxesCollection.doc(box.dataset.id).delete();
    box.remove();
    drawConnections();
  }

  async function addBox(x, y, text = 'Text box', id = null, width = 180, height = 80, fontSize = '16px') {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';

    if (id) box.dataset.id = id;

    const header = document.createElement('div');
    header.className = 'box-header';

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect';

    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.textContent = 'Ã—';

    header.appendChild(connectToggle);
    header.appendChild(delBtn);

    const content = document.createElement('div');
    content.contentEditable = true;
    content.className = 'box-content';
    content.textContent = text;
    content.style.fontSize = fontSize;

    box.appendChild(header);
    box.appendChild(content);

    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    // Event handlers
    delBtn.addEventListener('click', async e => {
      e.stopPropagation();
      if (selectMode) return;
      await deleteBox(box);
      updateDeleteButton();
    });

    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (selectMode) return;
      if (connectToggle.classList.contains('active')) {
        connectToggle.classList.remove('active');
        connectingBox = null;
      } else {
        // Deactivate any other toggles
        document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
        connectToggle.classList.add('active');
        connectingBox = box;
      }
    });

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        e.stopPropagation();
        resizingBox = box;
        resizeDir = handle.classList.contains('nw') ? 'nw' :
                    handle.classList.contains('ne') ? 'ne' :
                    handle.classList.contains('sw') ? 'sw' : 'se';
        resizeStart = {
          x: e.clientX,
          y: e.clientY,
          left: parseFloat(box.style.left),
          top: parseFloat(box.style.top),
          width: box.offsetWidth,
          height: box.offsetHeight
        };
        document.body.style.cursor = handle.style.cursor;
        window.addEventListener('pointermove', resizePointerMove);
        window.addEventListener('pointerup', resizePointerUp);
      });
    });

    content.addEventListener('input', e => {
      smoothAdjustFontSize(content, box);
      saveBox(box);
    });

    content.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.execCommand('insertHTML', false, '\n');
      }
    });

    box.addEventListener('pointerdown', e => {
      if (selectMode) {
        e.stopPropagation();
        if (e.shiftKey) {
          if (selectedBoxes.has(box)) {
            selectedBoxes.delete(box);
            box.classList.remove('selected');
          } else {
            selectedBoxes.add(box);
            box.classList.add('selected');
          }
        } else {
          clearSelection();
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
        updateDeleteButton();
        return;
      }
      if (e.target.closest('.resize-handle') || e.target === delBtn || e.target === connectToggle) return;

      draggingBox = box;
      const rect = box.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      box.style.cursor = 'grabbing';
      box.setPointerCapture(e.pointerId);
      e.preventDefault();
    });

    box.addEventListener('pointermove', e => {
      if (draggingBox !== box) return;
      e.preventDefault();
      const newX = (e.clientX - dragOffsetX - panX) / scale;
      const newY = (e.clientY - dragOffsetY - panY) / scale;
      box.style.left = newX + 'px';
      box.style.top = newY + 'px';
      drawConnections();
    });

    box.addEventListener('pointerup', async e => {
      if (draggingBox !== box) return;
      draggingBox = null;
      box.style.cursor = 'text';
      await saveBox(box);
    });

    box.addEventListener('click', e => {
      if (!selectMode && connectingBox && connectingBox !== box) {
        const fromId = connectingBox.dataset.id;
        const toId = box.dataset.id;
        if (fromId && toId && !connections.some(c => (c.fromId === fromId && c.toId === toId) || (c.fromId === toId && c.toId === fromId))) {
          const newConn = { id: generateId(), fromId, toId };
          connections.push(newConn);
          saveConnections();
          drawConnections();
        }
        // Deactivate connect toggle
        connectingBox.querySelector('.connect-toggle').classList.remove('active');
        connectingBox = null;
      }
    });

    canvas.appendChild(box);
    smoothAdjustFontSize(content, box);

    // Save box if new
    if (!id) saveBox(box);
    return box;
  }

  function clearSelection() {
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
    selectedConnections.clear();
    updateDeleteButton();
    drawConnections();
  }

  function updateDeleteButton() {
    deleteSelectedBtn.disabled = selectedBoxes.size === 0 && selectedConnections.size === 0;
  }

  // Resize handlers
  function resizePointerMove(e) {
    if (!resizingBox) return;
    e.preventDefault();
    const dx = (e.clientX - resizeStart.x) / scale;
    const dy = (e.clientY - resizeStart.y) / scale;
    let newLeft = resizeStart.left;
    let newTop = resizeStart.top;
    let newWidth = resizeStart.width;
    let newHeight = resizeStart.height;

    if (resizeDir.includes('n')) {
      newTop = resizeStart.top + dy;
      newHeight = resizeStart.height - dy;
    }
    if (resizeDir.includes('w')) {
      newLeft = resizeStart.left + dx;
      newWidth = resizeStart.width - dx;
    }
    if (resizeDir.includes('s')) {
      newHeight = resizeStart.height + dy;
    }
    if (resizeDir.includes('e')) {
      newWidth = resizeStart.width + dx;
    }
    // enforce minimum size
    newWidth = Math.max(newWidth, 80);
    newHeight = Math.max(newHeight, 40);

    resizingBox.style.left = newLeft + 'px';
    resizingBox.style.top = newTop + 'px';
    resizingBox.style.width = newWidth + 'px';
    resizingBox.style.height = newHeight + 'px';

    const content = resizingBox.querySelector('.box-content');
    smoothAdjustFontSize(content, resizingBox);
    drawConnections();
  }
  async function resizePointerUp(e) {
    if (!resizingBox) return;
    document.body.style.cursor = '';
    await saveBox(resizingBox);
    resizingBox = null;
    resizeDir = null;
    resizeStart = null;
    window.removeEventListener('pointermove', resizePointerMove);
    window.removeEventListener('pointerup', resizePointerUp);
  }

  // Auto font size adjust for box content
  function smoothAdjustFontSize(content, box) {
    let fontSize = 16;
    content.style.fontSize = fontSize + 'px';

    const maxWidth = box.clientWidth - 16;
    const maxHeight = box.clientHeight - 36; // header + padding

    let fits = false;
    while (!fits && fontSize > 8) {
      content.style.fontSize = fontSize + 'px';
      if (content.scrollHeight <= maxHeight && content.scrollWidth <= maxWidth) {
        fits = true;
      } else {
        fontSize--;
      }
    }
  }

  // Connections
  function drawConnections() {
    // Clear
    while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);

    connections.forEach(conn => {
      const fromBox = document.querySelector(`.box[data-id="${conn.fromId}"]`);
      const toBox = document.querySelector(`.box[data-id="${conn.toId}"]`);
      if (!fromBox || !toBox) return;

      // Calculate from/to points (center bottom to center top with curve)
      const fromRect = fromBox.getBoundingClientRect();
      const toRect = toBox.getBoundingClientRect();

      const vpRect = viewport.getBoundingClientRect();

      // Canvas relative positions (convert viewport absolute to canvas relative)
      const fromX = (parseFloat(fromBox.style.left) + fromBox.offsetWidth / 2) * scale + panX;
      const fromY = (parseFloat(fromBox.style.top) + fromBox.offsetHeight) * scale + panY;

      const toX = (parseFloat(toBox.style.left) + toBox.offsetWidth / 2) * scale + panX;
      const toY = (parseFloat(toBox.style.top)) * scale + panY;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

      // Bezier curve control points for nice curve
      const controlOffset = Math.abs(toY - fromY) / 2;
      const d = `M${fromX},${fromY} C${fromX},${fromY + controlOffset} ${toX},${toY - controlOffset} ${toX},${toY}`;
      path.setAttribute('d', d);
      path.setAttribute('stroke', selectedConnections.has(conn.id) ? 'blue' : 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      path.style.pointerEvents = 'stroke';

      path.addEventListener('click', e => {
        if (!selectMode) return;
        e.stopPropagation();
        if (selectedConnections.has(conn.id)) {
          selectedConnections.delete(conn.id);
          path.setAttribute('stroke', 'black');
        } else {
          selectedConnections.add(conn.id);
          path.setAttribute('stroke', 'blue');
        }
        updateDeleteButton();
      });

      connectionLayer.appendChild(path);
    });
  }

  async function saveConnections() {
    // Clear all and re-add
    const batch = db.batch();
    // Remove all old connections in firestore (inefficient, but simple)
    const allConns = await connectionsCollection.get();
    allConns.forEach(doc => batch.delete(doc.ref));

    // Add current connections
    connections.forEach(conn => {
      const ref = connectionsCollection.doc(conn.id);
      batch.set(ref, { fromId: conn.fromId, toId: conn.toId });
    });

    await batch.commit();
  }

  async function deleteSelected() {
    // Delete selected boxes and related connections
    for (const box of selectedBoxes) {
      await deleteBox(box);
    }
    // Delete selected connections
    if (selectedConnections.size > 0) {
      undoStack.push({
        connections: connections.filter(c => selectedConnections.has(c.id))
      });
      undoBtn.disabled = false;

      connections = connections.filter(c => !selectedConnections.has(c.id));
      await saveConnections();
      drawConnections();
      selectedConnections.clear();
    }
    clearSelection();
    updateDeleteButton();
  }

  async function undoDelete() {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    undoBtn.disabled = undoStack.length === 0;

    if (last.box) {
      // Restore box and its connections
      const b = last.box;
      const box = await addBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize);
      // Also restore connections for this box
      last.connections.forEach(c => {
        connections.push(c);
      });
      await saveConnections();
      drawConnections();
    } else if (last.connections) {
      // Restore connections only
      last.connections.forEach(c => connections.push(c));
      await saveConnections();
      drawConnections();
    }
  }

  // Canvas zoom & pan
  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    connectionLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    zoomDisplay.textContent = `Zoom: ${(scale * 100).toFixed(0)}%`;
  }

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const prevScale = scale;
    if (e.deltaY < 0) scale *= 1.1;
    else scale /= 1.1;
    scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale));

    // Zoom towards mouse pointer
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX -= (mx - panX) * (scale / prevScale - 1);
    panY -= (my - panY) * (scale / prevScale - 1);

    updateTransform();
  }, { passive: false });

  // Pan with right mouse or middle mouse drag
  viewport.addEventListener('pointerdown', e => {
    if (e.button === 1 || e.button === 2) {
      isPanning = true;
      panStartX = e.clientX - panX;
      panStartY = e.clientY - panY;
      viewport.style.cursor = 'grabbing';
      e.preventDefault();
    } else if (selectMode && e.button === 0) {
      // Start selection rectangle
      selectionStart = { x: e.clientX, y: e.clientY };
      selectionRect.style.left = e.clientX + 'px';
      selectionRect.style.top = e.clientY + 'px';
      selectionRect.style.width = '0px';
      selectionRect.style.height = '0px';
      selectionRect.style.display = 'block';
      isSelecting = true;
      clearSelection();
    }
  });
  viewport.addEventListener('pointermove', e => {
    if (isPanning) {
      panX = e.clientX - panStartX;
      panY = e.clientY - panStartY;
      updateTransform();
    } else if (isSelecting) {
      const x1 = Math.min(selectionStart.x, e.clientX);
      const y1 = Math.min(selectionStart.y, e.clientY);
      const x2 = Math.max(selectionStart.x, e.clientX);
      const y2 = Math.max(selectionStart.y, e.clientY);
      selectionRect.style.left = x1 + 'px';
      selectionRect.style.top = y1 + 'px';
      selectionRect.style.width = (x2 - x1) + 'px';
      selectionRect.style.height = (y2 - y1) + 'px';

      // Select boxes inside rectangle
      const rectLeft = (x1 - panX) / scale;
      const rectTop = (y1 - panY) / scale;
      const rectRight = (x2 - panX) / scale;
      const rectBottom = (y2 - panY) / scale;

      clearSelection();
      document.querySelectorAll('.box').forEach(box => {
        const left = parseFloat(box.style.left);
        const top = parseFloat(box.style.top);
        const right = left + box.offsetWidth;
        const bottom = top + box.offsetHeight;
        if (right >= rectLeft && left <= rectRight && bottom >= rectTop && top <= rectBottom) {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      });
      updateDeleteButton();
      drawConnections();
    }
  });
  viewport.addEventListener('pointerup', e => {
    if (isPanning) {
      isPanning = false;
      viewport.style.cursor = 'grab';
    }
    if (isSelecting) {
      isSelecting = false;
      selectionRect.style.display = 'none';
    }
  });
  viewport.addEventListener('contextmenu', e => {
    e.preventDefault(); // disable context menu to keep right drag panning smooth
  });

  // Double-click on canvas to create box
  viewport.addEventListener('dblclick', e => {
    if (e.target !== viewport && e.target !== canvas) return;
    if (selectMode) return;
    const pos = screenToCanvas(e.clientX, e.clientY);
    addBox(pos.x - 90, pos.y - 40);
  });

  // Button handlers
  undoBtn.addEventListener('click', undoDelete);
  selectModeBtn.addEventListener('click', () => {
    selectMode = !selectMode;
    selectModeBtn.textContent = `Select Mode: ${selectMode ? 'ON' : 'OFF'}`;
    if (!selectMode) clearSelection();
  });
  deleteSelectedBtn.addEventListener('click', deleteSelected);
  goCenterBtn.addEventListener('click', () => {
    panX = viewport.clientWidth / 2 - centerMark.x * scale;
    panY = viewport.clientHeight / 2 - centerMark.y * scale;
    updateTransform();
  });
  markCenterBtn.addEventListener('click', () => {
    centerMark.x = (viewport.clientWidth / 2 - panX) / scale;
    centerMark.y = (viewport.clientHeight / 2 - panY) / scale;
  });

  // Load from Firestore
  async function loadBoxesAndConnections() {
    // Clear UI
    canvas.innerHTML = '';
    connections = [];

    const boxDocs = await boxesCollection.get();
    for (const doc of boxDocs.docs) {
      const d = doc.data();
      await addBox(d.x, d.y, d.text, doc.id, d.width || 180, d.height || 80, d.fontSize || '16px');
    }

    const connDocs = await connectionsCollection.get();
    connDocs.forEach(doc => {
      const c = doc.data();
      connections.push({ id: doc.id, fromId: c.fromId, toId: c.toId });
    });

    drawConnections();
  }

  // Keyboard shortcuts
  window.addEventListener('keydown', e => {
    if (e.target.isContentEditable || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedBoxes.size > 0 || selectedConnections.size > 0) {
        e.preventDefault();
        deleteSelected();
      }
    }
    if (e.ctrlKey && e.key === 'z') {
      e.preventDefault();
      undoDelete();
    }
  });

  // Init
  viewport.style.cursor = 'grab';
  updateTransform();
  loadBoxesAndConnections();

})();
</script>
</body>
</html>
