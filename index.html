<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV4fullwithFirebase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  // Double-click to add box

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn,
         saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  // Boxes, connections, drawing

  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(({ fromId, toId }) => {
      const boxA = boxesMap.get(fromId);
      const boxB = boxesMap.get(toId);
      if (!boxA || !boxB) return;
      const ax = parseFloat(boxA.style.left) + boxA.offsetWidth / 2;
      const ay = parseFloat(boxA.style.top) + boxA.offsetHeight / 2;
      const bx = parseFloat(boxB.style.left) + boxB.offsetWidth / 2;
      const by = parseFloat(boxB.style.top) + boxB.offsetHeight / 2;
      const startX = ax * scale + panX;
      const startY = ay * scale + panY;
      const endX = bx * scale + panX;
      const endY = by * scale + panY;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", startX);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", endX);
      line.setAttribute("y2", endY);
      line.setAttribute("stroke", "black");
      line.setAttribute("stroke-width", "2");
      connectionLayer.appendChild(line);
    });
  }

  function createBoxElement(id, x, y, text = "", fontSize = 14) {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.fontSize = fontSize + 'px';
    box.setAttribute('data-id', id);

    // Header with drag handle and delete & connect toggle
    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    dragHandle.title = "Drag box (Shift+click for multi-select)";
    header.appendChild(dragHandle);

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = "Connect to another box";
    header.appendChild(connectToggle);

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = "Delete box";
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content editable area
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.textContent = text;
    content.style.fontSize = fontSize + 'px';
    box.appendChild(content);

    // Resize handles
    ['nw','ne','sw','se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = `resize-handle ${pos}`;
      box.appendChild(handle);
    });

    // Events

    // Dragging box
    let dragStartX, dragStartY, boxStartX, boxStartY;
    let multiDrag = false;

    function onPointerDown(e) {
      if (e.button !== 0) return;
      if (!editMode) return;
      if (e.target === connectToggle || e.target === deleteBtn || e.target.classList.contains('resize-handle')) return;

      if (!e.shiftKey) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        box.classList.add('selected');
        selectedBoxes.add(box);
      } else {
        if (selectedBoxes.has(box)) {
          box.classList.remove('selected');
          selectedBoxes.delete(box);
        } else {
          box.classList.add('selected');
          selectedBoxes.add(box);
        }
      }

      if (e.target === dragHandle) {
        multiDrag = selectedBoxes.size > 1 && selectedBoxes.has(box);
      } else {
        multiDrag = false;
      }

      dragStartX = e.clientX;
      dragStartY = e.clientY;
      boxStartX = parseFloat(box.style.left);
      boxStartY = parseFloat(box.style.top);

      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      e.preventDefault();
    }

    function onPointerMove(e) {
      const dx = (e.clientX - dragStartX) / scale;
      const dy = (e.clientY - dragStartY) / scale;
      if (multiDrag) {
        selectedBoxes.forEach(b => {
          const startX = parseFloat(b.style.left);
          const startY = parseFloat(b.style.top);
          b.style.left = (startX + dx) + 'px';
          b.style.top = (startY + dy) + 'px';
        });
      } else {
        box.style.left = (boxStartX + dx) + 'px';
        box.style.top = (boxStartY + dy) + 'px';
      }
      drawConnections();
    }

    function onPointerUp(e) {
      window.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
      if (multiDrag) {
        // update positions of all selected boxes after drag
        selectedBoxes.forEach(b => {
          b.style.left = parseFloat(b.style.left) + 'px';
          b.style.top = parseFloat(b.style.top) + 'px';
        });
      }
      multiDrag = false;
    }

    dragHandle.addEventListener('pointerdown', onPointerDown);
    box.addEventListener('pointerdown', onPointerDown);

    // Delete box
    deleteBtn.addEventListener('click', () => {
      undoStack.push({ type: 'deleteBox', boxId: id, data: serializeBox(box) });
      removeBox(id);
      updateUndoButton();
    });

    // Connect toggle
    connectToggle.addEventListener('click', () => {
      if (!editMode) return;
      if (connectionStartBoxId === null) {
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        connections.push({ fromId: connectionStartBoxId, toId: id });
        connectionStartBoxId = null;
        document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
        drawConnections();
      }
    });

    // Font size adjust buttons inside header (replace A+ and A- with + and -)
    const fontSizeDecBtn = document.createElement('button');
    fontSizeDecBtn.className = 'font-size-btn';
    fontSizeDecBtn.textContent = '−'; // minus sign
    fontSizeDecBtn.title = "Decrease font size";
    const fontSizeIncBtn = document.createElement('button');
    fontSizeIncBtn.className = 'font-size-btn';
    fontSizeIncBtn.textContent = '+'; // plus sign
    fontSizeIncBtn.title = "Increase font size";

    header.insertBefore(fontSizeDecBtn, connectToggle);
    header.insertBefore(fontSizeIncBtn, connectToggle);

    fontSizeDecBtn.addEventListener('click', () => {
      let fs = parseInt(box.style.fontSize) || 14;
      fs = Math.max(6, fs - 1);
      box.style.fontSize = fs + 'px';
      content.style.fontSize = fs + 'px';
    });
    fontSizeIncBtn.addEventListener('click', () => {
      let fs = parseInt(box.style.fontSize) || 14;
      fs = Math.min(48, fs + 1);
      box.style.fontSize = fs + 'px';
      content.style.fontSize = fs + 'px';
    });

    // Content editable toggle based on editMode
    content.contentEditable = editMode;

    // Resize logic

    let resizing = false;
    let resizeStartX, resizeStartY;
    let resizeStartWidth, resizeStartHeight;
    let resizeDir = null;

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        resizing = true;
        resizeDir = handle.classList.contains('nw') ? 'nw' :
                    handle.classList.contains('ne') ? 'ne' :
                    handle.classList.contains('sw') ? 'sw' :
                    'se';
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        resizeStartWidth = box.offsetWidth;
        resizeStartHeight = box.offsetHeight;
        boxStartX = parseFloat(box.style.left);
        boxStartY = parseFloat(box.style.top);
        window.addEventListener('pointermove', onResizeMove);
        window.addEventListener('pointerup', onResizeEnd);
        e.preventDefault();
      });
    });

    function onResizeMove(e) {
      if (!resizing) return;
      let dx = (e.clientX - resizeStartX) / scale;
      let dy = (e.clientY - resizeStartY) / scale;

      let newWidth = resizeStartWidth;
      let newHeight = resizeStartHeight;
      let newLeft = boxStartX;
      let newTop = boxStartY;

      if (resizeDir.includes('e')) {
        newWidth = Math.max(40, resizeStartWidth + dx);
      }
      if (resizeDir.includes('s')) {
        newHeight = Math.max(24, resizeStartHeight + dy);
      }
      if (resizeDir.includes('w')) {
        newWidth = Math.max(40, resizeStartWidth - dx);
        newLeft = boxStartX + dx;
      }
      if (resizeDir.includes('n')) {
        newHeight = Math.max(24, resizeStartHeight - dy);
        newTop = boxStartY + dy;
      }
      box.style.width = newWidth + 'px';
      box.style.height = newHeight + 'px';
      box.style.left = newLeft + 'px';
      box.style.top = newTop + 'px';
      drawConnections();
    }
    function onResizeEnd(e) {
      resizing = false;
      window.removeEventListener('pointermove', onResizeMove);
      window.removeEventListener('pointerup', onResizeEnd);
    }

    return box;
  }

  function addBox(x, y, text = "", fontSize = 14, id = null) {
    if (!id) id = generateId();
    if (boxesMap.has(id)) return null;
    const box = createBoxElement(id, x, y, text, fontSize);
    canvas.appendChild(box);
    boxesMap.set(id, box);
    return box;
  }

  function removeBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    // Remove any connections involving this box
    for (let i = connections.length -1; i >= 0; i--) {
      if (connections[i].fromId === id || connections[i].toId === id) {
        connections.splice(i,1);
      }
    }
    box.remove();
    boxesMap.delete(id);
    drawConnections();
  }

  // Serialize and deserialize

  function serializeBox(box) {
    return {
      id: box.getAttribute('data-id'),
      x: parseFloat(box.style.left),
      y: parseFloat(box.style.top),
      text: box.querySelector('.box-content').textContent,
      fontSize: parseInt(box.style.fontSize) || 14,
      width: box.offsetWidth,
      height: box.offsetHeight,
    };
  }
  function deserializeBox(data) {
    const box = addBox(data.x, data.y, data.text, data.fontSize, data.id);
    if (!box) return null;
    box.style.width = (data.width || 120) + 'px';
    box.style.height = (data.height || 40) + 'px';
    return box;
  }

  // Save and load maps

  async function loadMapsList() {
    mapSelect.innerHTML = '';
    mapsCache.clear();
    const colRef = collection(db, 'mindmaps');
    const querySnapshot = await getDocs(colRef);
    querySnapshot.forEach(docSnap => {
      const data = docSnap.data();
      mapsCache.set(docSnap.id, { name: data.name || docSnap.id, ...data });
    });
    refreshMapSelectOptions();
  }

  function refreshMapSelectOptions() {
    mapSelect.innerHTML = '';
    mapsCache.forEach(({ name }, id) => {
      const option = document.createElement('option');
      option.value = id;
      option.textContent = name;
      mapSelect.appendChild(option);
    });
    if (currentMapId && mapsCache.has(currentMapId)) {
      mapSelect.value = currentMapId;
    } else if (mapSelect.options.length > 0) {
      mapSelect.selectedIndex = 0;
      currentMapId = mapSelect.value;
    }
  }

  async function loadMap(id) {
    if (!id) return;
    currentMapId = id;
    const docRef = doc(db, 'mindmaps', id);
    try {
      const docSnap = await getDocs(collection(db, 'mindmaps'));
      const colRef = collection(db, 'mindmaps');
      const docData = mapsCache.get(id);
      if (!docData) return;
      clearAllBoxes();
      connections.length = 0;
      if (docData.boxes) {
        docData.boxes.forEach(bdata => {
          deserializeBox(bdata);
        });
      }
      if (docData.connections) {
        docData.connections.forEach(c => connections.push(c));
      }
      if (docData.center) {
        panX = docData.center.panX || 0;
        panY = docData.center.panY || 0;
        scale = docData.center.scale || 1;
      } else {
        panX = 0; panY = 0; scale = 1;
      }
      updateTransform();
      drawConnections();
      refreshMapSelectOptions();
      saveStatus.textContent = `Loaded "${docData.name}"`;
      setTimeout(() => saveStatus.textContent = '', 3000);
    } catch(e) {
      console.error('Load map error', e);
    }
  }

  function clearAllBoxes() {
    boxesMap.forEach(box => box.remove());
    boxesMap.clear();
  }

  async function saveCurrentMap() {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    const boxesData = [];
    boxesMap.forEach(box => boxesData.push(serializeBox(box)));
    const mapData = {
      name: mapsCache.get(currentMapId)?.name || currentMapId,
      boxes: boxesData,
      connections: [...connections],
      center: { panX, panY, scale },
      updated: Date.now()
    };
    const docRef = doc(db, 'mindmaps', currentMapId);
    try {
      await setDoc(docRef, mapData);
      mapsCache.set(currentMapId, mapData);
      saveStatus.textContent = 'Save successful';
      setTimeout(() => saveStatus.textContent = '', 2000);
    } catch(e) {
      console.error('Save error', e);
      saveStatus.textContent = 'Save failed';
      setTimeout(() => saveStatus.textContent = '', 2000);
    }
  }

  async function deleteCurrentMap() {
    if (!currentMapId) return;
    if (!confirm(`Delete map "${mapsCache.get(currentMapId)?.name || currentMapId}"? This cannot be undone.`)) return;
    try {
      await deleteDoc(doc(db, 'mindmaps', currentMapId));
      mapsCache.delete(currentMapId);
      clearAllBoxes();
      connections.length = 0;
      currentMapId = null;
      saveStatus.textContent = 'Map deleted';
      setTimeout(() => saveStatus.textContent = '', 2000);
      await loadMapsList();
      if (mapSelect.options.length > 0) {
        currentMapId = mapSelect.value;
        await loadMap(currentMapId);
      }
    } catch(e) {
      console.error('Delete error', e);
      saveStatus.textContent = 'Delete failed';
      setTimeout(() => saveStatus.textContent = '', 2000);
    }
  }

  async function renameCurrentMap() {
    if (!currentMapId) return;
    const newName = prompt("Enter new name for map", mapsCache.get(currentMapId)?.name || "");
    if (!newName) return;
    const data = mapsCache.get(currentMapId) || {};
    data.name = newName;
    mapsCache.set(currentMapId, data);
    const docRef = doc(db, 'mindmaps', currentMapId);
    try {
      await setDoc(docRef, data, { merge: true });
      refreshMapSelectOptions();
      saveStatus.textContent = 'Rename successful';
      setTimeout(() => saveStatus.textContent = '', 2000);
    } catch(e) {
      console.error('Rename error', e);
      saveStatus.textContent = 'Rename failed';
      setTimeout(() => saveStatus.textContent = '', 2000);
    }
  }

  async function createNewMap() {
    let newName = prompt("Enter name for new mind map", "New Map");
    if (!newName) return;
    // Ensure unique id
    let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    if (!newId) newId = generateId();
    // Make sure id is unique
    while(mapsCache.has(newId)) {
      newId += '-' + Math.floor(Math.random() * 9999);
    }
    const docRef = doc(db, 'mindmaps', newId);
    const mapData = {
      name: newName,
      boxes: [],
      connections: [],
      center: { panX: 0, panY: 0, scale: 1 },
      updated: Date.now()
    };
    try {
      await setDoc(docRef, mapData);
      mapsCache.set(newId, mapData);
      currentMapId = newId;
      clearAllBoxes();
      connections.length = 0;
      panX = 0; panY = 0; scale = 1;
      updateTransform();
      drawConnections();
      refreshMapSelectOptions();
      mapSelect.value = currentMapId;
      saveStatus.textContent = 'New map created';
      setTimeout(() => saveStatus.textContent = '', 2000);
    } catch(e) {
      console.error('New map error', e);
      saveStatus.textContent = 'Create failed';
      setTimeout(() => saveStatus.textContent = '', 2000);
    }
  }

  // Undo delete box

  function updateUndoButton() {
    undoBtn.disabled = undoStack.length === 0;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const action = undoStack.pop();
    if (action.type === 'deleteBox') {
      const data = action.data;
      deserializeBox(data);
      drawConnections();
      updateUndoButton();
      saveStatus.textContent = 'Undo successful';
      setTimeout(() => saveStatus.textContent = '', 2000);
    }
  });

  // Mark center and go center

  markCenterBtn.addEventListener('click', () => {
    saveStatus.textContent = 'Center marked';
    setTimeout(() => saveStatus.textContent = '', 1500);
    // Marking center only saves current pan and zoom values
  });

  goCenterBtn.addEventListener('click', () => {
    panX = 0;
    panY = 0;
    scale = 1;
    updateTransform();
    saveStatus.textContent = 'Centered viewport';
    setTimeout(() => saveStatus.textContent = '', 1500);
  });

  // Toggle edit mode

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
    boxesMap.forEach(box => {
      box.querySelector('.box-content').contentEditable = editMode;
      box.querySelectorAll('.resize-handle').forEach(h => h.style.display = editMode ? 'block' : 'none');
      box.querySelector('.delete-btn').style.display = editMode ? 'inline-flex' : 'none';
      box.querySelector('.connect-toggle').style.display = editMode ? 'inline-flex' : 'none';
      box.querySelector('.font-size-btn').style.display = editMode ? 'inline-flex' : 'none';
    });
    if (connectionStartBoxId !== null) {
      connectionStartBoxId = null;
      document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
    }
    saveStatus.textContent = editMode ? 'Edit mode ON' : 'Edit mode OFF';
    setTimeout(() => saveStatus.textContent = '', 1500);
  });

  // Load map on dropdown change
  mapSelect.addEventListener('change', () => {
    loadMap(mapSelect.value);
  });

  saveMapBtn.addEventListener('click', () => {
    saveCurrentMap();
  });
  renameMapBtn.addEventListener('click', () => {
    renameCurrentMap();
  });
  deleteMapBtn.addEventListener('click', () => {
    deleteCurrentMap();
  });
  newMapBtn.addEventListener('click', () => {
    createNewMap();
  });

  // How to modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Initialization

  async function init() {
    await loadMapsList();
    if (mapSelect.options.length > 0) {
      currentMapId = mapSelect.value;
      await loadMap(currentMapId);
    } else {
      // no maps, create one default map
      await createNewMap();
    }
    updateUndoButton();
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  }

  init();

</script>

</body>
</html>
