<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings - Editable Boxes & Connections</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body, #viewport {
    margin:0; padding:0; width:100%; height:100%; overflow:hidden;
    user-select:none; touch-action:none; background:#f0f0f0;
  }
  #viewport {
    position: relative; cursor: grab;
  }
  #canvas {
    position: absolute; top:0; left:0;
    user-select:none;
  }
  svg#connectionLayer {
    position: absolute;
    top:0; left:0; width:100%; height:100%;
    pointer-events:none;
    z-index: 0;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    min-width: 80px; min-height: 40px;
    box-sizing: border-box;
    overflow: hidden;
    z-index: 10;
    cursor: grab;
    display: flex;
    flex-direction: column;
  }
  .box-header {
    background: #ddd;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding: 1px 4px;
    user-select: none;
    height: 18px;
    border-bottom: 1px solid #bbb;
    flex-shrink: 0;
  }
  .box-header button {
    width: 20px; height: 18px;
    border: none;
    cursor: pointer;
    background: none;
    font-weight: bold;
    font-size: 18px;
    line-height: 1;
    padding: 0;
    user-select: none;
    color: red;
  }
  .connect-toggle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px; height: 20px;
    border-radius: 4px;
    background-color: #3b82f6;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  .connect-toggle.active {
    background-color: #16a34a;
  }
  .box-content {
    flex: 1;
    padding: 8px 10px;
    font-family: monospace;
    font-size: 16px;
    line-height: 1.2;
    overflow: auto;
    outline: none;
    white-space: pre-wrap;
    word-break: break-word;
    user-select: text;
    cursor: text;
  }
  .resize-handle {
    width: 14px;
    height: 14px;
    position: absolute;
    background: transparent;
    z-index: 20;
    bottom: 0; right: 0;
    cursor: nwse-resize;
  }
  #buttonContainer {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  button.floatingBtn {
    font-family: monospace;
    padding: 6px 12px;
    background: rgba(80, 80, 80, 0.6);
    border: 1px solid #555;
    color: #eee;
    cursor: pointer;
    border-radius: 4px;
    user-select: none;
  }
  button.floatingBtn:disabled {
    background: #999;
    cursor: default;
    color: #ccc;
  }
  #zoomDisplay {
    position: fixed;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.5);
    color: white;
    font-family: monospace;
    padding: 4px 8px;
    border-radius: 4px;
    user-select: none;
    pointer-events: none;
    z-index: 1001;
  }
  path.connection {
    stroke: black;
    stroke-width: 2;
    fill: none;
  }
</style>
</head>
<body>
<div id="viewport" tabindex="0">
  <svg id="connectionLayer"></svg>
  <div id="canvas"></div>
</div>
<div id="buttonContainer">
  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
</div>
<div id="zoomDisplay">Zoom: 100%</div>

<script>
(() => {
  const viewport = document.getElementById('viewport');
  const canvas = document.getElementById('canvas');
  const connectionLayer = document.getElementById('connectionLayer');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const zoomDisplay = document.getElementById('zoomDisplay');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, panStartX, panStartY;
  let undoStack = [];
  let connections = [];
  let connectionStartBox = null;

  const generateId = () => 'id_' + Math.random().toString(36).slice(2,11);

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px,${panY}px) scale(${scale})`;
    connectionLayer.style.transform = `translate(${panX}px,${panY}px) scale(${scale})`;
    zoomDisplay.textContent = `Zoom: ${Math.round(scale*100)}%`;
    drawConnections();
  }

  viewport.style.cursor = 'grab';
  viewport.addEventListener('pointerdown', e => {
    if(e.target.closest('.box') || e.target.closest('button')) return;
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    viewport.setPointerCapture(e.pointerId);
    viewport.style.cursor = 'grabbing';
  });
  viewport.addEventListener('pointermove', e => {
    if(!isPanning) return;
    const dx = e.clientX - panStartX;
    const dy = e.clientY - panStartY;
    panX += dx;
    panY += dy;
    panStartX = e.clientX;
    panStartY = e.clientY;
    updateTransform();
  });
  viewport.addEventListener('pointerup', e => {
    if(!isPanning) return;
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
    viewport.style.cursor = 'grab';
    saveAll();
  });

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    let newScale = scale * (e.deltaY < 0 ? zoomFactor : 1/zoomFactor);
    newScale = Math.min(3, Math.max(0.5, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
    saveAll();
  }, { passive: false });

  function createBox(x, y, text='Text box', id=null, width=180, height=80, fontSize='16px') {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.dataset.id = id || generateId();

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect';

    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Ã—';

    const header = document.createElement('div');
    header.className = 'box-header';
    header.appendChild(deleteBtn);

    box.appendChild(connectToggle);
    box.appendChild(header);

    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = true;
    content.spellcheck = false;
    content.textContent = text;
    content.style.fontSize = fontSize;

    box.appendChild(content);

    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle';
    box.appendChild(resizeHandle);

    let dragging = false, dragOffsetX, dragOffsetY;
    let resizing = false;
    let resizeStartWidth, resizeStartHeight, resizeStartClientX, resizeStartClientY;

    // Drag entire box by clicking anywhere inside except buttons and resize handle
    box.addEventListener('pointerdown', e => {
      if(e.target === connectToggle || e.target === deleteBtn || e.target === resizeHandle) return;
      dragging = true;
      dragOffsetX = e.clientX - box.offsetLeft;
      dragOffsetY = e.clientY - box.offsetTop;
      box.setPointerCapture(e.pointerId);
      e.preventDefault();
      viewport.style.cursor = 'grabbing';
    });
    box.addEventListener('pointermove', e => {
      if(!dragging) return;
      e.preventDefault();
      box.style.left = (e.clientX - dragOffsetX) + 'px';
      box.style.top = (e.clientY - dragOffsetY) + 'px';
      drawConnections();
    });
    box.addEventListener('pointerup', e => {
      if(!dragging) return;
      dragging = false;
      box.releasePointerCapture(e.pointerId);
      saveAll();
      viewport.style.cursor = 'grab';
    });

    // Resize
    resizeHandle.addEventListener('pointerdown', e => {
      resizing = true;
      resizeStartWidth = box.offsetWidth;
      resizeStartHeight = box.offsetHeight;
      resizeStartClientX = e.clientX;
      resizeStartClientY = e.clientY;
      resizeHandle.setPointerCapture(e.pointerId);
      e.preventDefault();
    });
    resizeHandle.addEventListener('pointermove', e => {
      if(!resizing || !resizeHandle.hasPointerCapture(e.pointerId)) return;
      e.preventDefault();
      const dx = e.clientX - resizeStartClientX;
      const dy = e.clientY - resizeStartClientY;
      box.style.width = Math.max(80, resizeStartWidth + dx) + 'px';
      box.style.height = Math.max(40, resizeStartHeight + dy) + 'px';
      adjustFontSize(content, box);
      drawConnections();
    });
    resizeHandle.addEventListener('pointerup', e => {
      if(!resizing) return;
      resizing = false;
      resizeHandle.releasePointerCapture(e.pointerId);
      saveAll();
    });

    // Connect toggle button
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if(connectionStartBox === box) {
        connectionStartBox = null;
        connectToggle.classList.remove('active');
      } else {
        document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
        connectionStartBox = box;
        connectToggle.classList.add('active');
      }
    });

    // Delete button
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(box.dataset.id);
    });

    // Click content to edit font size dynamically on input
    content.addEventListener('input', () => {
      adjustFontSize(content, box);
      saveAll();
    });

    // Adjust font size to fit box
    function adjustFontSize(contentDiv, container) {
      const padding = 16;
      const maxWidth = container.clientWidth - padding;
      const maxHeight = container.clientHeight - padding;
      let minSize = 8;
      let maxSize = 72;
      let fontSize = 16;
      while(minSize <= maxSize) {
        let mid = Math.floor((minSize + maxSize) / 2);
        contentDiv.style.fontSize = mid + 'px';
        if(contentDiv.scrollWidth <= maxWidth && contentDiv.scrollHeight <= maxHeight) {
          fontSize = mid;
          minSize = mid + 1;
        } else {
          maxSize = mid - 1;
        }
      }
      contentDiv.style.fontSize = fontSize + 'px';
    }
    adjustFontSize(content, box);

    canvas.appendChild(box);
    return box;
  }

  function deleteBox(id) {
    const box = document.querySelector(`.box[data-id="${id}"]`);
    if(!box) return;
    undoStack.push({
      type: 'box',
      id,
      x: box.offsetLeft,
      y: box.offsetTop,
      width: box.offsetWidth,
      height: box.offsetHeight,
      text: box.querySelector('.box-content').textContent,
      fontSize: box.querySelector('.box-content').style.fontSize || '16px',
    });
    undoBtn.disabled = false;
    connections = connections.filter(conn => {
      if(conn.from === id || conn.to === id) {
        const path = document.querySelector(`path.connection[data-id="${conn.id}"]`);
        if(path) path.remove();
        return false;
      }
      return true;
    });
    box.remove();
    saveAll();
  }

  undoBtn.addEventListener('click', () => {
    if(undoStack.length === 0) return;
    const last = undoStack.pop();
    if(last.type === 'box') {
      createBox(last.x, last.y, last.text, last.id, last.width, last.height, last.fontSize);
      saveAll();
    }
    undoBtn.disabled = undoStack.length === 0;
  });

  // Draw smooth cubic Bezier connections between box centers
  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(conn => {
      const fromBox = document.querySelector(`.box[data-id="${conn.from}"]`);
      const toBox = document.querySelector(`.box[data-id="${conn.to}"]`);
      if(!fromBox || !toBox) return;

      const startX = fromBox.offsetLeft + fromBox.offsetWidth / 2;
      const startY = fromBox.offsetTop + fromBox.offsetHeight / 2;
      const endX = toBox.offsetLeft + toBox.offsetWidth / 2;
      const endY = toBox.offsetTop + toBox.offsetHeight / 2;

      // Control points for smooth cubic bezier
      const controlOffsetX = Math.abs(endX - startX) / 2;
      const controlPoint1X = startX + controlOffsetX;
      const controlPoint1Y = startY;
      const controlPoint2X = endX - controlOffsetX;
      const controlPoint2Y = endY;

      const d = `M${startX} ${startY} C${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', d);
      path.classList.add('connection');
      path.dataset.id = conn.id;
      connectionLayer.appendChild(path);
    });
  }

  viewport.addEventListener('click', e => {
    if(!connectionStartBox) return;
    const targetBox = e.target.closest('.box');
    if(!targetBox) return;
    if(targetBox.dataset.id === connectionStartBox.dataset.id) {
      connectionStartBox.querySelector('.connect-toggle').classList.remove('active');
      connectionStartBox = null;
      return;
    }
    connections.push({
      id: generateId(),
      from: connectionStartBox.dataset.id,
      to: targetBox.dataset.id
    });
    connectionStartBox.querySelector('.connect-toggle').classList.remove('active');
    connectionStartBox = null;
    drawConnections();
    saveAll();
  });

  viewport.addEventListener('dblclick', e => {
    if(e.target.closest('.box') || e.target.closest('button')) return;
    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    createBox(x, y);
    saveAll();
  });

  function saveAll() {
    const boxes = [];
    document.querySelectorAll('.box').forEach(box => {
      boxes.push({
        id: box.dataset.id,
        x: box.offsetLeft,
        y: box.offsetTop,
        width: box.offsetWidth,
        height: box.offsetHeight,
        text: box.querySelector('.box-content').textContent,
        fontSize: box.querySelector('.box-content').style.fontSize || '16px',
      });
    });
    const data = {
      boxes,
      connections,
      panX,
      panY,
      scale
    };
    localStorage.setItem('stringsnthingsData', JSON.stringify(data));
  }
  function loadAll() {
    const dataStr = localStorage.getItem('stringsnthingsData');
    if(!dataStr) return;
    try {
      const data = JSON.parse(dataStr);
      document.querySelectorAll('.box').forEach(b => b.remove());
      connections = data.connections || [];
      panX = data.panX || 0;
      panY = data.panY || 0;
      scale = data.scale || 1;
      data.boxes.forEach(b => {
        createBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize);
      });
      updateTransform();
      drawConnections();
    } catch(e) {
      console.error('Load error', e);
    }
  }

  goCenterBtn.addEventListener('click', () => {
    panX = 0; panY = 0; scale = 1;
    updateTransform();
    saveAll();
  });

  loadAll();
  updateTransform();

  // Prevent text selection on dragging
  document.addEventListener('selectstart', e => {
    if(isPanning) e.preventDefault();
  });

})();
</script>
</body>
</html>
