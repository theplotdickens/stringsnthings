<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthings</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #f5f5f5;
      font-family: sans-serif;
    }
    #field {
      position: absolute;
      top: 0;
      left: 0;
      width: 100000px;
      height: 100000px;
      transform: translate(-50%, -50%);
    }
    .box {
      position: absolute;
      background: white;
      padding: 10px;
      border: 1px solid #ccc;
      resize: both;
      overflow: auto;
      min-width: 100px;
      min-height: 50px;
      box-sizing: border-box;
      user-select: text;
    }
    .line {
      stroke: black;
      stroke-width: 4;
      cursor: pointer;
    }
    .label {
      fill: white;
      stroke: black;
      stroke-width: 1;
      font-size: 16px;
      pointer-events: none;
    }
    .menu {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: rgba(100, 100, 100, 0.6);
      padding: 10px;
      border-radius: 10px;
    }
    .menu button {
      background: transparent;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <svg id="svg" style="position:absolute; z-index:0; width:100%; height:100%; pointer-events:none;"></svg>
  <div id="field"></div>
  <div class="menu">
    <button onclick="markCenter()">Mark Center</button>
    <button onclick="goToCenter()">Go to Center</button>
    <button onclick="toggleDrawMode()">Draw Mode</button>
    <button onclick="undo()">Undo</button>
    <button onclick="deleteSelected()">Delete Selected</button>
  </div>

  <script>
    const field = document.getElementById("field");
    const svg = document.getElementById("svg");
    let center = { x: 50000, y: 50000 };
    let boxes = [];
    let lines = [];
    let undoStack = [];
    let drawMode = false;
    let selectedLine = null;

    function createBox(x, y, text = "", width = 150, height = 100, fontSize = 16) {
      const box = document.createElement("div");
      box.className = "box";
      box.contentEditable = true;
      box.style.left = x + "px";
      box.style.top = y + "px";
      box.style.width = width + "px";
      box.style.height = height + "px";
      box.style.fontSize = fontSize + "px";
      box.innerText = text;

      // Add invisible resizers on all 4 corners
      ["nwse-resize", "nesw-resize", "nesw-resize", "nwse-resize"].forEach((cursor, i) => {
        const handle = document.createElement("div");
        handle.style.position = "absolute";
        handle.style.width = "12px";
        handle.style.height = "12px";
        handle.style.background = "transparent";
        handle.style.zIndex = "10";
        handle.style.cursor = cursor;

        switch (i) {
          case 0:
            handle.style.left = "-6px"; handle.style.top = "-6px";
            break;
          case 1:
            handle.style.right = "-6px"; handle.style.top = "-6px";
            break;
          case 2:
            handle.style.left = "-6px"; handle.style.bottom = "-6px";
            break;
          case 3:
            handle.style.right = "-6px"; handle.style.bottom = "-6px";
            break;
        }

        box.appendChild(handle);
      });

      makeDraggable(box);
      box.addEventListener("input", save);
      field.appendChild(box);
      boxes.push(box);
      save();
    }

    function makeDraggable(el) {
      let offsetX, offsetY;
      el.addEventListener("mousedown", e => {
        if (drawMode) return;
        if (e.target !== el) return;
        offsetX = e.offsetX;
        offsetY = e.offsetY;
        const onMouseMove = e2 => {
          el.style.left = e2.pageX - offsetX + "px";
          el.style.top = e2.pageY - offsetY + "px";
          updateLines();
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", () => {
          document.removeEventListener("mousemove", onMouseMove);
          save();
        }, { once: true });
      });

      el.addEventListener("mouseup", () => {
        el.dataset.fontSize = parseInt(window.getComputedStyle(el).fontSize);
      });

      const observer = new ResizeObserver(() => {
        const boxFontSize = parseInt(el.dataset.fontSize || 16);
        const newSize = Math.min(el.offsetWidth / 10, el.offsetHeight / 2);
        el.style.fontSize = Math.max(10, Math.min(boxFontSize, newSize)) + "px";
        updateLines();
        save();
      });
      observer.observe(el);
    }

    field.addEventListener("dblclick", e => {
      if (!drawMode) createBox(e.offsetX, e.offsetY);
    });

    function updateLines() {
      svg.innerHTML = "";
      lines.forEach(line => {
        const [a, b, label] = line;
        const ax = a.offsetLeft + a.offsetWidth / 2;
        const ay = a.offsetTop + a.offsetHeight / 2;
        const bx = b.offsetLeft + b.offsetWidth / 2;
        const by = b.offsetTop + b.offsetHeight / 2;

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", `M${ax},${ay} Q${(ax + bx) / 2},${(ay + by) / 2 - 100} ${bx},${by}`);
        path.classList.add("line");
        path.addEventListener("click", () => {
          selectedLine = line;
        });

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.classList.add("label");
        text.setAttribute("x", (ax + bx) / 2);
        text.setAttribute("y", (ay + by) / 2 - 20);
        text.textContent = label;

        svg.appendChild(path);
        svg.appendChild(text);
      });
    }

    function toggleDrawMode() {
      drawMode = !drawMode;
      if (drawMode) {
        let first = null;
        boxes.forEach(box => {
          box.onclick = e => {
            e.stopPropagation();
            if (!drawMode) return;
            if (!first) {
              first = box;
            } else {
              const label = prompt("Connection Label:");
              if (label) {
                lines.push([first, box, label]);
                undoStack.push(["line", [first, box, label]]);
                updateLines();
                save();
              }
              first = null;
            }
          };
        });
      }
    }

    function deleteSelected() {
      if (selectedLine) {
        const idx = lines.indexOf(selectedLine);
        if (idx > -1) {
          lines.splice(idx, 1);
          undoStack.push(["deleteLine", selectedLine]);
          updateLines();
          save();
          selectedLine = null;
        }
      }
    }

    function undo() {
      const last = undoStack.pop();
      if (!last) return;
      const [type, data] = last;
      if (type === "box") {
        field.removeChild(data);
        boxes = boxes.filter(b => b !== data);
      } else if (type === "line") {
        lines = lines.filter(l => l !== data);
        updateLines();
      } else if (type === "deleteLine") {
        lines.push(data);
        updateLines();
      }
      save();
    }

    function markCenter() {
      center.x = window.scrollX + window.innerWidth / 2;
      center.y = window.scrollY + window.innerHeight / 2;
    }

    function goToCenter() {
      window.scrollTo(center.x - window.innerWidth / 2, center.y - window.innerHeight / 2);
    }

    function save() {
      const data = {
        boxes: boxes.map(b => ({
          x: b.offsetLeft,
          y: b.offsetTop,
          text: b.innerText,
          width: b.offsetWidth,
          height: b.offsetHeight,
          fontSize: parseInt(window.getComputedStyle(b).fontSize)
        })),
        lines: lines.map(l => [boxes.indexOf(l[0]), boxes.indexOf(l[1]), l[2]])
      };
      localStorage.setItem("stringsnthings", JSON.stringify(data));
    }

    function load() {
      const data = JSON.parse(localStorage.getItem("stringsnthings") || "{}");
      if (data.boxes) {
        data.boxes.forEach(b => createBox(b.x, b.y, b.text, b.width, b.height, b.fontSize));
      }
      if (data.lines) {
        data.lines.forEach(([i, j, label]) => {
          if (boxes[i] && boxes[j]) lines.push([boxes[i], boxes[j], label]);
        });
        updateLines();
      }
    }

    load();
    goToCenter();
  </script>
</body>
</html>
