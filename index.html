<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV3withFirebaseSaveLoad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      flex-wrap: wrap;
      max-width: 90vw;
      justify-content: center;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #statusMessage {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1500;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
    <button id="saveBtn" class="floatingBtn">Save</button>
    <button id="loadBtn" class="floatingBtn">Load</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red × to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "Mark Center" to fix yourself a return point.
      Use "Go to Center" to jump to that point.
      **New:** Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the Save and Load buttons to save/load your mindmap to/from Firebase.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

  <div id="statusMessage"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

  // Your Firebase config here
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.firebasestorage.app",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const statusMessage = document.getElementById('statusMessage');
  const connectionLayer = document.getElementById('connectionLayer');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  // Show status messages briefly
  function showStatus(msg, duration=1500) {
    statusMessage.textContent = msg;
    statusMessage.style.opacity = '1';
    setTimeout(() => {
      statusMessage.style.opacity = '0';
    }, duration);
  }

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // deselect on background click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  markCenterBtn.addEventListener('click', async () => {
    const rect = viewport.getBoundingClientRect();
    const centerX = (rect.width / 2 - panX) / scale;
    const centerY = (rect.height / 2 - panY) / scale;
    // Save center in Firestore
    try {
      await setDoc(doc(db, "stringsnthings", "center"), { x: centerX, y: centerY });
      showStatus(`Center marked at: ${Math.round(centerX)}, ${Math.round(centerY)}`);
    } catch(e) {
      showStatus("Failed to mark center");
      console.error(e);
    }
  });

  goCenterBtn.addEventListener('click', async () => {
    try {
      const docSnap = await getDoc(doc(db, "stringsnthings", "center"));
      if (docSnap.exists()) {
        const c = docSnap.data();
        const rect = viewport.getBoundingClientRect();
        panX = rect.width / 2 - c.x * scale;
        panY = rect.height / 2 - c.y * scale;
        updateTransform();
        showStatus("Moved to center");
      } else {
        showStatus("No center marked");
      }
    } catch(e) {
      showStatus("Failed to load center");
      console.error(e);
    }
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    document.querySelectorAll('.box-header').forEach(header => {
      header.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.connect-toggle').forEach(toggle => {
      toggle.style.display = editMode ? 'inline-block' : 'none';
    });
    document.querySelectorAll('.font-size-btn').forEach(btn => {
      btn.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.drag-handle').forEach(handle => {
      handle.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.box-content').forEach(content => {
      content.contentEditable = editMode;
      content.style.cursor = editMode ? 'text' : 'default';
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });

  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Box creation and tracking
  let boxIdCounter = 1;

  function createBoxElement(id, x, y, width = 140, height = 80, text = '', fontSize = 14) {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = `${width}px`;
    box.style.height = `${height}px`;
    box.dataset.id = id;
    box.dataset.fontSize = fontSize;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Click to start or complete a connection';
    header.appendChild(connectToggle);

    // Font size controls
    const fontMinus = document.createElement('button');
    fontMinus.className = 'font-size-btn';
    fontMinus.textContent = '-';
    fontMinus.title = 'Decrease font size';
    header.appendChild(fontMinus);

    const fontPlus = document.createElement('button');
    fontPlus.className = 'font-size-btn';
    fontPlus.textContent = '+';
    fontPlus.title = 'Increase font size';
    header.appendChild(fontPlus);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Delete box';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content area
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.style.fontSize = `${fontSize}px`;
    content.textContent = text;
    box.appendChild(content);

    // Resize handles (only corners)
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = document.createElement('div');
      handle.className = `resize-handle ${corner}`;
      box.appendChild(handle);
    });

    // Event listeners:

    // Dragging box
    let dragging = false, dragStartX, dragStartY;
    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.stopPropagation();
      dragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      document.body.style.userSelect = 'none';

      // Multi-select dragging
      if (!selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        box.classList.add('selected');
        selectedBoxes.add(box);
      }
    });

    document.addEventListener('pointermove', e => {
      if (!dragging) return;
      e.preventDefault();
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      dragStartX = e.clientX;
      dragStartY = e.clientY;

      selectedBoxes.forEach(b => {
        let left = parseFloat(b.style.left);
        let top = parseFloat(b.style.top);
        left += dx / scale;
        top += dy / scale;
        b.style.left = `${left}px`;
        b.style.top = `${top}px`;
      });
      drawConnections();
    });

    document.addEventListener('pointerup', e => {
      if (dragging) {
        dragging = false;
        document.body.style.userSelect = '';
      }
    });

    // Shift+click on header to select multiple
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (!e.shiftKey) return;
      if (e.target === dragHandle) e.preventDefault();
      if (selectedBoxes.has(box)) {
        selectedBoxes.delete(box);
        box.classList.remove('selected');
      } else {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });

    // Delete box
    deleteBtn.addEventListener('click', e => {
      if (!editMode) return;
      e.stopPropagation();
      removeBox(id);
      showStatus('Box deleted');
    });

    // Connect toggle click
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === null) {
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else if (connectionStartBoxId === id) {
        // Cancel connection start
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        // Create connection from connectionStartBoxId -> id
        addConnection(connectionStartBoxId, id);
        connectionStartBoxId = null;
        clearConnectionToggles();
        showStatus('Connection added');
      }
      drawConnections();
    });

    // Font size adjust
    fontMinus.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      let fs = parseInt(box.dataset.fontSize);
      if (fs > 6) fs -= 1;
      box.dataset.fontSize = fs;
      content.style.fontSize = `${fs}px`;
    });

    fontPlus.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      let fs = parseInt(box.dataset.fontSize);
      if (fs < 72) fs += 1;
      box.dataset.fontSize = fs;
      content.style.fontSize = `${fs}px`;
    });

    // Resize handling
    let resizing = false;
    let resizeDir = null;
    let resizeStartX, resizeStartY;
    let origX, origY, origW, origH;

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        resizing = true;
        resizeDir = handle.classList[1];
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        origX = parseFloat(box.style.left);
        origY = parseFloat(box.style.top);
        origW = parseFloat(box.style.width);
        origH = parseFloat(box.style.height);
        document.body.style.userSelect = 'none';
      });
    });

    document.addEventListener('pointermove', e => {
      if (!resizing) return;
      e.preventDefault();
      let dx = (e.clientX - resizeStartX) / scale;
      let dy = (e.clientY - resizeStartY) / scale;
      let newX = origX, newY = origY, newW = origW, newH = origH;
      switch (resizeDir) {
        case 'nw':
          newX = origX + dx;
          newY = origY + dy;
          newW = origW - dx;
          newH = origH - dy;
          break;
        case 'ne':
          newY = origY + dy;
          newW = origW + dx;
          newH = origH - dy;
          break;
        case 'sw':
          newX = origX + dx;
          newW = origW - dx;
          newH = origH + dy;
          break;
        case 'se':
          newW = origW + dx;
          newH = origH + dy;
          break;
      }
      if (newW < 50) newW = 50;
      if (newH < 30) newH = 30;
      if (newX < 0) newX = 0;
      if (newY < 0) newY = 0;
      box.style.left = `${newX}px`;
      box.style.top = `${newY}px`;
      box.style.width = `${newW}px`;
      box.style.height = `${newH}px`;
      drawConnections();
    });

    document.addEventListener('pointerup', e => {
      if (resizing) {
        resizing = false;
        document.body.style.userSelect = '';
      }
    });

    // Content editing change triggers redraw to adjust connections
    content.addEventListener('input', e => {
      drawConnections();
    });

    return box;
  }

  function addBox(x, y, w=140, h=80, text='', fontSize=14, id = null) {
    if (!id) id = 'box' + boxIdCounter++;
    if (boxesMap.has(id)) return null;
    const box = createBoxElement(id, x, y, w, h, text, fontSize);
    boxesMap.set(id, box);
    canvas.appendChild(box);
    drawConnections();
    return box;
  }

  function removeBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    boxesMap.delete(id);
    // Remove all connections linked to this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    box.remove();
    drawConnections();
    undoStack.push({ action: 'removeBox', boxData: serializeBox(box), connections: [...connections] });
    undoBtn.disabled = false;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastAction = undoStack.pop();
    if (lastAction.action === 'removeBox') {
      const b = lastAction.boxData;
      addBox(b.x, b.y, b.width, b.height, b.text, b.fontSize, b.id);
      connections.length = 0;
      connections.push(...lastAction.connections);
      drawConnections();
      undoBtn.disabled = undoStack.length === 0;
      showStatus('Undo complete');
    }
  });

  function addConnection(fromId, toId) {
    if (connections.some(c => c.from === fromId && c.to === toId)) return;
    connections.push({ from: fromId, to: toId });
  }

  function clearConnectionToggles() {
    document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
  }

  // Draw connections as curved SVG lines
  function drawConnections() {
    const svg = connectionLayer;
    const rect = viewport.getBoundingClientRect();
    svg.setAttribute('width', rect.width);
    svg.setAttribute('height', rect.height);
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    connections.forEach(({ from, to }) => {
      const boxFrom = boxesMap.get(from);
      const boxTo = boxesMap.get(to);
      if (!boxFrom || !boxTo) return;

      // Get center bottom of from box and center top of to box
      const fromRect = boxFrom.getBoundingClientRect();
      const toRect = boxTo.getBoundingClientRect();

      // Convert screen coords to canvas coords (unscaled + unpanned)
      const fromX = (fromRect.left + fromRect.width / 2 - panX) / scale;
      const fromY = (fromRect.top + fromRect.height - panY) / scale;
      const toX = (toRect.left + toRect.width / 2 - panX) / scale;
      const toY = (toRect.top - panY) / scale;

      // Create path with simple bezier curve
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const deltaX = Math.abs(toX - fromX);
      const controlPointOffset = deltaX / 2;
      const d = `M${fromX},${fromY} C${fromX},${fromY + controlPointOffset} ${toX},${toY - controlPointOffset} ${toX},${toY}`;
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '1.5');
      path.setAttribute('fill', 'none');
      svg.appendChild(path);
    });
  }

  // Serialize map state to JSON
  function serialize() {
    const boxes = [];
    boxesMap.forEach(box => {
      boxes.push(serializeBox(box));
    });
    return {
      boxes,
      connections: [...connections],
      scale,
      panX,
      panY
    };
  }

  function serializeBox(box) {
    return {
      id: box.dataset.id,
      x: parseFloat(box.style.left),
      y: parseFloat(box.style.top),
      width: parseFloat(box.style.width),
      height: parseFloat(box.style.height),
      text: box.querySelector('.box-content').textContent,
      fontSize: parseInt(box.dataset.fontSize)
    };
  }

  // Deserialize and restore map state
  function deserialize(data) {
    clearAll();
    if (!data) return;
    if (data.scale) scale = data.scale;
    if (data.panX) panX = data.panX;
    if (data.panY) panY = data.panY;
    if (data.boxes && Array.isArray(data.boxes)) {
      data.boxes.forEach(b => {
        addBox(b.x, b.y, b.width, b.height, b.text, b.fontSize, b.id);
      });
    }
    if (data.connections && Array.isArray(data.connections)) {
      connections.length = 0;
      connections.push(...data.connections);
    }
    updateTransform();
    drawConnections();
  }

  function clearAll() {
    boxesMap.forEach(box => box.remove());
    boxesMap.clear();
    connections.length = 0;
    drawConnections();
  }

  // Save map state to Firestore
  saveBtn.addEventListener('click', async () => {
    const data = serialize();
    try {
      await setDoc(doc(db, "stringsnthings", "state"), data);
      showStatus("Save successful");
    } catch (e) {
      console.error("Save failed", e);
      showStatus("Save failed");
    }
  });

  // Load map state from Firestore
  loadBtn.addEventListener('click', async () => {
    try {
      const docSnap = await getDoc(doc(db, "stringsnthings", "state"));
      if (docSnap.exists()) {
        const data = docSnap.data();
        deserialize(data);
        showStatus("Load successful");
      } else {
        showStatus("No saved data found");
      }
    } catch (e) {
      console.error("Load failed", e);
      showStatus("Load failed");
    }
  });

  // Initial Setup: Load on page open if data exists
  window.addEventListener('load', async () => {
    try {
      const docSnap = await getDoc(doc(db, "stringsnthings", "state"));
      if (docSnap.exists()) {
        deserialize(docSnap.data());
        showStatus("Map loaded");
      }
    } catch (e) {
      console.error("Initial load failed", e);
    }
    // Also load center
    try {
      const docSnap = await getDoc(doc(db, "stringsnthings", "center"));
      if (docSnap.exists()) {
        const c = docSnap.data();
        const rect = viewport.getBoundingClientRect();
        panX = rect.width / 2 - c.x * scale;
        panY = rect.height / 2 - c.y * scale;
        updateTransform();
      }
    } catch {}
  });

</script>
</body>
</html>
