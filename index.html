<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV3withFirebaseSaveLoad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
    <button id="saveBtn" class="floatingBtn">Save</button>
    <button id="loadBtn" class="floatingBtn">Load</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      **New:** Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the Save button to store data in Firebase and Load to retrieve it.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import {
    getFirestore, doc, setDoc, getDoc,
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

  // Your Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const howToContent = document.getElementById('howToContent');
  const connectionLayer = document.getElementById('connectionLayer');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // deselect on background click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  markCenterBtn.addEventListener('click', () => {
    const rect = viewport.getBoundingClientRect();
    const centerX = (rect.width / 2 - panX) / scale;
    const centerY = (rect.height / 2 - panY) / scale;
    localStorage.setItem('markedCenter', JSON.stringify({ x: centerX, y: centerY }));
    // Also save to Firebase
    saveCenter(centerX, centerY);
    alert('Center marked at: ' + Math.round(centerX) + ', ' + Math.round(centerY));
  });

  goCenterBtn.addEventListener('click', () => {
    const savedCenter = localStorage.getItem('markedCenter');
    if (savedCenter) {
      const c = JSON.parse(savedCenter);
      const rect = viewport.getBoundingClientRect();
      panX = rect.width / 2 - c.x * scale;
      panY = rect.height / 2 - c.y * scale;
    } else {
      panX = window.innerWidth / 2;
      panY = window.innerHeight / 2;
    }
    updateTransform();
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    document.querySelectorAll('.box-header').forEach(header => {
      header.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.connect-toggle').forEach(toggle => {
      toggle.style.display = editMode ? 'inline-block' : 'none';
    });
    document.querySelectorAll('.font-size-btn').forEach(btn => {
      btn.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.drag-handle').forEach(handle => {
      handle.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.box-content').forEach(content => {
      content.contentEditable = editMode;
      content.style.cursor = editMode ? 'text' : 'default';
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(({ fromId, toId }) => {
      const boxA = boxesMap.get(fromId);
      const boxB = boxesMap.get(toId);
      if (!boxA || !boxB) return;
      const ax = parseFloat(boxA.style.left) + boxA.offsetWidth / 2;
      const ay = parseFloat(boxA.style.top) + boxA.offsetHeight / 2;
      const bx = parseFloat(boxB.style.left) + boxB.offsetWidth / 2;
      const by = parseFloat(boxB.style.top) + boxB.offsetHeight / 2;
      const startX = ax * scale + panX;
      const startY = ay * scale + panY;
      const endX = bx * scale + panX;
      const endY = by * scale + panY;
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const dx = endX - startX;
      const dy = endY - startY;
      const distance = Math.sqrt(dx*dx + dy*dy);
      if (distance === 0) return;
      const normX = dx / distance;
      const normY = dy / distance;
      const offset = 20;
      const sx = startX + normX * offset;
      const sy = startY + normY * offset;
      const ex = endX - normX * offset;
      const ey = endY - normY * offset;
      const controlX1 = sx + dy * 0.3;
      const controlY1 = sy - dx * 0.3;
      const controlX2 = ex + dy * 0.3;
      const controlY2 = ey - dx * 0.3;
      path.setAttribute('d', `M ${sx} ${sy} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${ex} ${ey}`);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      connectionLayer.appendChild(path);
    });
  }

  function createBoxElement(id, x, y, text = '', fontSize = 14, width = 150, height = 80) {
    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.dataset.id = id;

    const header = document.createElement('div');
    header.classList.add('box-header');
    header.style.display = editMode ? 'flex' : 'none';

    const dragHandle = document.createElement('div');
    dragHandle.classList.add('drag-handle');
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    const minusBtn = document.createElement('button');
    minusBtn.classList.add('font-size-btn');
    minusBtn.textContent = '−';
    minusBtn.title = 'Decrease font size';
    header.appendChild(minusBtn);

    const plusBtn = document.createElement('button');
    plusBtn.classList.add('font-size-btn');
    plusBtn.textContent = '+';
    plusBtn.title = 'Increase font size';
    header.appendChild(plusBtn);

    const connectToggle = document.createElement('button');
    connectToggle.classList.add('connect-toggle');
    connectToggle.title = 'Connect/Disconnect';
    connectToggle.style.display = editMode ? 'inline-block' : 'none';
    header.appendChild(connectToggle);

    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    const content = document.createElement('div');
    content.classList.add('box-content');
    content.contentEditable = editMode;
    content.style.fontSize = fontSize + 'px';
    content.style.width = '100%';
    content.style.height = '100%';
    content.style.minHeight = '24px';
    content.style.textAlign = 'center';
    content.style.display = 'flex';
    content.style.justifyContent = 'center';
    content.style.alignItems = 'center';
    content.style.wordBreak = 'break-word';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = document.createElement('div');
      handle.classList.add('resize-handle', corner);
      box.appendChild(handle);
    });

    canvas.appendChild(box);
    boxesMap.set(id, box);

    // Dragging
    let dragOffsetX, dragOffsetY;
    function onDragStart(e) {
      if (!editMode) return;
      if (e.button !== 0) return; // left mouse only
      if (!e.target.classList.contains('drag-handle')) return;
      e.preventDefault();
      dragOffsetX = e.clientX - box.offsetLeft * scale - panX;
      dragOffsetY = e.clientY - box.offsetTop * scale - panY;

      // Multi-select dragging support
      if (!selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }

      function onDragMove(ev) {
        ev.preventDefault();
        const moveX = ev.clientX - dragOffsetX - panX;
        const moveY = ev.clientY - dragOffsetY - panY;
        const dx = (moveX / scale) - parseFloat(box.style.left);
        const dy = (moveY / scale) - parseFloat(box.style.top);

        selectedBoxes.forEach(b => {
          const left = parseFloat(b.style.left) + dx;
          const top = parseFloat(b.style.top) + dy;
          b.style.left = left + 'px';
          b.style.top = top + 'px';
        });
        drawConnections();
      }

      function onDragEnd() {
        window.removeEventListener('pointermove', onDragMove);
        window.removeEventListener('pointerup', onDragEnd);
      }

      window.addEventListener('pointermove', onDragMove);
      window.addEventListener('pointerup', onDragEnd);
    }

    box.addEventListener('pointerdown', e => {
      if (e.shiftKey && e.target.closest('.box-header')) {
        e.preventDefault();
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      }
    });

    box.addEventListener('pointerdown', onDragStart);

    // Resize
    box.querySelectorAll('.resize-handle').forEach(handle => {
      let startX, startY, startWidth, startHeight;
      function onResizeStart(e) {
        if (!editMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        startWidth = box.offsetWidth;
        startHeight = box.offsetHeight;
        const corner = handle.classList[1];

        function onResizeMove(ev) {
          ev.preventDefault();
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          if (corner === 'nw') {
            const newWidth = startWidth - dx;
            const newHeight = startHeight - dy;
            if (newWidth > 40) {
              box.style.width = newWidth + 'px';
              box.style.left = (parseFloat(box.style.left) + dx / scale) + 'px';
            }
            if (newHeight > 30) {
              box.style.height = newHeight + 'px';
              box.style.top = (parseFloat(box.style.top) + dy / scale) + 'px';
            }
          } else if (corner === 'ne') {
            const newWidth = startWidth + dx;
            const newHeight = startHeight - dy;
            if (newWidth > 40) {
              box.style.width = newWidth + 'px';
            }
            if (newHeight > 30) {
              box.style.height = newHeight + 'px';
              box.style.top = (parseFloat(box.style.top) + dy / scale) + 'px';
            }
          } else if (corner === 'sw') {
            const newWidth = startWidth - dx;
            const newHeight = startHeight + dy;
            if (newWidth > 40) {
              box.style.width = newWidth + 'px';
              box.style.left = (parseFloat(box.style.left) + dx / scale) + 'px';
            }
            if (newHeight > 30) {
              box.style.height = newHeight + 'px';
            }
          } else if (corner === 'se') {
            const newWidth = startWidth + dx;
            const newHeight = startHeight + dy;
            if (newWidth > 40) {
              box.style.width = newWidth + 'px';
            }
            if (newHeight > 30) {
              box.style.height = newHeight + 'px';
            }
          }
          drawConnections();
        }
        function onResizeEnd() {
          window.removeEventListener('pointermove', onResizeMove);
          window.removeEventListener('pointerup', onResizeEnd);
        }
        window.addEventListener('pointermove', onResizeMove);
        window.addEventListener('pointerup', onResizeEnd);
      }
      handle.addEventListener('pointerdown', onResizeStart);
    });

    // Font size buttons
    plusBtn.addEventListener('click', e => {
      e.stopPropagation();
      let currentSize = parseInt(content.style.fontSize);
      if (currentSize < 72) {
        content.style.fontSize = (currentSize + 1) + 'px';
      }
    });
    minusBtn.addEventListener('click', e => {
      e.stopPropagation();
      let currentSize = parseInt(content.style.fontSize);
      if (currentSize > 8) {
        content.style.fontSize = (currentSize - 1) + 'px';
      }
    });

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (!connectionStartBoxId) {
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else if (connectionStartBoxId === id) {
        // cancel connection
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        // create connection
        connections.push({ fromId: connectionStartBoxId, toId: id });
        const startBox = boxesMap.get(connectionStartBoxId);
        if (startBox) {
          const startToggle = startBox.querySelector('.connect-toggle');
          startToggle.classList.remove('active');
        }
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
        drawConnections();
      }
    });

    // Delete button
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      undoStack.push({
        id: id,
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        text: content.textContent,
        fontSize: parseInt(content.style.fontSize),
        width: box.offsetWidth,
        height: box.offsetHeight
      });
      undoBtn.disabled = false;

      // Remove any connections related to this box
      for (let i = connections.length - 1; i >= 0; i--) {
        if (connections[i].fromId === id || connections[i].toId === id) {
          connections.splice(i, 1);
        }
      }
      boxesMap.delete(id);
      box.remove();
      drawConnections();
    });

    // Content changes update
    content.addEventListener('input', () => {
      drawConnections();
    });

    return box;
  }

  function addBox(x, y) {
    const id = 'box-' + Date.now() + '-' + Math.floor(Math.random() * 10000);
    createBoxElement(id, x, y);
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const data = undoStack.pop();
    createBoxElement(data.id, data.x, data.y, data.text, data.fontSize, data.width, data.height);
    undoBtn.disabled = undoStack.length === 0;
    drawConnections();
  });

  // Save/load to Firebase
  async function saveToFirebase() {
    const docRef = doc(db, 'stringsnthings', 'state');
    // Prepare data
    const boxData = [];
    boxesMap.forEach(box => {
      const id = box.dataset.id;
      const content = box.querySelector('.box-content').textContent;
      const fontSize = parseInt(box.querySelector('.box-content').style.fontSize);
      boxData.push({
        id,
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        text: content,
        fontSize,
        width: box.offsetWidth,
        height: box.offsetHeight
      });
    });
    try {
      await setDoc(docRef, {
        boxes: boxData,
        connections: connections,
        center: getSavedCenter()
      });
      alert('Save successful');
    } catch (e) {
      alert('Save failed: ' + e.message);
    }
  }

  async function loadFromFirebase() {
    const docRef = doc(db, 'stringsnthings', 'state');
    try {
      const docSnap = await getDoc(docRef);
      if (docSnap.exists()) {
        clearAllBoxes();
        const data = docSnap.data();
        if (data.boxes && Array.isArray(data.boxes)) {
          data.boxes.forEach(box => {
            createBoxElement(box.id, box.x, box.y, box.text, box.fontSize, box.width, box.height);
          });
        }
        connections.length = 0;
        if (data.connections && Array.isArray(data.connections)) {
          data.connections.forEach(conn => {
            if (conn.fromId && conn.toId) {
              connections.push(conn);
            }
          });
        }
        if (data.center) {
          saveCenter(data.center.x, data.center.y, false);
          panX = window.innerWidth / 2 - data.center.x * scale;
          panY = window.innerHeight / 2 - data.center.y * scale;
        }
        updateTransform();
        drawConnections();
        alert('Load successful');
      } else {
        alert('No saved data found.');
      }
    } catch (e) {
      alert('Load failed: ' + e.message);
    }
  }

  function clearAllBoxes() {
    boxesMap.forEach(box => box.remove());
    boxesMap.clear();
    connections.length = 0;
    drawConnections();
  }

  function saveCenter(x, y, saveLocal = true) {
    if (saveLocal) localStorage.setItem('markedCenter', JSON.stringify({ x, y }));
    // Save to Firebase
    const centerDoc = doc(db, 'stringsnthings', 'center');
    setDoc(centerDoc, { x, y }).catch(e => console.warn('Center save failed:', e));
  }

  function getSavedCenter() {
    const savedCenter = localStorage.getItem('markedCenter');
    if (savedCenter) {
      return JSON.parse(savedCenter);
    }
    return { x: 0, y: 0 };
  }

  saveBtn.addEventListener('click', saveToFirebase);
  loadBtn.addEventListener('click', loadFromFirebase);

  // On load: load saved center and go there
  window.addEventListener('load', () => {
    const center = getSavedCenter();
    panX = window.innerWidth / 2 - center.x * scale;
    panY = window.innerHeight / 2 - center.y * scale;
    updateTransform();
    drawConnections();
  });

</script>
</body>
</html>
