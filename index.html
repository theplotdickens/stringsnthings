<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>stringsnthingsV2</title>
<style>
  html, body {
    height: 100%;
    margin: 0; padding: 0;
    font-family: Arial, sans-serif;
  }
  #viewport {
    position: relative;
    width: 100vw;
    height: 90vh;
    overflow: hidden;
    background: #f0f0f0;
    cursor: grab;
  }
  #canvas {
    position: absolute;
    left: 0; top: 0;
  }
  .box {
    position: absolute;
    background: #fff;
    border: 1px solid #ccc;
    box-shadow: 0 0 4px rgba(0,0,0,0.1);
    min-width: 60px;
    min-height: 30px;
    display: flex;
    flex-direction: column;
    user-select: text;
  }
  .box-header {
    background: #ddd;
    padding: 2px 4px;
    display: flex;
    align-items: center;
    cursor: default;
  }
  .drag-handle {
    cursor: grab;
    margin-right: 6px;
    user-select: none;
    font-weight: bold;
  }
  .connect-toggle, .font-size-btn, .delete-btn {
    margin-left: 4px;
    cursor: pointer;
  }
  .box-content {
    flex-grow: 1;
    padding: 6px;
    overflow-wrap: break-word;
    outline: none;
  }
  .resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #999;
    opacity: 0.5;
    cursor: nwse-resize;
  }
  .resize-handle.nw { top: -5px; left: -5px; cursor: nwse-resize; }
  .resize-handle.ne { top: -5px; right: -5px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -5px; left: -5px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -5px; right: -5px; cursor: nwse-resize; }

  #controls {
    display: flex;
    flex-wrap: wrap;
    padding: 8px;
    background: #eee;
    gap: 6px;
  }
  #controls > * {
    padding: 6px 10px;
    cursor: pointer;
  }
  select, button {
    font-size: 14px;
  }
  #status {
    margin-left: auto;
    font-style: italic;
    color: #444;
  }
  svg {
    position: absolute;
    pointer-events: none;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
  }
</style>
<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
</head>
<body>
  <div id="controls">
    <button id="newMapBtn" title="Create new map">New Map</button>
    <select id="mapSelect" aria-label="Select Map"></select>
    <button id="saveBtn" title="Save current map">Save</button>
    <button id="deleteBtn" title="Delete current map">Delete</button>
    <button id="renameBtn" title="Rename current map">Rename</button>
    <button id="undoBtn" title="Undo last delete" disabled>Undo</button>
    <button id="toggleEditModeBtn" title="Toggle Edit/View mode">Toggle Edit Mode</button>
    <button id="goCenterBtn" title="Go to center">Go Center</button>
    <button id="markCenterBtn" title="Mark current center">Mark Center</button>
    <div id="status" aria-live="polite" aria-atomic="true"></div>
  </div>
  <div id="viewport" tabindex="0" aria-label="Main canvas viewport">
    <div id="canvas" role="list"></div>
    <svg id="connectionsSvg"></svg>
  </div>

<script>
(() => {
  // Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // Elements
  const viewport = document.getElementById('viewport');
  const canvas = document.getElementById('canvas');
  const connectionsSvg = document.getElementById('connectionsSvg');

  const newMapBtn = document.getElementById('newMapBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveBtn = document.getElementById('saveBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const renameBtn = document.getElementById('renameBtn');
  const undoBtn = document.getElementById('undoBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const statusMessage = document.getElementById('status');

  // State
  let boxes = {};
  let connections = [];
  let undoStack = [];
  let isEditMode = true;
  let scale = 1;
  let panX = 0;
  let panY = 0;
  let centerPosition = {x: 0, y: 0};
  let currentMapName = null;
  let activeConnectionBoxId = null;
  const selectedBoxes = new Set();

  // Utilities
  function generateId() {
    return 'id' + Math.random().toString(36).substr(2, 9);
  }

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    connectionsSvg.style.transform = canvas.style.transform;
  }

  function clearSelection() {
    selectedBoxes.forEach(id => {
      if(boxes[id]) boxes[id].element.classList.remove('selected');
    });
    selectedBoxes.clear();
  }

  function selectBox(id) {
    if (!boxes[id]) return;
    boxes[id].element.classList.add('selected');
    selectedBoxes.add(id);
  }

  function drawConnections() {
    while(connectionsSvg.firstChild) connectionsSvg.removeChild(connectionsSvg.firstChild);
    connections.forEach(conn => {
      const fromBox = boxes[conn.from];
      const toBox = boxes[conn.to];
      if (!fromBox || !toBox) return;

      // Calculate line positions - from center of boxes
      const fromX = fromBox.x + fromBox.width / 2;
      const fromY = fromBox.y + fromBox.height / 2;
      const toX = toBox.x + toBox.width / 2;
      const toY = toBox.y + toBox.height / 2;

      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute('x1', fromX);
      line.setAttribute('y1', fromY);
      line.setAttribute('x2', toX);
      line.setAttribute('y2', toY);
      line.setAttribute('stroke', '#0077cc');
      line.setAttribute('stroke-width', '2');
      connectionsSvg.appendChild(line);
    });
  }

  function createBox(x = 100, y = 100, text = '', id = null, fontSize = 14) {
    if (!id) id = generateId();
    if(boxes[id]) return boxes[id]; // already exists

    const box = {
      id,
      x,
      y,
      width: 150,
      height: 60,
      text,
      fontSize,
      element: null,
      content: null,
      dragHandle: null,
      connectToggle: null,
      deleteBtn: null,
      fontMinus: null,
      fontPlus: null,
    };

    // Create DOM
    const el = document.createElement('div');
    el.className = 'box';
    el.style.left = box.x + 'px';
    el.style.top = box.y + 'px';
    el.style.width = box.width + 'px';
    el.style.height = box.height + 'px';
    el.style.fontSize = box.fontSize + 'px';
    el.setAttribute('data-id', id);
    el.setAttribute('tabindex', '0');
    el.setAttribute('role', 'textbox');
    el.setAttribute('aria-label', 'Text box, editable');

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    // Drag handle "✥"
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Connect toggle
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Toggle connection mode';
    connectToggle.setAttribute('aria-pressed', 'false');
    header.appendChild(connectToggle);

    // Font minus
    const fontMinus = document.createElement('button');
    fontMinus.className = 'font-size-btn';
    fontMinus.title = 'Decrease font size';
    fontMinus.textContent = '−';
    header.appendChild(fontMinus);

    // Font plus
    const fontPlus = document.createElement('button');
    fontPlus.className = 'font-size-btn';
    fontPlus.title = 'Increase font size';
    fontPlus.textContent = '+';
    header.appendChild(fontPlus);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.title = 'Delete box';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    el.appendChild(header);

    // Content editable
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = isEditMode;
    content.spellcheck = false;
    content.textContent = text;
    el.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      el.appendChild(handle);
    });

    // Save refs
    box.element = el;
    box.content = content;
    box.dragHandle = dragHandle;
    box.connectToggle = connectToggle;
    box.deleteBtn = deleteBtn;
    box.fontMinus = fontMinus;
    box.fontPlus = fontPlus;

    canvas.appendChild(el);
    setupBoxEvents(box);
    boxes[id] = box;
    return box;
  }

  function setupBoxEvents(box) {
    const {element, content, dragHandle, connectToggle, deleteBtn, fontMinus, fontPlus} = box;

    // Dragging logic
    let isDragging = false;
    let dragStart = {x: 0, y: 0};
    let dragOrigin = {x: 0, y: 0};

    // Multi-select support on drag handle with shift
    dragHandle.addEventListener('mousedown', e => {
      if (!isEditMode) return;
      e.preventDefault();

      if (e.shiftKey) {
        if (selectedBoxes.has(box.id)) {
          selectedBoxes.delete(box.id);
          element.classList.remove('selected');
        } else {
          selectBox(box.id);
        }
        if (selectedBoxes.size === 0) {
          selectBox(box.id);
        }
      } else {
        if (!selectedBoxes.has(box.id)) {
          clearSelection();
          selectBox(box.id);
        }
        isDragging = true;
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
        dragOrigin.x = panX;
        dragOrigin.y = panY;
        document.body.style.cursor = 'grabbing';
      }
    });

    window.addEventListener('mouseup', e => {
      if (isDragging) {
        isDragging = false;
        document.body.style.cursor = '';
        e.preventDefault();
      }
    });

    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      e.preventDefault();

      const dx = (e.clientX - dragStart.x) / scale;
      const dy = (e.clientY - dragStart.y) / scale;

      selectedBoxes.forEach(id => {
        if (boxes[id]) {
          boxes[id].x += dx;
          boxes[id].y += dy;
          boxes[id].element.style.left = boxes[id].x + 'px';
          boxes[id].element.style.top = boxes[id].y + 'px';
        }
      });
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      drawConnections();
    });

    // Double click focuses content
    element.addEventListener('dblclick', e => {
      if (!isEditMode) return;
      if (e.target === content) return;
      e.preventDefault();
      content.focus();
    });

    // Content input updates text
    content.addEventListener('input', e => {
      box.text = content.textContent;
    });

    // Prevent text selection interference on header clicks except buttons
    element.querySelector('.box-header').addEventListener('mousedown', e => {
      if (e.target !== dragHandle && !e.target.classList.contains('connect-toggle') &&
          !e.target.classList.contains('font-size-btn') && e.target !== deleteBtn) {
        e.stopPropagation();
        e.preventDefault();
        if (!selectedBoxes.has(box.id)) {
          clearSelection();
          selectBox(box.id);
        }
      }
    });

    // Connect toggle button
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!isEditMode) return;

      if (activeConnectionBoxId === null) {
        activeConnectionBoxId = box.id;
        connectToggle.classList.add('active');
        connectToggle.setAttribute('aria-pressed', 'true');
        statusMessage.textContent = 'Select a second box to connect.';
      } else if (activeConnectionBoxId === box.id) {
        activeConnectionBoxId = null;
        connectToggle.classList.remove('active');
        connectToggle.setAttribute('aria-pressed', 'false');
        statusMessage.textContent = '';
      } else {
        connections.push({from: activeConnectionBoxId, to: box.id});
        if (boxes[activeConnectionBoxId]) {
          boxes[activeConnectionBoxId].connectToggle.classList.remove('active');
          boxes[activeConnectionBoxId].connectToggle.setAttribute('aria-pressed', 'false');
        }
        activeConnectionBoxId = null;
        connectToggle.classList.remove('active');
        connectToggle.setAttribute('aria-pressed', 'false');
        drawConnections();
        statusMessage.textContent = 'Connection made.';
        setTimeout(() => { statusMessage.textContent = ''; }, 1500);
      }
    });

    // Delete button
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!isEditMode) return;
      deleteBox(box.id);
    });

    // Font size controls
    fontMinus.addEventListener('click', e => {
      e.stopPropagation();
      if (!isEditMode) return;
      box.fontSize = Math.max(8, box.fontSize - 1);
      box.element.style.fontSize = box.fontSize + 'px';
    });
    fontPlus.addEventListener('click', e => {
      e.stopPropagation();
      if (!isEditMode) return;
      box.fontSize = Math.min(48, box.fontSize + 1);
      box.element.style.fontSize = box.fontSize + 'px';
    });

    // Resize handles
    const resizeHandles = element.querySelectorAll('.resize-handle');
    resizeHandles.forEach(handle => {
      let isResizing = false;
      let startX, startY, startW, startH, startLeft, startTop;

      handle.addEventListener('mousedown', e => {
        if (!isEditMode) return;
        e.stopPropagation();
        e.preventDefault();
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startW = box.width;
        startH = box.height;
        startLeft = box.x;
        startTop = box.y;
        document.body.style.cursor = handle.style.cursor;
      });

      window.addEventListener('mouseup', e => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
        }
      });

      window.addEventListener('mousemove', e => {
        if (!isResizing) return;
        e.preventDefault();

        const dx = (e.clientX - startX) / scale;
        const dy = (e.clientY - startY) / scale;

        if (handle.classList.contains('se')) {
          box.width = Math.max(60, startW + dx);
          box.height = Math.max(30, startH + dy);
        } else if (handle.classList.contains('sw')) {
          box.width = Math.max(60, startW - dx);
          box.height = Math.max(30, startH + dy);
          box.x = startLeft + dx;
        } else if (handle.classList.contains('ne')) {
          box.width = Math.max(60, startW + dx);
          box.height = Math.max(30, startH - dy);
          box.y = startTop + dy;
        } else if (handle.classList.contains('nw')) {
          box.width = Math.max(60, startW - dx);
          box.height = Math.max(30, startH - dy);
          box.x = startLeft + dx;
          box.y = startTop + dy;
        }

        element.style.width = box.width + 'px';
        element.style.height = box.height + 'px';
        element.style.left = box.x + 'px';
        element.style.top = box.y + 'px';
        drawConnections();
      });
    });
  }

  function deleteBox(id) {
    if (!boxes[id]) return;
    const box = boxes[id];
    canvas.removeChild(box.element);
    delete boxes[id];

    // Remove connections related
    connections = connections.filter(c => c.from !== id && c.to !== id);

    undoStack.push({type: 'deleteBox', box: box, connections: [...connections]});
    drawConnections();
    updateStatus('Box deleted.');
  }

  function updateStatus(text) {
    statusMessage.textContent = text;
    setTimeout(() => {
      if (statusMessage.textContent === text) {
        statusMessage.textContent = '';
      }
    }, 1500);
  }

  // Viewport panning
  let isDraggingViewport = false;
  let viewportDragStart = {x:0, y:0};
  let viewportPanStart = {x:0, y:0};

  viewport.addEventListener('mousedown', e => {
    if (!isEditMode) return;
    if (e.target !== viewport) return;
    e.preventDefault();
    isDraggingViewport = true;
    viewportDragStart.x = e.clientX;
    viewportDragStart.y = e.clientY;
    viewportPanStart.x = panX;
    viewportPanStart.y = panY;
    viewport.style.cursor = 'grabbing';
  });
  window.addEventListener('mouseup', e => {
    if (isDraggingViewport) {
      isDraggingViewport = false;
      viewport.style.cursor = 'grab';
    }
  });
  window.addEventListener('mousemove', e => {
    if (!isDraggingViewport) return;
    e.preventDefault();
    const dx = e.clientX - viewportDragStart.x;
    const dy = e.clientY - viewportDragStart.y;
    panX = viewportPanStart.x + dx;
    panY = viewportPanStart.y + dy;
    updateTransform();
  });

  // Zoom with wheel
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    if (!isEditMode) return;

    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const worldX = (mouseX - panX) / scale;
    const worldY = (mouseY - panY) / scale;

    const delta = -e.deltaY * 0.0015;
    let newScale = scale * (1 + delta);
    newScale = Math.min(Math.max(newScale, 0.2), 5);

    panX = mouseX - worldX * newScale;
    panY = mouseY - worldY * newScale;

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Double click empty area creates box
  viewport.addEventListener('dblclick', e => {
    if (!isEditMode) return;
    if (e.target.closest('.box')) return; // ignore double clicks on boxes

    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    const newBox = createBox(x, y, '');
    clearSelection();
    selectBox(newBox.id);
    newBox.content.focus();
  });

  // Save current map
  async function saveMap() {
    if (!currentMapName) {
      updateStatus('No map selected');
      return;
    }
    const data = {
      boxes: {},
      connections,
      center: centerPosition,
      timestamp: Date.now(),
    };
    for (const id in boxes) {
      const b = boxes[id];
      data.boxes[id] = {
        x: b.x,
        y: b.y,
        width: b.width,
        height: b.height,
        text: b.text,
        fontSize: b.fontSize,
      };
    }
    try {
      await db.collection('maps').doc(currentMapName).set(data);
      updateStatus('Map saved');
      loadMapNames(); // refresh list
    } catch(e) {
      updateStatus('Error saving map');
      console.error(e);
    }
  }

  // Load map by name
  async function loadMap(name) {
    if (!name) return;
    try {
      const doc = await db.collection('maps').doc(name).get();
      if (!doc.exists) {
        updateStatus('Map not found');
        return;
      }
      clearCanvas();
      const data = doc.data();
      for (const id in data.boxes) {
        const b = data.boxes[id];
        const box = createBox(b.x, b.y, b.text, id, b.fontSize);
        box.width = b.width;
        box.height = b.height;
        box.element.style.width = b.width + 'px';
        box.element.style.height = b.height + 'px';
      }
      connections = data.connections || [];
      centerPosition = data.center || {x: 0, y: 0};
      updateTransform();
      drawConnections();
      currentMapName = name;
      mapSelect.value = name;
      updateStatus('Map loaded: ' + name);
    } catch(e) {
      updateStatus('Error loading map');
      console.error(e);
    }
  }

  // Load map names for dropdown
  async function loadMapNames() {
    try {
      const snapshot = await db.collection('maps').orderBy('timestamp', 'desc').get();
      mapSelect.innerHTML = '';
      snapshot.forEach(doc => {
        const option = document.createElement('option');
        option.value = doc.id;
        option.textContent = doc.id;
        mapSelect.appendChild(option);
      });
      if (!currentMapName && snapshot.docs.length > 0) {
        loadMap(snapshot.docs[0].id);
      }
    } catch(e) {
      updateStatus('Error loading map list');
      console.error(e);
    }
  }

  // Clear canvas and all boxes
  function clearCanvas() {
    Object.values(boxes).forEach(b => {
      if (b.element.parentNode) b.element.parentNode.removeChild(b.element);
    });
    Object.keys(boxes).forEach(id => delete boxes[id]);
    connections = [];
    clearSelection();
    drawConnections();
  }

  // New map prompt and create empty map
  async function createNewMap() {
    const name = prompt('Enter new map name (unique):');
    if (!name) return;
    const doc = await db.collection('maps').doc(name).get();
    if (doc.exists) {
      alert('Map with that name already exists');
      return;
    }
    clearCanvas();
    currentMapName = name;
    mapSelect.value = name;
    centerPosition = {x: 0, y: 0};
    panX = 0;
    panY = 0;
    scale = 1;
    updateTransform();
    updateStatus('New map created: ' + name);
  }

  // Delete current map
  async function deleteMap() {
    if (!currentMapName) {
      updateStatus('No map selected');
      return;
    }
    if (!confirm(`Delete map "${currentMapName}"? This cannot be undone.`)) return;
    try {
      await db.collection('maps').doc(currentMapName).delete();
      clearCanvas();
      currentMapName = null;
      loadMapNames();
      updateStatus('Map deleted');
    } catch(e) {
      updateStatus('Error deleting map');
      console.error(e);
    }
  }

  // Rename current map
  async function renameMap() {
    if (!currentMapName) {
      updateStatus('No map selected');
      return;
    }
    const newName = prompt('Enter new name for map:', currentMapName);
    if (!newName || newName === currentMapName) return;

    const existingDoc = await db.collection('maps').doc(newName).get();
    if (existingDoc.exists) {
      alert('Name already taken');
      return;
    }
    try {
      const doc = await db.collection('maps').doc(currentMapName).get();
      if (!doc.exists) return;
      await db.collection('maps').doc(newName).set(doc.data());
      await db.collection('maps').doc(currentMapName).delete();
      currentMapName = newName;
      loadMapNames();
      mapSelect.value = newName;
      updateStatus('Map renamed');
    } catch(e) {
      updateStatus('Error renaming map');
      console.error(e);
    }
  }

  // Undo last delete - only box deletions for now
  function undoDelete() {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    if (last.type === 'deleteBox') {
      const b = last.box;
      boxes[b.id] = b;
      canvas.appendChild(b.element);
      drawConnections();
      updateStatus('Undo delete');
    }
  }

  // Toggle edit mode
  function toggleEditMode() {
    isEditMode = !isEditMode;
    Object.values(boxes).forEach(box => {
      box.content.contentEditable = isEditMode;
      box.connectToggle.disabled = !isEditMode;
      box.deleteBtn.disabled = !isEditMode;
      box.fontMinus.disabled = !isEditMode;
      box.fontPlus.disabled = !isEditMode;
      // Show/hide resize handles
      const resizeHandles = box.element.querySelectorAll('.resize-handle');
      resizeHandles.forEach(h => h.style.display = isEditMode ? 'block' : 'none');
    });
    statusMessage.textContent = isEditMode ? 'Edit mode enabled' : 'View mode enabled';
    setTimeout(() => statusMessage.textContent = '', 1500);
  }

  // Go to center position
  function goToCenter() {
    panX = -centerPosition.x * scale + viewport.clientWidth / 2;
    panY = -centerPosition.y * scale + viewport.clientHeight / 2;
    updateTransform();
  }

  // Mark center position as current viewport center
  function markCenter() {
    centerPosition.x = (-panX + viewport.clientWidth / 2) / scale;
    centerPosition.y = (-panY + viewport.clientHeight / 2) / scale;
    updateStatus('Center marked');
  }

  // Event listeners
  newMapBtn.addEventListener('click', createNewMap);
  mapSelect.addEventListener('change', e => {
    if (mapSelect.value) {
      loadMap(mapSelect.value);
    }
  });
  saveBtn.addEventListener('click', saveMap);
  deleteBtn.addEventListener('click', deleteMap);
  renameBtn.addEventListener('click', renameMap);
  undoBtn.addEventListener('click', undoDelete);
  toggleEditModeBtn.addEventListener('click', toggleEditMode);
  goCenterBtn.addEventListener('click', goToCenter);
  markCenterBtn.addEventListener('click', markCenter);

  // Keyboard shortcuts for undo
  window.addEventListener('keydown', e => {
    if (!isEditMode) return;
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
      undoDelete();
      e.preventDefault();
    }
  });

  // Initialization
  function init() {
    viewport.style.cursor = 'grab';
    updateTransform();
    toggleEditMode(); // sets edit mode and enables contenteditable etc.
    loadMapNames();
  }
  init();
})();
</script>
</body>
</html>
