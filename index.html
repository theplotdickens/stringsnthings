<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings with Curvy Lines + Undo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
  }
  #canvas {
    position: absolute; top: 0; left: 0; transform-origin: 0 0;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    padding: 8px;
    min-width: 80px;
    min-height: 40px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    user-select: text;
    touch-action: none;
    cursor: text;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    z-index: 10;
  }
  .box > div[contenteditable="true"] {
    outline: none;
    white-space: pre-wrap;
    word-break: break-word;
    font-family: monospace, monospace;
    user-select: text;
    cursor: text;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: 1.2;
  }
  .delete-btn {
    position: absolute;
    top: 2px; right: 4px;
    cursor: pointer;
    color: red;
    font-weight: bold;
    user-select: none;
    pointer-events: auto;
    z-index: 20;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn.active {
    background: rgba(50, 150, 200, 0.8);
    color: white;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }

  /* SVG styling */
  #lineLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    overflow: visible;
    z-index: 5;
  }
  .line-path {
    fill: none;
    stroke: black;
    stroke-width: 2;
  }
  .line-label {
    font-family: monospace, monospace;
    font-size: 14px;
    fill: black;
    pointer-events: none;
    user-select: none;
  }
</style>
</head>
<body>
<div id="viewport">
  <svg id="lineLayer"></svg>
  <div id="canvas"></div>
</div>

<div id="buttonContainer">
  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
  <button id="undoLineBtn" class="floatingBtn" disabled>Undo Line</button>
  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
  <button id="drawLineToggle" class="floatingBtn">Draw Line OFF</button>
</div>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.firebasestorage.app",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const lineLayer = document.getElementById('lineLayer');

  const undoBtn = document.getElementById('undoBtn');
  const undoLineBtn = document.getElementById('undoLineBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const drawLineToggle = document.getElementById('drawLineToggle');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;
  const undoStack = [];
  const undoLineStack = [];

  let drawLineMode = false;
  let selectedBoxes = [];
  let currentPathPoints = [];
  let isDrawingPath = false;

  const boxesCollection = db.collection('boxes');
  const linesCollection = db.collection('lines');

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    lineLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (drawLineMode) return; // no pan when drawing lines
    if (e.target.closest('.box') || e.target === goCenterBtn || e.target === undoBtn || e.target === undoLineBtn || e.target === drawLineToggle) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
  });
  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });
  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    scale *= dir;
    updateTransform();
  });

  // Box dragging variables
  const draggingInfo = {
    dragging: false,
    offsetX: 0,
    offsetY: 0,
    currentBox: null,
  };

  // Map box element => firestore doc id
  const idMap = new Map();
  // Map line doc id => {path, label, startBoxId, endBoxId, svg elements}
  const linesMap = new Map();

  function adjustFontSizeToFit(contentDiv, box) {
    const padding = 8;
    const maxFontSize = 100;
    const minFontSize = 8;
    contentDiv.style.fontSize = maxFontSize + 'px';
    const boxWidth = box.clientWidth - padding * 2;
    const boxHeight = box.clientHeight - padding * 2;
    let fontSize = maxFontSize;
    while (fontSize >= minFontSize) {
      contentDiv.style.fontSize = fontSize + 'px';
      if (contentDiv.scrollWidth <= boxWidth && contentDiv.scrollHeight <= boxHeight) break;
      fontSize -= 1;
    }
    if (fontSize < minFontSize) fontSize = minFontSize;
    contentDiv.style.fontSize = fontSize + 'px';
  }

  function addBox(x, y, text = 'Text box', id = null, width=180, height=80, fontSize='16px') {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = width + 'px';
    box.style.height = height + 'px';

    const content = document.createElement('div');
    content.contentEditable = true;
    content.style.minWidth = '80px';
    content.style.minHeight = '24px';
    content.style.whiteSpace = 'pre-wrap';
    content.style.wordBreak = 'break-word';
    content.style.outline = 'none';
    content.style.fontFamily = 'monospace, monospace';
    content.textContent = text;
    content.style.userSelect = 'text';
    content.style.cursor = 'text';
    content.style.height = '100%';
    content.style.width = '100%';
    content.style.boxSizing = 'border-box';
    content.style.padding = '0';
    content.style.margin = '0';
    content.style.overflow = 'visible';
    content.style.lineHeight = '1.2';
    content.style.fontSize = fontSize || '16px';

    if (fontSize === '16px' || !fontSize) {
      adjustFontSizeToFit(content, box);
    }

    content.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.execCommand('insertHTML', false, '\n');
      }
    });

    const delBtn = document.createElement('span');
    delBtn.className = 'delete-btn';
    delBtn.textContent = 'Ã—';

    box.appendChild(content);
    box.appendChild(delBtn);

    // Add 4 invisible corner resize handles
    const corners = ['nw', 'ne', 'sw', 'se'];
    corners.forEach(corner => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + corner;
      box.appendChild(handle);

      handle.addEventListener('pointerdown', e => {
        e.stopPropagation();
        startResizing(e, box, corner);
      });
    });

    // Dragging logic
    box.addEventListener('pointerdown', e => {
      if (e.target === delBtn) return;
      if (drawLineMode) {
        e.stopPropagation();
        handleBoxSelection(box);
        return;
      }
      if (drawLineMode) return; // no drag when drawing lines
      draggingInfo.dragging = true;
      draggingInfo.offsetX = e.clientX - box.getBoundingClientRect().left;
      draggingInfo.offsetY = e.clientY - box.getBoundingClientRect().top;
      draggingInfo.currentBox = box;
      box.setPointerCapture(e.pointerId);
      box.style.cursor = 'grabbing';
    });
    box.addEventListener('pointermove', e => {
      if (!draggingInfo.dragging || draggingInfo.currentBox !== box) return;
      const newX = (e.clientX - draggingInfo.offsetX - panX) / scale;
      const newY = (e.clientY - draggingInfo.offsetY - panY) / scale;
      box.style.left = `${newX}px`;
      box.style.top = `${newY}px`;
      saveBox(box);
      updateLinesForBox(idMap.get(box));
    });
    box.addEventListener('pointerup', e => {
      if (draggingInfo.currentBox === box) {
        draggingInfo.dragging = false;
        draggingInfo.currentBox.style.cursor = 'text';
        draggingInfo.currentBox.releasePointerCapture(e.pointerId);
        draggingInfo.currentBox = null;
      }
    });

    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      undoStack.push({
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        text: content.textContent,
        width: box.offsetWidth,
        height: box.offsetHeight,
        fontSize: content.style.fontSize,
        id: idMap.get(box)
      });
      if (undoStack.length > 5) undoStack.shift();
      undoBtn.disabled = false;
      if (idMap.has(box)) {
        removeLinesForBox(idMap.get(box));
        boxesCollection.doc(idMap.get(box)).delete();
      }
      box.remove();
    });

    content.addEventListener('input', () => {
      adjustFontSizeToFit(content, box);
      saveBox(box);
    });

    function saveBox(boxElement) {
      const data = {
        x: parseFloat(boxElement.style.left),
        y: parseFloat(boxElement.style.top),
        width: boxElement.offsetWidth,
        height: boxElement.offsetHeight,
        text: boxElement.querySelector('div[contenteditable]').textContent,
        fontSize: boxElement.querySelector('div[contenteditable]').style.fontSize || '16px'
      };
      const boxId = idMap.get(boxElement);
      if (boxId) {
        boxesCollection.doc(boxId).set(data);
      } else {
        boxesCollection.add(data).then(docRef => {
          idMap.set(boxElement, docRef.id);
        });
      }
    }

    canvas.appendChild(box);
    if (!id) {
      boxesCollection.add({
        x, y, width, height,
        text, fontSize
      }).then(docRef => {
        idMap.set(box, docRef.id);
      });
    } else {
      idMap.set(box, id);
    }

    return box;
  }

  // Resize logic for corners
  let resizing = false;
  let resizeCorner = null;
  let resizeBox = null;
  let resizeStartX = 0;
  let resizeStartY = 0;
  let resizeStartWidth = 0;
  let resizeStartHeight = 0;
  let resizeStartLeft = 0;
  let resizeStartTop = 0;

  function startResizing(e, box, corner) {
    resizing = true;
    resizeCorner = corner;
    resizeBox = box;
    resizeStartX = e.clientX;
    resizeStartY = e.clientY;
    resizeStartWidth = box.offsetWidth;
    resizeStartHeight = box.offsetHeight;
    resizeStartLeft = parseFloat(box.style.left);
    resizeStartTop = parseFloat(box.style.top);

    window.addEventListener('pointermove', resizePointerMove);
    window.addEventListener('pointerup', resizePointerUp);

    box.setPointerCapture(e.pointerId);
    e.preventDefault();
  }

  function resizePointerMove(e) {
    if (!resizing) return;

    let dx = (e.clientX - resizeStartX) / scale;
    let dy = (e.clientY - resizeStartY) / scale;

    let newWidth = resizeStartWidth;
    let newHeight = resizeStartHeight;
    let newLeft = resizeStartLeft;
    let newTop = resizeStartTop;

    switch (resizeCorner) {
      case 'nw':
        newWidth = resizeStartWidth - dx;
        newHeight = resizeStartHeight - dy;
        newLeft = resizeStartLeft + dx;
        newTop = resizeStartTop + dy;
        break;
      case 'ne':
        newWidth = resizeStartWidth + dx;
        newHeight = resizeStartHeight - dy;
        newTop = resizeStartTop + dy;
        break;
      case 'sw':
        newWidth = resizeStartWidth - dx;
        newHeight = resizeStartHeight + dy;
        newLeft = resizeStartLeft + dx;
        break;
      case 'se':
        newWidth = resizeStartWidth + dx;
        newHeight = resizeStartHeight + dy;
        break;
    }

    // Enforce minimum sizes
    newWidth = Math.max(newWidth, 80);
    newHeight = Math.max(newHeight, 40);

    resizeBox.style.width = newWidth + 'px';
    resizeBox.style.height = newHeight + 'px';
    resizeBox.style.left = newLeft + 'px';
    resizeBox.style.top = newTop + 'px';

    // Update font size & save box
    const contentDiv = resizeBox.querySelector('div[contenteditable]');
    adjustFontSizeToFit(contentDiv, resizeBox);
    saveBox(resizeBox);
    updateLinesForBox(idMap.get(resizeBox));
  }

  function resizePointerUp(e) {
    resizing = false;
    resizeCorner = null;
    resizeBox = null;
    window.removeEventListener('pointermove', resizePointerMove);
    window.removeEventListener('pointerup', resizePointerUp);
  }

  // Undo buttons
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastBox = undoStack.pop();
    addBox(lastBox.x, lastBox.y, lastBox.text, null, lastBox.width, lastBox.height, lastBox.fontSize);
    if (undoStack.length === 0) undoBtn.disabled = true;
  });

  // TODO: Lines logic, undoLineBtn, drawLineToggle, updateLinesForBox, removeLinesForBox, etc.
  // Placeholder for those functions - You can integrate your existing logic here.

  // Go to center button logic
  goCenterBtn.addEventListener('click', () => {
    panX = window.innerWidth / 2 - 200;
    panY = window.innerHeight / 2 - 100;
    scale = 1;
    updateTransform();
  });

  // Draw line toggle button
  drawLineToggle.addEventListener('click', () => {
    drawLineMode = !drawLineMode;
    drawLineToggle.textContent = drawLineMode ? 'Draw Line ON' : 'Draw Line OFF';
  });

  // Initialize
  updateTransform();

  // Load boxes from Firebase
  boxesCollection.get().then(snapshot => {
    snapshot.forEach(doc => {
      const data = doc.data();
      addBox(data.x, data.y, data.text, doc.id, data.width || 180, data.height || 80, data.fontSize || '16px');
    });
  });

  // ... Add your existing line drawing and undo logic here ...
</script>
</body>
</html>
