<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsandthingschangesmore</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  // Double-click to add box

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn,
         saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  // Boxes, connections, undo etc

  function createBoxElement(id, x, y, text = "", fontSize = 14) {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.fontSize = fontSize + 'px';
    box.setAttribute('data-id', id);

    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    dragHandle.title = "Drag box (Shift+click for multi-select)";
    header.appendChild(dragHandle);

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = "Connect to another box";
    header.appendChild(connectToggle);

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = "Delete box";
    header.appendChild(deleteBtn);

    box.appendChild(header);

    const content = document.createElement('div');
    content.className = 'box-content';
    content.spellcheck = false;
    content.textContent = text;
    content.style.fontSize = fontSize + 'px';
    content.contentEditable = editMode;
    box.appendChild(content);

    ['nw','ne','sw','se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = `resize-handle ${pos}`;
      box.appendChild(handle);
    });

    // Dragging
    let dragStartX, dragStartY, boxStartX, boxStartY;
    let multiDrag = false;

    function onPointerDown(e) {
      if (e.button !== 0) return;
      if (!editMode) return;

      if (e.target === content) {
        // Allow editing text; do nothing here
        return;
      }

      if (e.target === connectToggle || e.target === deleteBtn || e.target.classList.contains('resize-handle')) return;

      if (!e.shiftKey) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        box.classList.add('selected');
        selectedBoxes.add(box);
      } else {
        if (selectedBoxes.has(box)) {
          box.classList.remove('selected');
          selectedBoxes.delete(box);
        } else {
          box.classList.add('selected');
          selectedBoxes.add(box);
        }
      }

      if (e.target === dragHandle) {
        multiDrag = selectedBoxes.size > 1 && selectedBoxes.has(box);
      } else {
        multiDrag = false;
      }

      dragStartX = e.clientX;
      dragStartY = e.clientY;
      boxStartX = parseFloat(box.style.left);
      boxStartY = parseFloat(box.style.top);

      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      e.preventDefault();
    }

    function onPointerMove(e) {
      const dx = (e.clientX - dragStartX) / scale;
      const dy = (e.clientY - dragStartY) / scale;
      if (multiDrag) {
        selectedBoxes.forEach(b => {
          const startX = parseFloat(b.style.left);
          const startY = parseFloat(b.style.top);
          b.style.left = (startX + dx) + 'px';
          b.style.top = (startY + dy) + 'px';
        });
      } else {
        box.style.left = (boxStartX + dx) + 'px';
        box.style.top = (boxStartY + dy) + 'px';
      }
      drawConnections();
    }

    function onPointerUp(e) {
      window.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
      multiDrag = false;
      saveCurrentMap();
    }

    dragHandle.addEventListener('pointerdown', onPointerDown);
    box.addEventListener('pointerdown', onPointerDown);

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (connectionStartBoxId) {
        // Create connection
        if (connectionStartBoxId !== id) {
          connections.push({ from: connectionStartBoxId, to: id, label: "" });
          saveCurrentMap();
        }
        clearConnectionToggles();
        connectionStartBoxId = null;
        drawConnections();
      } else {
        connectionStartBoxId = id;
        clearConnectionToggles();
        connectToggle.classList.add('active');
      }
    });

    // Delete button
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      undoStack.push({ boxes: Array.from(boxesMap.values()).map(b => serializeBox(b)),
                       connections: connections.map(c => ({...c})),
                       panX, panY, scale, currentMapId });
      removeBox(id);
      saveCurrentMap();
      updateUndoButton();
    });

    // Font size controls on header - optional, could be added if you want

    // Resize
    let resizeDir = null;
    let resizeStartX, resizeStartY, resizeStartW, resizeStartH;

    function onResizePointerDown(e) {
      if (!editMode) return;
      if (e.button !== 0) return;
      resizeDir = e.target.classList.contains('resize-handle') ? e.target.classList[1] : null;
      if (!resizeDir) return;
      e.stopPropagation();
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      resizeStartW = box.offsetWidth;
      resizeStartH = box.offsetHeight;

      window.addEventListener('pointermove', onResizePointerMove);
      window.addEventListener('pointerup', onResizePointerUp);
    }

    function onResizePointerMove(e) {
      const dx = (e.clientX - resizeStartX) / scale;
      const dy = (e.clientY - resizeStartY) / scale;
      let newW = resizeStartW;
      let newH = resizeStartH;
      let newX = parseFloat(box.style.left);
      let newY = parseFloat(box.style.top);

      if (resizeDir.includes('e')) newW = Math.max(40, resizeStartW + dx);
      if (resizeDir.includes('s')) newH = Math.max(24, resizeStartH + dy);
      if (resizeDir.includes('w')) {
        newW = Math.max(40, resizeStartW - dx);
        newX = parseFloat(box.style.left) + dx;
      }
      if (resizeDir.includes('n')) {
        newH = Math.max(24, resizeStartH - dy);
        newY = parseFloat(box.style.top) + dy;
      }
      box.style.width = newW + 'px';
      box.style.height = newH + 'px';
      box.style.left = newX + 'px';
      box.style.top = newY + 'px';
      drawConnections();
    }

    function onResizePointerUp(e) {
      window.removeEventListener('pointermove', onResizePointerMove);
      window.removeEventListener('pointerup', onResizePointerUp);
      saveCurrentMap();
    }

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', onResizePointerDown);
    });

    // Content change save debounce
    let contentChangeTimeout = null;
    content.addEventListener('input', () => {
      if (contentChangeTimeout) clearTimeout(contentChangeTimeout);
      contentChangeTimeout = setTimeout(() => {
        saveCurrentMap();
      }, 500);
    });

    // Store box element in boxesMap
    boxesMap.set(id, box);

    return box;
  }

  // Serialization and deserialization helpers

  function serializeBox(box) {
    return {
      id: box.getAttribute('data-id'),
      x: parseFloat(box.style.left),
      y: parseFloat(box.style.top),
      text: box.querySelector('.box-content').textContent,
      fontSize: parseFloat(box.style.fontSize) || 14,
      width: box.offsetWidth,
      height: box.offsetHeight,
    };
  }

  // Add a new box

  function addBox(x, y) {
    if (!editMode) return;
    const id = generateId();
    const box = createBoxElement(id, x, y);
    canvas.appendChild(box);
    saveCurrentMap();
  }

  // Remove a box by id, also remove related connections

  function removeBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    box.remove();
    boxesMap.delete(id);
    // Remove connections from or to this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    drawConnections();
  }

  // Draw all connections

  function drawConnections() {
    const svgNS = "http://www.w3.org/2000/svg";
    while (connectionLayer.firstChild) {
      connectionLayer.removeChild(connectionLayer.firstChild);
    }
    connections.forEach(conn => {
      const fromBox = boxesMap.get(conn.from);
      const toBox = boxesMap.get(conn.to);
      if (!fromBox || !toBox) return;
      const fromRect = fromBox.getBoundingClientRect();
      const toRect = toBox.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      // Calculate positions relative to viewport and adjusted for pan and scale
      const fromX = parseFloat(fromBox.style.left) + fromBox.offsetWidth / 2;
      const fromY = parseFloat(fromBox.style.top) + fromBox.offsetHeight / 2;
      const toX = parseFloat(toBox.style.left) + toBox.offsetWidth / 2;
      const toY = parseFloat(toBox.style.top) + toBox.offsetHeight / 2;

      // Create a simple curved path (quadratic Bezier)
      const path = document.createElementNS(svgNS, "path");
      const dx = toX - fromX;
      const dy = toY - fromY;
      const cx = fromX + dx / 2 + dy / 4;
      const cy = fromY + dy / 2 - dx / 4;

      path.setAttribute("d", `M${fromX},${fromY} Q${cx},${cy} ${toX},${toY}`);
      path.setAttribute("stroke", "black");
      path.setAttribute("stroke-width", "2");
      path.setAttribute("fill", "none");
      connectionLayer.appendChild(path);

      // Label
      if (conn.label && conn.label.trim().length > 0) {
        const textElem = document.createElementNS(svgNS, "text");
        textElem.textContent = conn.label;
        textElem.setAttribute("font-size", "14");
        textElem.setAttribute("fill", "black");
        // Position label at curve midpoint
        textElem.setAttribute("x", cx);
        textElem.setAttribute("y", cy - 5);
        textElem.setAttribute("text-anchor", "middle");
        connectionLayer.appendChild(textElem);
      }
    });
  }

  // Clear connection toggles (all buttons)

  function clearConnectionToggles() {
    document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
  }

  // Undo handling

  function updateUndoButton() {
    undoBtn.disabled = undoStack.length === 0;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const state = undoStack.pop();
    loadMapState(state);
    updateUndoButton();
  });

  // Load a map's full state

  function loadMapState(state) {
    // Clear current
    connections.length = 0;
    boxesMap.forEach(box => box.remove());
    boxesMap.clear();

    // Restore boxes
    state.boxes.forEach(boxData => {
      const box = createBoxElement(boxData.id, boxData.x, boxData.y, boxData.text, boxData.fontSize);
      box.style.width = boxData.width + 'px';
      box.style.height = boxData.height + 'px';
      canvas.appendChild(box);
    });

    // Restore connections
    connections.splice(0, connections.length, ...state.connections);

    // Restore pan/zoom
    panX = state.panX;
    panY = state.panY;
    scale = state.scale;
    currentMapId = state.currentMapId;
    updateTransform();
    drawConnections();
  }

  // Save current map to Firestore

  async function saveCurrentMap() {
    if (!currentMapId) return;
    const boxesData = Array.from(boxesMap.values()).map(serializeBox);
    try {
      await setDoc(doc(db, "mindmaps", currentMapId), {
        boxes: boxesData,
        connections: connections,
        panX, panY, scale,
        updatedAt: Date.now()
      });
      saveStatus.textContent = "Saved " + new Date().toLocaleTimeString();
      saveStatus.style.color = "green";
    } catch (e) {
      saveStatus.textContent = "Save failed";
      saveStatus.style.color = "red";
      console.error(e);
    }
  }

  // Load all maps into the select dropdown

  async function loadMapsList() {
    mapSelect.innerHTML = "";
    try {
      const snapshot = await getDocs(collection(db, "mindmaps"));
      mapsCache.clear();
      snapshot.forEach(docSnap => {
        const data = docSnap.data();
        const mapId = docSnap.id;
        mapsCache.set(mapId, data);
        const option = document.createElement('option');
        option.value = mapId;
        option.textContent = mapId;
        mapSelect.appendChild(option);
      });
      if (mapsCache.size > 0) {
        currentMapId = mapSelect.value = [...mapsCache.keys()][0];
        await loadMap(currentMapId);
      } else {
        createNewMap();
      }
    } catch (e) {
      console.error(e);
      saveStatus.textContent = "Failed to load maps";
      saveStatus.style.color = "red";
    }
  }

  // Load a map by ID

  async function loadMap(mapId) {
    if (!mapId) return;
    try {
      const docSnap = await getDocs(collection(db, "mindmaps"));
      const mapDoc = await importMapFromFirestore(mapId);
      if (!mapDoc) {
        saveStatus.textContent = "Map not found";
        saveStatus.style.color = "red";
        return;
      }
      const data = mapDoc;
      connections.length = 0;
      boxesMap.forEach(box => box.remove());
      boxesMap.clear();

      (data.boxes || []).forEach(boxData => {
        const box = createBoxElement(boxData.id, boxData.x, boxData.y, boxData.text, boxData.fontSize);
        if(boxData.width) box.style.width = boxData.width + 'px';
        if(boxData.height) box.style.height = boxData.height + 'px';
        canvas.appendChild(box);
      });
      connections.push(...(data.connections || []));
      panX = data.panX || 0;
      panY = data.panY || 0;
      scale = data.scale || 1;
      currentMapId = mapId;
      updateTransform();
      drawConnections();
      saveStatus.textContent = "Loaded map";
      saveStatus.style.color = "green";
      undoStack.length = 0;
      updateUndoButton();
    } catch (e) {
      console.error(e);
      saveStatus.textContent = "Load failed";
      saveStatus.style.color = "red";
    }
  }

  async function importMapFromFirestore(id) {
    try {
      const docRef = doc(db, "mindmaps", id);
      const docSnap = await getDocs(collection(db, "mindmaps"));
      const snap = await docRef.get?.() || null;
      if (snap && snap.exists) return snap.data();
      return null;
    } catch (e) {
      console.error(e);
      return null;
    }
  }

  // Create a new map (blank)

  async function createNewMap() {
    const newId = prompt("Enter new map name (unique id):");
    if (!newId) return;
    if (mapsCache.has(newId)) {
      alert("Map with that name already exists!");
      return;
    }
    connections.length = 0;
    boxesMap.forEach(box => box.remove());
    boxesMap.clear();
    panX = 0;
    panY = 0;
    scale = 1;
    currentMapId = newId;
    mapSelect.appendChild(new Option(newId, newId));
    mapSelect.value = newId;
    updateTransform();
    drawConnections();
    saveCurrentMap();
    undoStack.length = 0;
    updateUndoButton();
  }

  // Rename current map

  async function renameCurrentMap() {
    if (!currentMapId) return;
    const newName = prompt("Enter new name for map:", currentMapId);
    if (!newName || newName === currentMapId) return;
    if (mapsCache.has(newName)) {
      alert("Map with that name already exists!");
      return;
    }
    try {
      const oldDoc = doc(db, "mindmaps", currentMapId);
      const newDoc = doc(db, "mindmaps", newName);
      await setDoc(newDoc, {
        boxes: Array.from(boxesMap.values()).map(serializeBox),
        connections: connections,
        panX, panY, scale,
        updatedAt: Date.now()
      });
      await deleteDoc(oldDoc);
      mapsCache.delete(currentMapId);
      mapsCache.set(newName, true);
      currentMapId = newName;
      loadMapsList();
      saveStatus.textContent = "Renamed map";
      saveStatus.style.color = "green";
    } catch(e) {
      console.error(e);
      alert("Rename failed");
    }
  }

  // Delete current map

  async function deleteCurrentMap() {
    if (!currentMapId) return;
    if (!confirm(`Delete map '${currentMapId}'? This cannot be undone.`)) return;
    try {
      await deleteDoc(doc(db, "mindmaps", currentMapId));
      mapsCache.delete(currentMapId);
      currentMapId = null;
      connections.length = 0;
      boxesMap.forEach(box => box.remove());
      boxesMap.clear();
      panX = 0;
      panY = 0;
      scale = 1;
      updateTransform();
      drawConnections();
      loadMapsList();
      saveStatus.textContent = "Deleted map";
      saveStatus.style.color = "green";
    } catch(e) {
      console.error(e);
      alert("Delete failed");
    }
  }

  // Map select change

  mapSelect.addEventListener('change', () => {
    const val = mapSelect.value;
    loadMap(val);
  });

  saveMapBtn.addEventListener('click', saveCurrentMap);
  renameMapBtn.addEventListener('click', renameCurrentMap);
  deleteMapBtn.addEventListener('click', deleteCurrentMap);
  newMapBtn.addEventListener('click', createNewMap);

  // Go to center and mark center

  let markedCenter = { x: 0, y: 0 };

  goCenterBtn.addEventListener('click', () => {
    panX = viewport.clientWidth / 2 - markedCenter.x * scale;
    panY = viewport.clientHeight / 2 - markedCenter.y * scale;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    markedCenter.x = (viewport.clientWidth / 2 - panX) / scale;
    markedCenter.y = (viewport.clientHeight / 2 - panY) / scale;
    alert(`Marked center at (${markedCenter.x.toFixed(2)}, ${markedCenter.y.toFixed(2)})`);
  });

  // Toggle edit mode

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    boxesMap.forEach(box => {
      const content = box.querySelector('.box-content');
      content.contentEditable = editMode;
      box.querySelectorAll('.resize-handle, .connect-toggle, .delete-btn, .drag-handle').forEach(elem => {
        elem.style.display = editMode ? '' : 'none';
      });
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'Edit Disabled';
  });

  // How to use modal

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Initialization

  loadMapsList();

  updateTransform();
  drawConnections();
  updateUndoButton();

  // Save map periodically (every 10 seconds)
  setInterval(() => {
    saveCurrentMap();
  }, 10000);
</script>
</body>
</html>
