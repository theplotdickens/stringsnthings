<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
    user-select: none;
  }
  #canvas {
    position: absolute; top: 0; left: 0; transform-origin: 0 0;
    z-index: 10;
  }
  #connectionLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 5;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    min-width: 80px;
    min-height: 40px;
    user-select: text;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    cursor: text;
    overflow: hidden;
    transition: width 0.1s ease, height 0.1s ease;
  }
  .box.selected {
    border-color: blue;
    box-shadow: 0 0 4px 2px rgba(0,0,255,0.4);
  }
  .box-header {
    background: #ddd;
    padding: 1px 4px;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 4px;
    user-select: none;
    cursor: default;
    border-bottom: 1px solid #bbb;
    font-size: 12px;
    height: 18px;
    box-sizing: border-box;
    flex-shrink: 0;
  }
  .delete-btn {
    color: red;
    font-weight: bold;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    user-select: none;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .connect-toggle {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: none;
    background-color: blue;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.25s ease;
    padding: 0;
    margin: 0;
    flex-shrink: 0;
  }
  .connect-toggle.active {
    background-color: green;
  }
  .box-content {
    flex: 1;
    padding: 6px 8px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    overflow: auto;
    outline: none;
    cursor: text;
    user-select: text;
    font-size: 16px;
    line-height: 1.2;
    min-height: 24px;
    word-break: break-word;
    box-sizing: border-box;
    resize: none;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }
  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }
  #zoomDisplay {
    position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.5); color: white; font-family: monospace;
    padding: 4px 8px; border-radius: 4px;
    user-select: none; pointer-events: none; z-index: 1001;
  }
  #selectionRect {
    position: absolute;
    border: 1px dashed blue;
    background: rgba(0,0,255,0.15);
    pointer-events: none;
    display: none;
    z-index: 50;
  }
</style>
</head>
<body>
  <div id="viewport" tabindex="0">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
    <div id="selectionRect"></div>
  </div>
  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="selectModeBtn" class="floatingBtn">Select Mode: OFF</button>
    <button id="deleteSelectedBtn" class="floatingBtn" disabled>Delete Selected</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
  </div>
  <div id="zoomDisplay">Zoom: 100%</div>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
      authDomain: "stringsnthings-65aa0.firebaseapp.com",
      projectId: "stringsnthings-65aa0",
      storageBucket: "stringsnthings-65aa0.firebasestorage.app",
      messagingSenderId: "35780192306",
      appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    const canvas = document.getElementById('canvas');
    const viewport = document.getElementById('viewport');
    const undoBtn = document.getElementById('undoBtn');
    const selectModeBtn = document.getElementById('selectModeBtn');
    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    const goCenterBtn = document.getElementById('goCenterBtn');
    const markCenterBtn = document.getElementById('markCenterBtn');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const connectionLayer = document.getElementById('connectionLayer');
    const selectionRect = document.getElementById('selectionRect');

    let scale = 1, panX = 0, panY = 0;
    let isPanning = false, startX, startY;

    let undoStack = [];
    let connections = [];
    let selectedBoxes = new Set();
    let selectedConnections = new Set();
    let selectMode = false;

    let draggingBox = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    let resizingBox = null;
    let resizeDir = null;
    let resizeStart = null;

    let connectingBox = null; // box from which a connection is started

    let selectionStart = null;
    let isSelecting = false;

    const boxesCollection = db.collection('boxes');
    const connectionsCollection = db.collection('connections');

    // Utils
    function generateId() {
      return 'id_' + Math.random().toString(36).substr(2, 9);
    }

    // Coordinate helpers for pan/zoom
    function screenToCanvas(x, y) {
      return { x: (x - panX) / scale, y: (y - panY) / scale };
    }

    function canvasToScreen(x, y) {
      return { x: x * scale + panX, y: y * scale + panY };
    }

    // Zoom limits
    const MIN_SCALE = 0.5;
    const MAX_SCALE = 3;

    // Draw all connections
    function drawConnections() {
      connectionLayer.innerHTML = '';
      connections.forEach(({ id, fromId, toId }) => {
        const boxA = document.querySelector(`.box[data-id="${fromId}"]`);
        const boxB = document.querySelector(`.box[data-id="${toId}"]`);
        if (!boxA || !boxB) return;

        const ax = parseFloat(boxA.style.left) + boxA.offsetWidth / 2;
        const ay = parseFloat(boxA.style.top) + boxA.offsetHeight / 2;
        const bx = parseFloat(boxB.style.left) + boxB.offsetWidth / 2;
        const by = parseFloat(boxB.style.top) + boxB.offsetHeight / 2;

        // SVG coordinates with pan/zoom
        const startX = ax * scale + panX;
        const startY = ay * scale + panY;
        const endX = bx * scale + panX;
        const endY = by * scale + panY;

        // Create path element
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        // Quadratic bezier curve control point for curve
        const dx = endX - startX;
        const dy = endY - startY;
        const distance = Math.sqrt(dx*dx + dy*dy);
        if(distance === 0) return; // Prevent division by zero
        const normX = dx / distance;
        const normY = dy / distance;
        const cpOffset = 40; // curve bend

        // Perpendicular vector
        const cpX = (startX + endX) / 2 - normY * cpOffset;
        const cpY = (startY + endY) / 2 + normX * cpOffset;

        path.setAttribute('d', `M${startX},${startY} Q${cpX},${cpY} ${endX},${endY}`);
        path.setAttribute('stroke', selectedConnections.has(id) ? 'blue' : 'black');
        path.setAttribute('stroke-width', selectedConnections.has(id) ? '4' : '2');
        path.setAttribute('fill', 'none');
        path.style.cursor = 'pointer';
        path.dataset.connectionId = id;

        path.addEventListener('click', e => {
          if (!selectMode) return;
          e.stopPropagation();
          if (selectedConnections.has(id)) {
            selectedConnections.delete(id);
          } else {
            selectedConnections.add(id);
          }
          updateDeleteButton();
          drawConnections();
        });

        connectionLayer.appendChild(path);
      });
    }

    // Save all connections to Firestore (overwrite)
    async function saveConnections() {
      // Clear existing connections in DB, then add current connections
      const batch = db.batch();
      const snap = await connectionsCollection.get();
      snap.forEach(doc => batch.delete(doc.ref));
      connections.forEach(conn => {
        const ref = connectionsCollection.doc(conn.id || generateId());
        batch.set(ref, { fromId: conn.fromId, toId: conn.toId });
      });
      await batch.commit();
    }

    // Load connections from Firestore
    async function loadConnections() {
      connections.length = 0;
      const snapshot = await connectionsCollection.get();
      snapshot.forEach(doc => {
        const data = doc.data();
        connections.push({ id: doc.id, fromId: data.fromId, toId: data.toId });
      });
      drawConnections();
    }

    // Smoothly adjust font size inside box content to fit box size
    function smoothAdjustFontSize(contentDiv, box) {
      const padding = 14;
      const maxWidth = box.clientWidth - padding;
      const maxHeight = box.clientHeight - padding;
      let minSize = 8;
      let maxSize = 72;
      let fontSize = 16;
      while (minSize <= maxSize) {
        const mid = Math.floor((minSize + maxSize) / 2);
        contentDiv.style.fontSize = mid + 'px';
        if (contentDiv.scrollWidth <= maxWidth && contentDiv.scrollHeight <= maxHeight) {
          fontSize = mid;
          minSize = mid + 1;
        } else {
          maxSize = mid - 1;
        }
      }
      contentDiv.style.fontSize = fontSize + 'px';
    }

    // Save or update a box in Firestore immediately
    async function saveBox(box, content) {
      if (!box.dataset.id) {
        const docRef = await boxesCollection.add({
          x: parseFloat(box.style.left),
          y: parseFloat(box.style.top),
          text: content.textContent,
          width: box.offsetWidth,
          height: box.offsetHeight,
          fontSize: content.style.fontSize || '16px'
        });
        box.dataset.id = docRef.id;
      } else {
        await boxesCollection.doc(box.dataset.id).set({
          x: parseFloat(box.style.left),
          y: parseFloat(box.style.top),
          text: content.textContent,
          width: box.offsetWidth,
          height: box.offsetHeight,
          fontSize: content.style.fontSize || '16px'
        });
      }
    }

    // Delete a box and its connections immediately
    async function deleteBox(box) {
      if (!box.dataset.id) return;
      undoStack.push({
        box: {
          id: box.dataset.id,
          x: parseFloat(box.style.left),
          y: parseFloat(box.style.top),
          text: box.querySelector('.box-content').textContent,
          width: box.offsetWidth,
          height: box.offsetHeight,
          fontSize: box.querySelector('.box-content').style.fontSize
        },
        connections: connections.filter(c => c.fromId === box.dataset.id || c.toId === box.dataset.id)
      });
      undoBtn.disabled = false;

      // Remove related connections
      for (let i = connections.length -1; i >= 0; i--) {
        if (connections[i].fromId === box.dataset.id || connections[i].toId === box.dataset.id) {
          connections.splice(i, 1);
        }
      }
      await saveConnections();

      // Remove box from Firestore
      await boxesCollection.doc(box.dataset.id).delete();

      box.remove();
      drawConnections();
    }

    // Add a new box, or load existing box
    async function addBox(x, y, text = 'Text box', id = null, width = 180, height = 80, fontSize = '16px') {
      const box = document.createElement('div');
      box.className = 'box';
      box.style.left = x + 'px';
      box.style.top = y + 'px';
      box.style.width = width + 'px';
      box.style.height = height + 'px';
      box.spellcheck = false;

      if (id) box.dataset.id = id;

      const header = document.createElement('div');
      header.className = 'box-header';

      const connectToggle = document.createElement('button');
      connectToggle.className = 'connect-toggle';
      connectToggle.title = 'Connect';

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = '×';

      header.appendChild(connectToggle);
      header.appendChild(delBtn);

      const content = document.createElement('div');
      content.contentEditable = true;
      content.className = 'box-content';
      content.textContent = text;
      content.style.fontSize = fontSize;

      box.appendChild(header);
      box.appendChild(content);

      const handles = {};
      ['nw', 'ne', 'sw', 'se'].forEach(pos => {
        const h = document.createElement('div');
        h.className = 'resize-handle ' + pos;
        box.appendChild(h);
        handles[pos] = h;
      });

      // Drag logic
      box.addEventListener('pointerdown', e => {
        if (selectMode) {
          // Selection logic instead of drag in select mode
          e.stopPropagation();
          if (e.shiftKey) {
            // Multi select toggle
            if (selectedBoxes.has(box)) {
              selectedBoxes.delete(box);
              box.classList.remove('selected');
            } else {
              selectedBoxes.add(box);
              box.classList.add('selected');
            }
          } else {
            // Single select
            clearSelection();
            selectedBoxes.add(box);
            box.classList.add('selected');
          }
          updateDeleteButton();
          return;
        }

        if (e.target === delBtn || e.target === connectToggle || e.target.classList.contains('resize-handle')) return;

        draggingBox = box;
        const rect = box.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        box.style.cursor = 'grabbing';
        box.setPointerCapture(e.pointerId);
        e.preventDefault();
      });

      box.addEventListener('pointermove', e => {
        if (draggingBox !== box) return;
        e.preventDefault();
        const newX = (e.clientX - dragOffsetX - panX) / scale;
        const newY = (e.clientY - dragOffsetY - panY) / scale;
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';
        drawConnections();
      });

      box.addEventListener('pointerup', async e => {
        if (draggingBox !== box) return;
        draggingBox = null;
        box.style.cursor = 'text';
        await saveBox(box, box.querySelector('.box-content'));
      });

      // Resize logic
      Object.entries(handles).forEach(([pos, handle]) => {
        handle.addEventListener('pointerdown', e => {
          e.stopPropagation();
          resizingBox = box;
          resizeDir = pos;
          resizeStart = { x: e.clientX, y: e.clientY, width: box.offsetWidth, height: box.offsetHeight, left: parseFloat(box.style.left), top: parseFloat(box.style.top) };
          box.setPointerCapture(e.pointerId);
          e.preventDefault();
        });
      });

      box.addEventListener('pointermove', e => {
        if (resizingBox !== box) return;
        e.preventDefault();
        const dx = (e.clientX - resizeStart.x) / scale;
        const dy = (e.clientY - resizeStart.y) / scale;
        let newWidth = resizeStart.width;
        let newHeight = resizeStart.height;
        let newLeft = resizeStart.left;
        let newTop = resizeStart.top;

        switch(resizeDir) {
          case 'nw':
            newWidth = resizeStart.width - dx;
            newHeight = resizeStart.height - dy;
            newLeft = resizeStart.left + dx;
            newTop = resizeStart.top + dy;
            break;
          case 'ne':
            newWidth = resizeStart.width + dx;
            newHeight = resizeStart.height - dy;
            newTop = resizeStart.top + dy;
            break;
          case 'sw':
            newWidth = resizeStart.width - dx;
            newHeight = resizeStart.height + dy;
            newLeft = resizeStart.left + dx;
            break;
          case 'se':
            newWidth = resizeStart.width + dx;
            newHeight = resizeStart.height + dy;
            break;
        }
        if (newWidth < 60) newWidth = 60;
        if (newHeight < 40) newHeight = 40;

        box.style.width = newWidth + 'px';
        box.style.height = newHeight + 'px';
        box.style.left = newLeft + 'px';
        box.style.top = newTop + 'px';

        smoothAdjustFontSize(box.querySelector('.box-content'), box);

        drawConnections();
      });

      box.addEventListener('pointerup', async e => {
        if (resizingBox !== box) return;
        resizingBox = null;
        resizeDir = null;
        resizeStart = null;
        await saveBox(box, box.querySelector('.box-content'));
      });

      // Content editable input save & adjust font
      content.addEventListener('input', () => {
        smoothAdjustFontSize(content, box);
        saveBox(box, content);
      });

      // Delete button - no confirmation
      delBtn.addEventListener('click', async e => {
        e.stopPropagation();
        await deleteBox(box);
        selectedBoxes.delete(box);
        updateDeleteButton();
      });

      // Connect toggle logic (no more "must save" alert)
      connectToggle.addEventListener('click', async e => {
        e.stopPropagation();
        if (connectingBox === null) {
          connectingBox = box;
          connectToggle.classList.add('active');
        } else if (connectingBox === box) {
          connectingBox = null;
          connectToggle.classList.remove('active');
        } else {
          // Auto-save boxes if not saved
          if (!connectingBox.dataset.id) {
            await saveBox(connectingBox, connectingBox.querySelector('.box-content'));
          }
          if (!box.dataset.id) {
            await saveBox(box, box.querySelector('.box-content'));
          }
          const fromId = connectingBox.dataset.id;
          const toId = box.dataset.id;
          // Avoid duplicate connections
          const exists = connections.some(c => (c.fromId === fromId && c.toId === toId) || (c.fromId === toId && c.toId === fromId));
          if (!exists) {
            const id = generateId();
            connections.push({ id, fromId, toId });
            await saveConnections();
          }
          document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
          connectingBox = null;
          drawConnections();
        }
      });

      box.addEventListener('click', e => {
        if (!selectMode) return;
        e.stopPropagation();
      });

      canvas.appendChild(box);
      smoothAdjustFontSize(content, box);

      return box;
    }

    // Clear all selections
    function clearSelection() {
      selectedBoxes.forEach(box => box.classList.remove('selected'));
      selectedBoxes.clear();
      selectedConnections.clear();
      updateDeleteButton();
      drawConnections();
    }

    // Update Delete button state
    function updateDeleteButton() {
      deleteSelectedBtn.disabled = (selectedBoxes.size === 0 && selectedConnections.size === 0);
    }

    // Delete selected boxes and connections (no confirm)
    async function deleteSelected() {
      const deletedBoxes = [];
      const deletedConnections = [];

      for (const box of selectedBoxes) {
        deletedBoxes.push({
          id: box.dataset.id,
          x: parseFloat(box.style.left),
          y: parseFloat(box.style.top),
          text: box.querySelector('.box-content').textContent,
          width: box.offsetWidth,
          height: box.offsetHeight,
          fontSize: box.querySelector('.box-content').style.fontSize
        });
      }
      for (const connId of selectedConnections) {
        const c = connections.find(c => c.id === connId);
        if (c) deletedConnections.push(c);
      }

      undoStack.push({ boxes: deletedBoxes, connections: deletedConnections });
      undoBtn.disabled = false;

      for (const box of selectedBoxes) {
        if (box.dataset.id) {
          await boxesCollection.doc(box.dataset.id).delete();
        }
        // Remove connections linked to box
        for (let i = connections.length - 1; i >= 0; i--) {
          if (connections[i].fromId === box.dataset.id || connections[i].toId === box.dataset.id) {
            connections.splice(i, 1);
          }
        }
        box.remove();
      }

      for (const conn of deletedConnections) {
        const idx = connections.findIndex(c => c.id === conn.id);
        if (idx >= 0) connections.splice(idx, 1);
      }
      await saveConnections();

      selectedBoxes.clear();
      selectedConnections.clear();
      updateDeleteButton();
      drawConnections();
    }

    // Undo last delete
    async function undo() {
      if (undoStack.length === 0) return;
      const last = undoStack.pop();
      undoBtn.disabled = undoStack.length === 0;

      if (last.box) {
        const b = last.box;
        const box = await addBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize);
        await saveBox(box, box.querySelector('.box-content'));
        if (last.connections) {
          for (const c of last.connections) {
            connections.push(c);
          }
          await saveConnections();
        }
      } else if (last.boxes) {
        for (const b of last.boxes) {
          const box = await addBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize);
          await saveBox(box, box.querySelector('.box-content'));
        }
        if (last.connections) {
          for (const c of last.connections) {
            connections.push(c);
          }
          await saveConnections();
        }
      }
      drawConnections();
    }

    // Save all boxes
    async function saveAllBoxes() {
      const promises = [];
      document.querySelectorAll('.box').forEach(box => {
        promises.push(saveBox(box, box.querySelector('.box-content')));
      });
      await Promise.all(promises);
    }

    // Load boxes from Firestore
    async function loadBoxes() {
      canvas.innerHTML = '';
      const snapshot = await boxesCollection.get();
      const boxesData = [];
      snapshot.forEach(doc => {
        const d = doc.data();
        boxesData.push({
          id: doc.id,
          x: d.x,
          y: d.y,
          text: d.text,
          width: d.width || 180,
          height: d.height || 80,
          fontSize: d.fontSize || '16px'
        });
      });
      boxesData.forEach(b => addBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize));
    }

    // Select mode toggle
    selectModeBtn.addEventListener('click', () => {
      selectMode = !selectMode;
      selectModeBtn.textContent = 'Select Mode: ' + (selectMode ? 'ON' : 'OFF');
      viewport.style.cursor = selectMode ? 'default' : 'grab';
      clearSelection();
    });

    // Delete selected button no confirm
    deleteSelectedBtn.addEventListener('click', async () => {
      await deleteSelected();
    });

    // Undo button
    undoBtn.addEventListener('click', undo);

    // Pan & zoom handlers
    viewport.addEventListener('pointerdown', e => {
      if (selectMode) return;
      if (e.target.closest('.box') || e.target.closest('button') || e.target === connectionLayer) return;
      isPanning = true;
      startX = e.clientX;
      startY = e.clientY;
      viewport.setPointerCapture(e.pointerId);
      viewport.style.cursor = 'grabbing';
    });

    viewport.addEventListener('pointermove', e => {
      if (!isPanning) return;
      e.preventDefault();
      panX += e.clientX - startX;
      panY += e.clientY - startY;
      startX = e.clientX;
      startY = e.clientY;
      updateTransform();
    });

    viewport.addEventListener('pointerup', e => {
      if (!isPanning) return;
      isPanning = false;
      viewport.style.cursor = selectMode ? 'default' : 'grab';
    });

    viewport.addEventListener('wheel', e => {
      e.preventDefault();
      const oldScale = scale;
      const delta = -e.deltaY * 0.0015;
      scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale + delta));
      const mouseX = e.clientX;
      const mouseY = e.clientY;
      panX -= (mouseX - panX) * (scale / oldScale - 1);
      panY -= (mouseY - panY) * (scale / oldScale - 1);
      updateTransform();
      zoomDisplay.textContent = 'Zoom: ' + Math.round(scale * 100) + '%';
    }, { passive: false });

    // Add box on double click if not select mode
    viewport.addEventListener('dblclick', e => {
      if (selectMode) return;
      const pos = screenToCanvas(e.clientX, e.clientY);
      addBox(pos.x, pos.y);
    });

    // Go to center button
    goCenterBtn.addEventListener('click', () => {
      panX = window.innerWidth / 2;
      panY = window.innerHeight / 2;
      scale = 1;
      updateTransform();
      zoomDisplay.textContent = 'Zoom: 100%';
    });

    // Mark center button - shifts all boxes so current viewport center is canvas origin
    markCenterBtn.addEventListener('click', () => {
      const centerCanvasX = (window.innerWidth / 2 - panX) / scale;
      const centerCanvasY = (window.innerHeight / 2 - panY) / scale;

      document.querySelectorAll('.box').forEach(box => {
        const x = parseFloat(box.style.left);
        const y = parseFloat(box.style.top);
        box.style.left = (x - centerCanvasX) + 'px';
        box.style.top = (y - centerCanvasY) + 'px';
      });

      panX += centerCanvasX * scale;
      panY += centerCanvasY * scale;

      updateTransform();
      saveAllBoxes();
    });

    // Selection rectangle logic
    viewport.addEventListener('pointerdown', e => {
      if (!selectMode) return;
      if (e.target.closest('.box') || e.target.closest('button') || e.target === connectionLayer) return;
      e.preventDefault();
      selectionStart = { x: e.clientX, y: e.clientY };
      selectionRect.style.left = selectionStart.x + 'px';
      selectionRect.style.top = selectionStart.y + 'px';
      selectionRect.style.width = '0px';
      selectionRect.style.height = '0px';
      selectionRect.style.display = 'block';
      isSelecting = true;
    });

    viewport.addEventListener('pointermove', e => {
      if (!isSelecting) return;
      e.preventDefault();
      const x1 = Math.min(selectionStart.x, e.clientX);
      const y1 = Math.min(selectionStart.y, e.clientY);
      const x2 = Math.max(selectionStart.x, e.clientX);
      const y2 = Math.max(selectionStart.y, e.clientY);
      selectionRect.style.left = x1 + 'px';
      selectionRect.style.top = y1 + 'px';
      selectionRect.style.width = (x2 - x1) + 'px';
      selectionRect.style.height = (y2 - y1) + 'px';
    });

    viewport.addEventListener('pointerup', e => {
      if (!isSelecting) return;
      isSelecting = false;
      selectionRect.style.display = 'none';
      const rect = selectionRect.getBoundingClientRect();

      clearSelection();

      document.querySelectorAll('.box').forEach(box => {
        const bRect = box.getBoundingClientRect();
        if (bRect.left >= rect.left && bRect.right <= rect.right && bRect.top >= rect.top && bRect.bottom <= rect.bottom) {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      });

      connections.forEach(c => {
        const boxA = document.querySelector(`.box[data-id="${c.fromId}"]`);
        const boxB = document.querySelector(`.box[data-id="${c.toId}"]`);
        if (!boxA || !boxB) return;
        const ax = boxA.getBoundingClientRect().left + boxA.offsetWidth / 2;
        const ay = boxA.getBoundingClientRect().top + boxA.offsetHeight / 2;
        const bx = boxB.getBoundingClientRect().left + boxB.offsetWidth / 2;
        const by = boxB.getBoundingClientRect().top + boxB.offsetHeight / 2;
        const midX = (ax + bx) / 2;
        const midY = (ay + by) / 2;
        if (midX >= rect.left && midX <= rect.right && midY >= rect.top && midY <= rect.bottom) {
          selectedConnections.add(c.id);
        }
      });

      updateDeleteButton();
      drawConnections();
    });

    // Click outside clears selection in select mode
    viewport.addEventListener('click', e => {
      if (!selectMode) return;
      if (e.target.closest('.box') || e.target.closest('button')) return;
      clearSelection();
    });

    // Update transform on canvas
    function updateTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      drawConnections();
    }

    // Save boxes and connections before unload
    window.addEventListener('beforeunload', () => {
      saveAllBoxes();
      saveConnections();
    });

    // Initialize
    (async function init() {
      await loadBoxes();
      await loadConnections();
      updateTransform();
      zoomDisplay.textContent = 'Zoom: ' + Math.round(scale * 100) + '%';
    })();

  </script>
</body>
</html>
