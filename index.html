<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV6</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: text;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 16px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      user-select: none;
      flex-shrink: 0;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      padding: 6px 12px;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.15);
      font-family: monospace, monospace;
      align-items: center;
    }
    #topMenu select, #topMenu button {
      font-family: monospace, monospace;
      font-size: 14px;
      padding: 4px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      background: white;
    }
    #topMenu button:disabled {
      background: #eee;
      cursor: default;
      color: #999;
      border-color: #999;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #viewport {
      touch-action: none;
    }
    #footerInfo {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #bottomButtons {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="topMenu">
    <select id="mindMapSelect" aria-label="Select mind map"></select>
    <button id="saveMapBtn">Save Map</button>
    <button id="renameMapBtn">Rename Map</button>
    <button id="deleteMapBtn">Delete Map</button>
    <button id="newMapBtn">New Map</button>
  </div>

  <div id="bottomButtons">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the top menu to save, rename, delete, or create new mind maps.
      Selecting a mind map from the dropdown will load it automatically.
      Use the + and – buttons in the box header to increase or decrease font size.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getFirestore, collection, doc, getDoc, getDocs, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mindMapSelect = document.getElementById('mindMapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  viewport.addEventListener('dblclick', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target)) return;
    if (e.target.closest('.box')) return;
    const x = (e.clientX - panX) / scale;
    const y = (e.clientY - panY) / scale;
    addBox(x, y);
  });

  function addBox(x, y, text = '', boxId = null, fontSize = 14, width = 120, height = 60) {
    boxId = boxId || `box-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.style.fontSize = fontSize + 'px';
    box.dataset.id = boxId;

    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.title = 'Drag box';
    dragHandle.textContent = '✥';

    const fontMinusBtn = document.createElement('button');
    fontMinusBtn.className = 'font-size-btn';
    fontMinusBtn.title = 'Decrease font size';
    fontMinusBtn.textContent = '−';

    const fontPlusBtn = document.createElement('button');
    fontPlusBtn.className = 'font-size-btn';
    fontPlusBtn.title = 'Increase font size';
    fontPlusBtn.textContent = '+';

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.title = 'Delete box';
    deleteBtn.textContent = '×';

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect boxes';

    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    content.style.textAlign = 'center';

    // Append in order: drag handle left, then font minus, font plus, delete, connect toggle right
    header.appendChild(dragHandle);
    header.appendChild(fontMinusBtn);
    header.appendChild(fontPlusBtn);
    header.appendChild(deleteBtn);
    header.appendChild(connectToggle);

    box.appendChild(header);
    box.appendChild(content);

    // Resize handles
    ['nw','ne','sw','se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    canvas.appendChild(box);
    boxesMap.set(boxId, { box, content, connectToggle });

    // Event listeners:

    // Dragging
    let dragOffsetX, dragOffsetY;
    function onPointerDown(e) {
      if (!editMode) return;
      if (!e.shiftKey && !selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
      }
      if (selectedBoxes.has(box)) {
        // Already selected: drag all selected boxes
      } else {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }

      if (e.target === dragHandle || e.target.closest('.drag-handle')) {
        e.preventDefault();
        const rect = box.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        window.addEventListener('pointermove', onDragMove);
        window.addEventListener('pointerup', onDragEnd);
      }
    }
    function onDragMove(e) {
      e.preventDefault();
      const newX = (e.clientX - dragOffsetX - panX) / scale;
      const newY = (e.clientY - dragOffsetY - panY) / scale;
      selectedBoxes.forEach(b => {
        const id = b.dataset.id;
        const bb = boxesMap.get(id);
        const oldX = parseFloat(bb.box.style.left);
        const oldY = parseFloat(bb.box.style.top);
        const dx = newX - oldX;
        const dy = newY - oldY;
        bb.box.style.left = (oldX + dx) + 'px';
        bb.box.style.top = (oldY + dy) + 'px';
      });
      drawConnections();
    }
    function onDragEnd(e) {
      window.removeEventListener('pointermove', onDragMove);
      window.removeEventListener('pointerup', onDragEnd);
    }
    header.addEventListener('pointerdown', onPointerDown);

    // Shift+click to select multiple
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
        e.preventDefault();
      }
    });

    // Delete box
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      deleteBox(boxId);
    });

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      if (!editMode) return;
      e.stopPropagation();
      if (connectionStartBoxId === boxId) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (connectionStartBoxId === null) {
        connectionStartBoxId = boxId;
        connectToggle.classList.add('active');
      } else {
        if (connectionStartBoxId !== boxId) {
          addConnection(connectionStartBoxId, boxId);
        }
        const startBox = boxesMap.get(connectionStartBoxId);
        if (startBox) startBox.connectToggle.classList.remove('active');
        connectionStartBoxId = null;
      }
      drawConnections();
    });

    // Resize
    let resizeDir = null;
    let resizeStartX, resizeStartY, resizeStartW, resizeStartH;
    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        resizeDir = handle.classList[1];
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        resizeStartW = box.offsetWidth;
        resizeStartH = box.offsetHeight;
        window.addEventListener('pointermove', onResize);
        window.addEventListener('pointerup', onResizeEnd);
      });
    });
    function onResize(e) {
      e.preventDefault();
      let dx = (e.clientX - resizeStartX) / scale;
      let dy = (e.clientY - resizeStartY) / scale;
      let newW = resizeStartW;
      let newH = resizeStartH;
      let newX = parseFloat(box.style.left);
      let newY = parseFloat(box.style.top);
      if (resizeDir.includes('e')) newW = Math.max(40, resizeStartW + dx);
      if (resizeDir.includes('s')) newH = Math.max(24, resizeStartH + dy);
      if (resizeDir.includes('w')) {
        newW = Math.max(40, resizeStartW - dx);
        newX = newX + dx;
      }
      if (resizeDir.includes('n')) {
        newH = Math.max(24, resizeStartH - dy);
        newY = newY + dy;
      }
      box.style.width = newW + 'px';
      box.style.height = newH + 'px';
      box.style.left = newX + 'px';
      box.style.top = newY + 'px';
      drawConnections();
    }
    function onResizeEnd() {
      window.removeEventListener('pointermove', onResize);
      window.removeEventListener('pointerup', onResizeEnd);
    }

    // Font size buttons
    fontMinusBtn.addEventListener('click', e => {
      e.stopPropagation();
      let currentSize = parseFloat(box.style.fontSize) || 14;
      if (currentSize > 8) {
        currentSize -= 1;
        box.style.fontSize = currentSize + 'px';
        content.style.fontSize = currentSize + 'px';
      }
    });
    fontPlusBtn.addEventListener('click', e => {
      e.stopPropagation();
      let currentSize = parseFloat(box.style.fontSize) || 14;
      if (currentSize < 48) {
        currentSize += 1;
        box.style.fontSize = currentSize + 'px';
        content.style.fontSize = currentSize + 'px';
      }
    });

    // Content editable focus and styling
    content.addEventListener('input', () => {
      // autosave could go here
    });

    // Disable text selection drag on drag handle
    dragHandle.addEventListener('mousedown', e => e.preventDefault());

    return boxId;
  }

  function deleteBox(boxId) {
    const bb = boxesMap.get(boxId);
    if (!bb) return;
    undoStack.push({ type: 'deleteBox', data: { ...getBoxData(boxId) } });
    canvas.removeChild(bb.box);
    boxesMap.delete(boxId);

    // Remove connections referencing this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === boxId || connections[i].to === boxId) {
        undoStack.push({ type: 'deleteConnection', data: connections[i] });
        connections.splice(i, 1);
      }
    }
    drawConnections();
    undoBtn.disabled = false;
  }

  function addConnection(fromId, toId) {
    if (fromId === toId) return;
    if (connections.some(c => c.from === fromId && c.to === toId)) return;
    connections.push({ from: fromId, to: toId });
  }

  function drawConnections() {
    const svg = document.getElementById('connectionLayer');
    while (svg.firstChild) svg.removeChild(svg.firstChild);
    connections.forEach(({ from, to }) => {
      const bbFrom = boxesMap.get(from);
      const bbTo = boxesMap.get(to);
      if (!bbFrom || !bbTo) return;
      const startX = parseFloat(bbFrom.box.style.left) + bbFrom.box.offsetWidth / 2;
      const startY = parseFloat(bbFrom.box.style.top) + bbFrom.box.offsetHeight / 2;
      const endX = parseFloat(bbTo.box.style.left) + bbTo.box.offsetWidth / 2;
      const endY = parseFloat(bbTo.box.style.top) + bbTo.box.offsetHeight / 2;
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', startX);
      line.setAttribute('y1', startY);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '1.5');
      svg.appendChild(line);
    });
  }

  function getBoxData(boxId) {
    const bb = boxesMap.get(boxId);
    if (!bb) return null;
    return {
      id: boxId,
      text: bb.content.textContent,
      x: parseFloat(bb.box.style.left),
      y: parseFloat(bb.box.style.top),
      width: bb.box.offsetWidth,
      height: bb.box.offsetHeight,
      fontSize: parseFloat(bb.box.style.fontSize) || 14,
      connectedTo: connections.filter(c => c.from === boxId).map(c => c.to),
    };
  }

  async function saveMap() {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    const boxesData = [];
    boxesMap.forEach((val, key) => {
      boxesData.push(getBoxData(key));
    });
    const mapDoc = doc(db, 'mindmaps', currentMapId);
    await setDoc(mapDoc, {
      name: currentMapName,
      boxes: boxesData,
      connections: connections,
      center: { panX, panY, scale }
    });
    alert('Map saved.');
    await loadMapsList();
  }

  async function loadMapsList() {
    mindMapSelect.innerHTML = '';
    const col = collection(db, 'mindmaps');
    const snapshot = await getDocs(col);
    snapshot.forEach(docSnap => {
      const option = document.createElement('option');
      option.value = docSnap.id;
      option.textContent = docSnap.data().name || docSnap.id;
      mindMapSelect.appendChild(option);
    });
    if (currentMapId) {
      const opt = [...mindMapSelect.options].find(o => o.value === currentMapId);
      if (opt) opt.selected = true;
    }
  }

  async function loadMap(mapId) {
    currentMapId = mapId;
    const mapDoc = doc(db, 'mindmaps', mapId);
    const snap = await getDoc(mapDoc);
    if (!snap.exists()) {
      alert('Map not found');
      return;
    }
    const data = snap.data();
    currentMapName = data.name || mapId;
    clearCanvas();
    if (Array.isArray(data.boxes)) {
      data.boxes.forEach(b => {
        addBox(b.x, b.y, b.text, b.id, b.fontSize || 14, b.width || 120, b.height || 60);
      });
    }
    connections.length = 0;
    if (Array.isArray(data.connections)) {
      data.connections.forEach(c => connections.push(c));
    }
    panX = data.center?.panX || 0;
    panY = data.center?.panY || 0;
    scale = data.center?.scale || 1;
    updateTransform();
    drawConnections();
  }

  function clearCanvas() {
    boxesMap.forEach(({ box }) => {
      canvas.removeChild(box);
    });
    boxesMap.clear();
    connections.length = 0;
    selectedBoxes.clear();
    undoStack.length = 0;
    undoBtn.disabled = true;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const action = undoStack.pop();
    if (action.type === 'deleteBox') {
      const d = action.data;
      addBox(d.x, d.y, d.text, d.id, d.fontSize, d.width, d.height);
      if (Array.isArray(d.connectedTo)) {
        d.connectedTo.forEach(toId => {
          addConnection(d.id, toId);
        });
      }
      drawConnections();
    } else if (action.type === 'deleteConnection') {
      connections.push(action.data);
      drawConnections();
    }
    undoBtn.disabled = undoStack.length === 0;
  });

  goCenterBtn.addEventListener('click', () => {
    panX = 0;
    panY = 0;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    if (!currentMapId) return;
    const mapDoc = doc(db, 'mindmaps', currentMapId);
    setDoc(mapDoc, {
      center: { panX, panY, scale }
    }, { merge: true });
    alert('Center position marked and saved.');
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
    boxesMap.forEach(({ content, connectToggle, box }) => {
      content.contentEditable = editMode;
      connectToggle.style.display = editMode ? 'inline-block' : 'none';
      box.querySelector('.box-header').style.display = editMode ? 'flex' : 'none';
    });
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  saveMapBtn.addEventListener('click', saveMap);

  mindMapSelect.addEventListener('change', e => {
    const id = e.target.value;
    if (id !== currentMapId) {
      loadMap(id);
    }
  });

  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return alert('No map loaded');
    const newName = prompt('Enter new map name:', currentMapName);
    if (newName && newName.trim().length > 0) {
      const mapDoc = doc(db, 'mindmaps', currentMapId);
      await setDoc(mapDoc, { name: newName.trim() }, { merge: true });
      currentMapName = newName.trim();
      await loadMapsList();
      mindMapSelect.value = currentMapId;
      alert('Map renamed.');
    }
  });

  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return alert('No map loaded');
    if (!confirm(`Are you sure you want to delete "${currentMapName}"? This cannot be undone.`)) return;
    await deleteDoc(doc(db, 'mindmaps', currentMapId));
    currentMapId = null;
    currentMapName = '';
    clearCanvas();
    await loadMapsList();
    if (mindMapSelect.options.length > 0) {
      currentMapId = mindMapSelect.options[0].value;
      await loadMap(currentMapId);
    }
  });

  newMapBtn.addEventListener('click', async () => {
    const newName = prompt('Enter new map name:', 'New Mind Map');
    if (!newName || newName.trim().length === 0) return;
    const col = collection(db, 'mindmaps');
    const newId = 'map-' + Date.now() + '-' + Math.floor(Math.random() * 10000);
    currentMapId = newId;
    currentMapName = newName.trim();
    clearCanvas();
    panX = 0; panY = 0; scale = 1;
    updateTransform();
    await setDoc(doc(db, 'mindmaps', newId), {
      name: currentMapName,
      boxes: [],
      connections: [],
      center: { panX, panY, scale }
    });
    await loadMapsList();
    mindMapSelect.value = currentMapId;
  });

  // Initialization
  (async () => {
    await loadMapsList();
    if (currentMapId) {
      await loadMap(currentMapId);
    } else if (mindMapSelect.options.length > 0) {
      currentMapId = mindMapSelect.options[0].value;
      await loadMap(currentMapId);
    }
  })();

</script>
</body>
</html>
