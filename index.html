<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv25</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    // Drag handle
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Font size minus button
    const fontSizeMinusBtn = document.createElement('button');
    fontSizeMinusBtn.className = 'font-size-btn';
    fontSizeMinusBtn.textContent = '−';
    fontSizeMinusBtn.title = 'Decrease font size';
    header.appendChild(fontSizeMinusBtn);

    // Font size plus button
    const fontSizePlusBtn = document.createElement('button');
    fontSizePlusBtn.className = 'font-size-btn';
    fontSizePlusBtn.textContent = '+';
    fontSizePlusBtn.title = 'Increase font size';
    header.appendChild(fontSizePlusBtn);

    // Connect toggle button
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Toggle connect mode';
    header.appendChild(connectToggle);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.title = 'Delete this box';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content area
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + corner;
      box.appendChild(handle);
    });

    // Add to DOM and map
    canvas.appendChild(box);
    boxesMap.set(id, { elem: box, fontSize });

    // Event listeners

    // Dragging the box by drag handle
    let dragOffsetX, dragOffsetY;
    function onDragStart(e) {
      e.stopPropagation();
      if (!editMode) return;
      if (e.button !== 0) return;
      if (selectedBoxes.size && selectedBoxes.has(box)) {
        // group drag will be handled on move
        dragOffsetX = e.clientX;
        dragOffsetY = e.clientY;
      } else {
        dragOffsetX = e.clientX - box.offsetLeft;
        dragOffsetY = e.clientY - box.offsetTop;
      }
      window.addEventListener('pointermove', onDrag);
      window.addEventListener('pointerup', onDragEnd);
    }
    function onDrag(e) {
      e.preventDefault();
      if (selectedBoxes.size && selectedBoxes.has(box)) {
        // group drag all selected boxes
        const dx = e.clientX - dragOffsetX;
        const dy = e.clientY - dragOffsetY;
        selectedBoxes.forEach(b => {
          b.style.left = (b.offsetLeft + dx) + 'px';
          b.style.top = (b.offsetTop + dy) + 'px';
        });
        dragOffsetX = e.clientX;
        dragOffsetY = e.clientY;
        drawConnections();
      } else {
        box.style.left = (e.clientX - dragOffsetX) + 'px';
        box.style.top = (e.clientY - dragOffsetY) + 'px';
        drawConnections();
      }
    }
    function onDragEnd(e) {
      window.removeEventListener('pointermove', onDrag);
      window.removeEventListener('pointerup', onDragEnd);
      saveStatus.textContent = '';
    }
    dragHandle.addEventListener('pointerdown', onDragStart);

    // Multi-select with Shift + click on header
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (!e.shiftKey) {
        // clear selection except this box
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      } else {
        // toggle selection
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      }
    });

    // Delete box
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      deleteBox(id);
    });

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        // Cancel connection
        connectionStartBoxId = null;
        updateConnectButtons();
      } else if (connectionStartBoxId === null) {
        // Start connection
        connectionStartBoxId = id;
        updateConnectButtons();
      } else {
        // Finish connection
        if (connectionStartBoxId !== id) {
          createConnection(connectionStartBoxId, id);
        }
        connectionStartBoxId = null;
        updateConnectButtons();
      }
    });

    // Font size controls
    fontSizePlusBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      changeFontSize(id, 1);
    });
    fontSizeMinusBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      changeFontSize(id, -1);
    });

    // Content editable toggle on edit mode switch
    content.contentEditable = editMode;

    // Resize logic
    let resizing = false;
    let resizeDir = '';
    let startW, startH, startMouseX, startMouseY;

    function onResizeStart(e) {
      if (!editMode) return;
      e.stopPropagation();
      resizing = true;
      resizeDir = e.target.classList.contains('nw') ? 'nw' :
                  e.target.classList.contains('ne') ? 'ne' :
                  e.target.classList.contains('sw') ? 'sw' :
                  e.target.classList.contains('se') ? 'se' : '';
      startW = box.offsetWidth;
      startH = box.offsetHeight;
      startMouseX = e.clientX;
      startMouseY = e.clientY;
      window.addEventListener('pointermove', onResizeMove);
      window.addEventListener('pointerup', onResizeEnd);
    }

    function onResizeMove(e) {
      if (!resizing) return;
      e.preventDefault();
      const dx = e.clientX - startMouseX;
      const dy = e.clientY - startMouseY;
      let newW = startW;
      let newH = startH;
      if (resizeDir.includes('e')) newW = Math.max(40, startW + dx);
      if (resizeDir.includes('w')) newW = Math.max(40, startW - dx);
      if (resizeDir.includes('s')) newH = Math.max(30, startH + dy);
      if (resizeDir.includes('n')) newH = Math.max(30, startH - dy);

      // Adjust position if resizing from west or north
      if (resizeDir.includes('w')) box.style.left = (box.offsetLeft + (startW - newW)) + 'px';
      if (resizeDir.includes('n')) box.style.top = (box.offsetTop + (startH - newH)) + 'px';

      box.style.width = newW + 'px';
      box.style.height = newH + 'px';
      drawConnections();
    }

    function onResizeEnd(e) {
      resizing = false;
      window.removeEventListener('pointermove', onResizeMove);
      window.removeEventListener('pointerup', onResizeEnd);
    }

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', onResizeStart);
    });

    // Content change updates
    content.addEventListener('input', e => {
      saveStatus.textContent = '';
    });

    return box;
  }

  function deleteBox(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    // Save undo info
    undoStack.push({
      type: 'deleteBox',
      data: {
        id,
        box: boxData.elem.outerHTML,
        connections: connections.filter(c => c.from === id || c.to === id),
      }
    });
    undoBtn.disabled = false;

    // Remove connections related to this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }

    // Remove box
    boxesMap.get(id).elem.remove();
    boxesMap.delete(id);

    drawConnections();
    saveStatus.textContent = '';
  }

  function createConnection(fromId, toId) {
    // Avoid duplicates and self connections
    if (fromId === toId) return;
    if (connections.find(c => c.from === fromId && c.to === toId)) return;
    connections.push({ from: fromId, to: toId });
    saveStatus.textContent = '';
    drawConnections();
  }

  function updateConnectButtons() {
    boxesMap.forEach(({ elem }, id) => {
      const btn = elem.querySelector('.connect-toggle');
      if (connectionStartBoxId === id) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  }

  function changeFontSize(id, delta) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    let newFontSize = boxData.fontSize + delta;
    if (newFontSize < 8) newFontSize = 8;
    if (newFontSize > 40) newFontSize = 40;
    boxData.fontSize = newFontSize;
    const content = boxData.elem.querySelector('.box-content');
    content.style.fontSize = newFontSize + 'px';
    saveStatus.textContent = '';
  }

  // Draw connections on SVG layer
  function drawConnections() {
    while (connectionLayer.firstChild) {
      connectionLayer.removeChild(connectionLayer.firstChild);
    }
    connections.forEach(({ from, to }) => {
      const fromBox = boxesMap.get(from);
      const toBox = boxesMap.get(to);
      if (!fromBox || !toBox) return;

      const fromElem = fromBox.elem;
      const toElem = toBox.elem;

      // Get centers in canvas coordinates
      const fromRect = fromElem.getBoundingClientRect();
      const toRect = toElem.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      const fromX = (fromRect.left + fromRect.width / 2 - vpRect.left - panX) / scale;
      const fromY = (fromRect.top + fromRect.height / 2 - vpRect.top - panY) / scale;
      const toX = (toRect.left + toRect.width / 2 - vpRect.left - panX) / scale;
      const toY = (toRect.top + toRect.height / 2 - vpRect.top - panY) / scale;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', fromX);
      line.setAttribute('y1', fromY);
      line.setAttribute('x2', toX);
      line.setAttribute('y2', toY);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '2');
      connectionLayer.appendChild(line);
    });
  }

  // Undo delete
  undoBtn.addEventListener('click', () => {
    if (!undoStack.length) return;
    const action = undoStack.pop();
    if (action.type === 'deleteBox') {
      // Reinsert box
      const container = document.createElement('div');
      container.innerHTML = action.data.box;
      const boxElem = container.firstChild;
      canvas.appendChild(boxElem);
      const id = action.data.id;
      boxesMap.set(id, { elem: boxElem, fontSize: parseInt(boxElem.querySelector('.box-content').style.fontSize) || 14 });

      // Re-add connections
      action.data.connections.forEach(c => connections.push(c));

      drawConnections();
      saveStatus.textContent = '';
      undoBtn.disabled = undoStack.length === 0;
    }
  });

  // Centering functions
  let markedCenter = { x: 0, y: 0 };

  goCenterBtn.addEventListener('click', () => {
    panX = markedCenter.x;
    panY = markedCenter.y;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    markedCenter.x = panX;
    markedCenter.y = panY;
    saveStatus.textContent = 'Center marked';
    setTimeout(() => { saveStatus.textContent = ''; }, 1500);
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    boxesMap.forEach(({ elem }) => {
      const content = elem.querySelector('.box-content');
      content.contentEditable = editMode;
      elem.querySelector('.delete-btn').style.display = editMode ? 'inline-block' : 'none';
      elem.querySelector('.connect-toggle').style.display = editMode ? 'inline-block' : 'none';
      elem.querySelectorAll('.font-size-btn').forEach(btn => {
        btn.style.display = editMode ? 'inline-block' : 'none';
      });
      elem.querySelectorAll('.resize-handle').forEach(handle => {
        handle.style.display = editMode ? 'block' : 'none';
      });
      elem.querySelector('.drag-handle').style.cursor = editMode ? 'move' : 'default';
    });
    saveStatus.textContent = editMode ? 'Edit mode ON' : 'Edit mode OFF';
    setTimeout(() => { saveStatus.textContent = ''; }, 1000);
  });

  // How to modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // New box on double click (only if edit mode)
  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    const id = generateId();
    createBox(id, x, y);
    saveStatus.textContent = '';
  });

  // Map selection dropdown logic

  async function loadMapsList() {
    mapSelect.innerHTML = '';
    mapsCache.clear();
    const colRef = collection(db, 'maps');
    const snapshot = await getDocs(colRef);
    if (snapshot.empty) {
      currentMapId = null;
      return;
    }
    snapshot.forEach(docSnap => {
      const data = docSnap.data();
      mapsCache.set(docSnap.id, data);
      const option = document.createElement('option');
      option.value = docSnap.id;
      option.textContent = data.name || docSnap.id;
      mapSelect.appendChild(option);
    });
    if (mapsCache.size > 0) {
      currentMapId = mapSelect.options[0].value;
      mapSelect.value = currentMapId;
      await loadMap(currentMapId);
    } else {
      currentMapId = null;
    }
  }

  mapSelect.addEventListener('change', async () => {
    if (!mapSelect.value) return;
    if (currentMapId === mapSelect.value) return;
    currentMapId = mapSelect.value;
    await loadMap(currentMapId);
  });

  async function loadMap(id) {
    // Clear current boxes and connections
    boxesMap.forEach(({ elem }) => elem.remove());
    boxesMap.clear();
    connections.length = 0;
    connectionStartBoxId = null;
    updateConnectButtons();

    const docRef = doc(db, 'maps', id);
    const docSnap = await getDocs(collection(db, 'maps'));
    // Instead of getDocs on collection, use getDoc on docRef
    const { getDoc } = await import("https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js");
    const snapshot = await getDoc(docRef);
    if (!snapshot.exists()) {
      alert("Map not found!");
      return;
    }
    const data = snapshot.data();

    // Load boxes
    if (data.boxes) {
      for (const [id, box] of Object.entries(data.boxes)) {
        createBox(id, box.x, box.y, box.w, box.h, box.text, box.fontSize || 14);
      }
    }

    // Load connections
    if (data.connections) {
      for (const conn of data.connections) {
        connections.push(conn);
      }
    }

    // Load center
    if (data.center) {
      panX = data.center.x || 0;
      panY = data.center.y || 0;
      scale = data.center.scale || 1;
    } else {
      panX = 0; panY = 0; scale = 1;
    }
    updateTransform();
    drawConnections();
    saveStatus.textContent = `Loaded map "${data.name || id}"`;
    setTimeout(() => { saveStatus.textContent = ''; }, 2000);
  }

  async function saveCurrentMap() {
    if (!currentMapId) {
      alert('No map selected.');
      return;
    }
    const boxesObj = {};
    boxesMap.forEach(({ elem, fontSize }, id) => {
      boxesObj[id] = {
        x: parseInt(elem.style.left) || 0,
        y: parseInt(elem.style.top) || 0,
        w: parseInt(elem.style.width) || 120,
        h: parseInt(elem.style.height) || 60,
        text: elem.querySelector('.box-content').textContent,
        fontSize
      };
    });
    const data = {
      boxes: boxesObj,
      connections: connections.slice(),
      center: { x: panX, y: panY, scale },
      name: mapsCache.get(currentMapId)?.name || currentMapId,
    };
    const docRef = doc(db, 'maps', currentMapId);
    await setDoc(docRef, data);
    saveStatus.textContent = 'Map saved';
    setTimeout(() => { saveStatus.textContent = ''; }, 1500);
  }

  saveMapBtn.addEventListener('click', saveCurrentMap);

  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    const newName = prompt('Enter new map name:', mapsCache.get(currentMapId)?.name || '');
    if (!newName) return;
    const docRef = doc(db, 'maps', currentMapId);
    const data = mapsCache.get(currentMapId) || {};
    data.name = newName;
    await setDoc(docRef, data, { merge: true });
    mapsCache.set(currentMapId, data);
    const option = [...mapSelect.options].find(o => o.value === currentMapId);
    if (option) option.textContent = newName;
    saveStatus.textContent = 'Map renamed';
    setTimeout(() => { saveStatus.textContent = ''; }, 1500);
  });

  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    if (!confirm(`Delete map "${mapsCache.get(currentMapId)?.name || currentMapId}"? This cannot be undone.`)) return;
    const docRef = doc(db, 'maps', currentMapId);
    await deleteDoc(docRef);
    mapsCache.delete(currentMapId);
    await loadMapsList();
    saveStatus.textContent = 'Map deleted';
    setTimeout(() => { saveStatus.textContent = ''; }, 1500);
  });

  newMapBtn.addEventListener('click', async () => {
    let newName = prompt('Enter new map name:', 'New Map');
    if (!newName) return;

    // Generate a new unique ID
    let newId;
    do {
      newId = generateId();
    } while (mapsCache.has(newId));

    const data = {
      boxes: {},
      connections: [],
      center: { x: 0, y: 0, scale: 1 },
      name: newName
    };
    const docRef = doc(db, 'maps', newId);
    await setDoc(docRef, data);
    mapsCache.set(newId, data);
    await loadMapsList();
    mapSelect.value = newId;
    currentMapId = newId;
    saveStatus.textContent = 'New map created';
    setTimeout(() => { saveStatus.textContent = ''; }, 1500);
  });

  // Initial load maps list
  loadMapsList();

  // Initial setup of edit mode UI states
  toggleEditModeBtn.click();

</script>
</body>
</html>
