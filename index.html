<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings - Fixed Properly</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body, #viewport {
    margin:0; padding:0; width:100%; height:100%; overflow:hidden;
    user-select:none; touch-action:none; background:#f0f0f0;
  }
  #viewport {
    position: relative; cursor: grab;
  }
  #canvas {
    position: absolute; top:0; left:0;
    user-select:none;
  }
  svg#connectionLayer {
    position: absolute;
    top:0; left:0; width:100%; height:100%;
    pointer-events:none;
    z-index: 0;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    min-width: 80px; min-height: 40px;
    display: flex; flex-direction: column;
    user-select: text;
    box-sizing: border-box;
    overflow: hidden;
    z-index: 10;
  }
  .box.selected {
    outline: 3px solid #3377ff;
    outline-offset: -3px;
  }
  .box-header {
    background: #ddd;
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 1px 4px;
    user-select: none;
    cursor: grab;
    font-size: 12px;
    height: 18px;
    border-bottom: 1px solid #bbb;
    flex-shrink: 0;
  }
  .box-header button {
    width: 18px; height: 18px;
    border: none;
    cursor: pointer;
    border-radius: 50%;
    font-weight: bold;
    font-size: 14px;
    line-height: 1;
    padding: 0;
    user-select: none;
  }
  .connect-toggle {
    background-color: #3b82f6;
    color: white;
  }
  .connect-toggle.active {
    background-color: #16a34a;
  }
  .delete-btn {
    background: transparent;
    color: red;
  }
  .box-content {
    flex: 1;
    padding: 6px 8px;
    font-family: monospace;
    font-size: 16px;
    line-height: 1.2;
    overflow: auto;
    outline: none;
    white-space: pre-wrap;
    word-break: break-word;
    user-select: text;
    resize: none;
  }
  .resize-handle {
    width: 14px;
    height: 14px;
    position: absolute;
    background: transparent;
    z-index: 20;
  }
  .resize-handle.se {
    bottom: 0; right: 0;
    cursor: nwse-resize;
  }
  #buttonContainer {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  button.floatingBtn {
    font-family: monospace;
    padding: 6px 12px;
    background: rgba(80, 80, 80, 0.6);
    border: 1px solid #555;
    color: #eee;
    cursor: pointer;
    border-radius: 4px;
    user-select: none;
  }
  button.floatingBtn:disabled {
    background: #999;
    cursor: default;
    color: #ccc;
  }
  #zoomDisplay {
    position: fixed;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.5);
    color: white;
    font-family: monospace;
    padding: 4px 8px;
    border-radius: 4px;
    user-select: none;
    pointer-events: none;
    z-index: 1001;
  }
</style>
</head>
<body>
<div id="viewport" tabindex="0">
  <svg id="connectionLayer"></svg>
  <div id="canvas"></div>
</div>
<div id="buttonContainer">
  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
  <button id="selectModeBtn" class="floatingBtn">Select Mode: OFF</button>
  <button id="deleteSelectedBtn" class="floatingBtn" disabled>Delete Selected</button>
  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
  <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
</div>
<div id="zoomDisplay">Zoom: 100%</div>

<script>
(() => {
  const viewport = document.getElementById('viewport');
  const canvas = document.getElementById('canvas');
  const connectionLayer = document.getElementById('connectionLayer');
  const undoBtn = document.getElementById('undoBtn');
  const selectModeBtn = document.getElementById('selectModeBtn');
  const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const zoomDisplay = document.getElementById('zoomDisplay');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, panStartX, panStartY;
  let undoStack = [];
  let connections = [];
  let selectedBoxes = new Set();
  let selectedConnections = new Set();
  let selectMode = false;
  let connectionStartBox = null;
  let centerMarker = null;

  const generateId = () => 'id_' + Math.random().toString(36).slice(2,11);

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px,${panY}px) scale(${scale})`;
    connectionLayer.style.transform = `translate(${panX}px,${panY}px) scale(${scale})`;
    zoomDisplay.textContent = `Zoom: ${Math.round(scale*100)}%`;
    if(centerMarker) updateCenterMarkerPosition();
    drawConnections();
  }

  viewport.style.cursor = 'grab';
  viewport.addEventListener('pointerdown', e => {
    if(selectMode) return;
    if(e.target.closest('.box') || e.target.closest('button')) return;
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    viewport.setPointerCapture(e.pointerId);
    viewport.style.cursor = 'grabbing';
  });
  viewport.addEventListener('pointermove', e => {
    if(!isPanning) return;
    const dx = e.clientX - panStartX;
    const dy = e.clientY - panStartY;
    panX += dx;
    panY += dy;
    panStartX = e.clientX;
    panStartY = e.clientY;
    updateTransform();
  });
  viewport.addEventListener('pointerup', e => {
    if(!isPanning) return;
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
    viewport.style.cursor = 'grab';
    saveAll();
  });

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    let newScale = scale * (e.deltaY < 0 ? zoomFactor : 1/zoomFactor);
    newScale = Math.min(3, Math.max(0.5, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
    saveAll();
  }, { passive: false });

  function createBox(x, y, text='Text box', id=null, width=180, height=80, fontSize='16px') {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.dataset.id = id || generateId();

    const header = document.createElement('div');
    header.className = 'box-header';

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect';
    connectToggle.textContent = '⛓';

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';

    header.appendChild(connectToggle);
    header.appendChild(deleteBtn);
    box.appendChild(header);

    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = true;
    content.spellcheck = false;
    content.textContent = text;
    content.style.fontSize = fontSize;

    box.appendChild(content);

    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle se';
    box.appendChild(resizeHandle);

    let dragging = false, dragOffsetX, dragOffsetY;
    let resizing = false;
    let resizeStartWidth, resizeStartHeight, resizeStartClientX, resizeStartClientY;

    header.addEventListener('pointerdown', e => {
      if(selectMode) return;
      if(e.target === connectToggle || e.target === deleteBtn) return;
      dragging = true;
      dragOffsetX = e.clientX - box.offsetLeft;
      dragOffsetY = e.clientY - box.offsetTop;
      box.setPointerCapture(e.pointerId);
      e.preventDefault();
      viewport.style.cursor = 'grabbing';
    });
    header.addEventListener('pointermove', e => {
      if(!dragging) return;
      e.preventDefault();
      box.style.left = (e.clientX - dragOffsetX) + 'px';
      box.style.top = (e.clientY - dragOffsetY) + 'px';
      drawConnections();
    });
    header.addEventListener('pointerup', e => {
      if(!dragging) return;
      dragging = false;
      box.releasePointerCapture(e.pointerId);
      saveAll();
      viewport.style.cursor = 'grab';
    });

    resizeHandle.addEventListener('pointerdown', e => {
      if(selectMode) return;
      resizing = true;
      resizeStartWidth = box.offsetWidth;
      resizeStartHeight = box.offsetHeight;
      resizeStartClientX = e.clientX;
      resizeStartClientY = e.clientY;
      resizeHandle.setPointerCapture(e.pointerId);
      e.preventDefault();
    });
    resizeHandle.addEventListener('pointermove', e => {
      if(!resizing || !resizeHandle.hasPointerCapture(e.pointerId)) return;
      e.preventDefault();
      const dx = e.clientX - resizeStartClientX;
      const dy = e.clientY - resizeStartClientY;
      box.style.width = Math.max(80, resizeStartWidth + dx) + 'px';
      box.style.height = Math.max(40, resizeStartHeight + dy) + 'px';
      adjustFontSize(content, box);
      drawConnections();
    });
    resizeHandle.addEventListener('pointerup', e => {
      if(!resizing) return;
      resizing = false;
      resizeHandle.releasePointerCapture(e.pointerId);
      saveAll();
    });

    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if(!selectMode) return;
      if(connectionStartBox === box) {
        connectionStartBox = null;
        connectToggle.classList.remove('active');
      } else {
        document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
        connectionStartBox = box;
        connectToggle.classList.add('active');
      }
    });

    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      if(!selectMode) return;
      deleteBox(box.dataset.id);
    });

    box.addEventListener('click', e => {
      if(!selectMode) return;
      e.stopPropagation();
      if(e.shiftKey) {
        if(selectedBoxes.has(box.dataset.id)) selectedBoxes.delete(box.dataset.id);
        else selectedBoxes.add(box.dataset.id);
      } else {
        selectedBoxes.clear();
        selectedConnections.clear();
        selectedBoxes.add(box.dataset.id);
      }
      updateSelectionVisuals();
    });

    content.addEventListener('input', () => {
      adjustFontSize(content, box);
      saveAll();
    });

    function adjustFontSize(contentDiv, container) {
      const padding = 14;
      const maxWidth = container.clientWidth - padding;
      const maxHeight = container.clientHeight - padding;
      let minSize = 8;
      let maxSize = 72;
      let fontSize = 16;
      while(minSize <= maxSize) {
        let mid = Math.floor((minSize + maxSize) / 2);
        contentDiv.style.fontSize = mid + 'px';
        if(contentDiv.scrollWidth <= maxWidth && contentDiv.scrollHeight <= maxHeight) {
          fontSize = mid;
          minSize = mid + 1;
        } else {
          maxSize = mid -1;
        }
      }
      contentDiv.style.fontSize = fontSize + 'px';
    }
    adjustFontSize(content, box);

    canvas.appendChild(box);
    updateSelectionVisuals();
    return box;
  }

  function updateSelectionVisuals() {
    document.querySelectorAll('.box').forEach(box => {
      if(selectedBoxes.has(box.dataset.id)) {
        box.classList.add('selected');
        box.querySelector('.connect-toggle').classList.add('active');
      } else {
        box.classList.remove('selected');
        box.querySelector('.connect-toggle').classList.remove('active');
      }
    });
    document.querySelectorAll('path.connection').forEach(path => {
      if(selectedConnections.has(path.dataset.id)) {
        path.classList.add('selected');
      } else {
        path.classList.remove('selected');
      }
    });
    deleteSelectedBtn.disabled = selectedBoxes.size === 0 && selectedConnections.size === 0;
  }

  function deleteBox(id) {
    const box = document.querySelector(`.box[data-id="${id}"]`);
    if(!box) return;
    undoStack.push({
      type: 'box',
      id,
      x: box.offsetLeft,
      y: box.offsetTop,
      width: box.offsetWidth,
      height: box.offsetHeight,
      text: box.querySelector('.box-content').textContent,
      fontSize: box.querySelector('.box-content').style.fontSize || '16px',
    });
    undoBtn.disabled = false;
    connections = connections.filter(conn => {
      if(conn.from === id || conn.to === id) {
        const path = document.querySelector(`path.connection[data-id="${conn.id}"]`);
        if(path) path.remove();
        return false;
      }
      return true;
    });
    box.remove();
    selectedBoxes.delete(id);
    saveAll();
    updateSelectionVisuals();
  }

  deleteSelectedBtn.addEventListener('click', () => {
    selectedBoxes.forEach(id => deleteBox(id));
    selectedConnections.forEach(id => {
      const connIndex = connections.findIndex(c => c.id === id);
      if(connIndex !== -1) {
        undoStack.push({type:'connection', data:connections[connIndex]});
        undoBtn.disabled = false;
        const path = document.querySelector(`path.connection[data-id="${id}"]`);
        if(path) path.remove();
        connections.splice(connIndex,1);
      }
    });
    selectedBoxes.clear();
    selectedConnections.clear();
    saveAll();
    updateSelectionVisuals();
  });

  undoBtn.addEventListener('click', () => {
    if(undoStack.length === 0) return;
    const last = undoStack.pop();
    if(last.type === 'box') {
      createBox(last.x, last.y, last.text, last.id, last.width, last.height, last.fontSize);
    } else if(last.type === 'connection') {
      connections.push(last.data);
    }
    saveAll();
    updateSelectionVisuals();
    undoBtn.disabled = undoStack.length === 0;
  });

  selectModeBtn.addEventListener('click', () => {
    selectMode = !selectMode;
    selectModeBtn.textContent = 'Select Mode: ' + (selectMode ? 'ON' : 'OFF');
    if(!selectMode) {
      selectedBoxes.clear();
      selectedConnections.clear();
      updateSelectionVisuals();
      connectionStartBox = null;
      document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
    }
  });

  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(conn => {
      const fromBox = document.querySelector(`.box[data-id="${conn.from}"]`);
      const toBox = document.querySelector(`.box[data-id="${conn.to}"]`);
      if(!fromBox || !toBox) return;

      const p1 = {
        x: fromBox.offsetLeft + fromBox.offsetWidth / 2,
        y: fromBox.offsetTop + fromBox.offsetHeight / 2,
      };
      const p2 = {
        x: toBox.offsetLeft + toBox.offsetWidth / 2,
        y: toBox.offsetTop + toBox.offsetHeight / 2,
      };
      const dist = Math.abs(p2.x - p1.x) / 2;
      const d = `M${p1.x},${p1.y} C${p1.x + dist},${p1.y} ${p2.x - dist},${p2.y} ${p2.x},${p2.y}`;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', d);
      path.classList.add('connection');
      path.dataset.id = conn.id;
      if(selectedConnections.has(conn.id)) path.classList.add('selected');
      connectionLayer.appendChild(path);

      if(conn.label && conn.label.trim() !== '') {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.textContent = conn.label;
        text.setAttribute('x', (p1.x + p2.x) / 2);
        text.setAttribute('y', (p1.y + p2.y) / 2 - 10);
        text.setAttribute('font-size', '12');
        text.setAttribute('font-family', 'monospace');
        text.setAttribute('fill', 'black');
        text.setAttribute('text-anchor', 'middle');
        connectionLayer.appendChild(text);
      }

      path.addEventListener('click', e => {
        if(!selectMode) return;
        e.stopPropagation();
        if(selectedConnections.has(conn.id)) selectedConnections.delete(conn.id);
        else selectedConnections.add(conn.id);
        updateSelectionVisuals();
      });
    });
  }

  viewport.addEventListener('click', e => {
    if(!selectMode) return;
    if(!connectionStartBox) return;
    const targetBox = e.target.closest('.box');
    if(!targetBox) return;
    if(targetBox.dataset.id === connectionStartBox.dataset.id) {
      connectionStartBox.querySelector('.connect-toggle').classList.remove('active');
      connectionStartBox = null;
      return;
    }
    let label = prompt("Label for connection:", "");
    connections.push({
      id: generateId(),
      from: connectionStartBox.dataset.id,
      to: targetBox.dataset.id,
      label: label || '',
    });
    connectionStartBox.querySelector('.connect-toggle').classList.remove('active');
    connectionStartBox = null;
    drawConnections();
    saveAll();
  });

  viewport.addEventListener('dblclick', e => {
    if(selectMode) return;
    if(e.target.closest('.box') || e.target.closest('button')) return;
    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    createBox(x, y);
    saveAll();
  });

  viewport.addEventListener('click', e => {
    if(!selectMode) return;
    if(e.target === viewport || e.target === canvas || e.target === connectionLayer) {
      selectedBoxes.clear();
      selectedConnections.clear();
      updateSelectionVisuals();
    }
  });

  viewport.addEventListener('keydown', e => {
    if(e.key === 'Delete' && selectMode) {
      deleteSelectedBtn.click();
    }
    if(e.key === 'Escape') {
      selectedBoxes.clear();
      selectedConnections.clear();
      updateSelectionVisuals();
    }
  });

  function saveAll() {
    const boxes = [];
    document.querySelectorAll('.box').forEach(box => {
      boxes.push({
        id: box.dataset.id,
        x: box.offsetLeft,
        y: box.offsetTop,
        width: box.offsetWidth,
        height: box.offsetHeight,
        text: box.querySelector('.box-content').textContent,
        fontSize: box.querySelector('.box-content').style.fontSize || '16px',
      });
    });
    const data = {
      boxes,
      connections,
      panX,
      panY,
      scale,
      centerMarkerPos: centerMarker ? {x:-panX, y:-panY} : null,
    };
    localStorage.setItem('stringsnthingsData', JSON.stringify(data));
  }
  function loadAll() {
    const dataStr = localStorage.getItem('stringsnthingsData');
    if(!dataStr) return;
    try {
      const data = JSON.parse(dataStr);
      document.querySelectorAll('.box').forEach(b => b.remove());
      connections = data.connections || [];
      panX = data.panX || 0;
      panY = data.panY || 0;
      scale = data.scale || 1;
      data.boxes.forEach(b => {
        createBox(b.x, b.y, b.text, b.id, b.width, b.height, b.fontSize);
      });
      updateTransform();
      drawConnections();
      if(data.centerMarkerPos) {
        createCenterMarker();
        panX = -data.centerMarkerPos.x;
        panY = -data.centerMarkerPos.y;
        updateTransform();
        updateCenterMarkerPosition();
      }
    } catch(err) {
      console.error('Load error:', err);
    }
  }

  function createCenterMarker() {
    if(centerMarker) centerMarker.remove();
    centerMarker = document.createElement('div');
    centerMarker.style.position = 'absolute';
    centerMarker.style.width = '20px';
    centerMarker.style.height = '20px';
    centerMarker.style.border = '3px solid red';
    centerMarker.style.borderRadius = '50%';
    centerMarker.style.pointerEvents = 'none';
    centerMarker.style.zIndex = '9999';
    viewport.appendChild(centerMarker);
    updateCenterMarkerPosition();
  }
  function updateCenterMarkerPosition() {
    if(!centerMarker) return;
    centerMarker.style.left = (-panX - 10) + 'px';
    centerMarker.style.top = (-panY - 10) + 'px';
  }
  markCenterBtn.addEventListener('click', () => {
    createCenterMarker();
    saveAll();
  });

  goCenterBtn.addEventListener('click', () => {
    panX = 0; panY = 0; scale = 1;
    updateTransform();
    saveAll();
  });

  loadAll();
  updateTransform();
  updateSelectionVisuals();
})();
</script>
</body>
</html>
