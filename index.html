<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv28</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9ea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    // Drag handle
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Font size minus button
    const fontSizeMinusBtn = document.createElement('button');
    fontSizeMinusBtn.className = 'font-size-btn';
    fontSizeMinusBtn.textContent = '−';
    fontSizeMinusBtn.title = 'Decrease font size';
    header.appendChild(fontSizeMinusBtn);

    // Font size plus button
    const fontSizePlusBtn = document.createElement('button');
    fontSizePlusBtn.className = 'font-size-btn';
    fontSizePlusBtn.textContent = '+';
    fontSizePlusBtn.title = 'Increase font size';
    header.appendChild(fontSizePlusBtn);

    // Connect toggle button
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect / disconnect this box';
    header.appendChild(connectToggle);

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Delete this box';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content (editable div)
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text || '';
    box.appendChild(content);

    // Resize handles
    ['nw','ne','sw','se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    // Event listeners

    // Dragging
    let dragStartX, dragStartY, boxStartX, boxStartY;
    let isDragging = false;
    dragHandle.addEventListener('pointerdown', e => {
      e.stopPropagation();
      if (!editMode) return;
      isDragging = true;
      const rect = box.getBoundingClientRect();
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      boxStartX = parseFloat(box.style.left);
      boxStartY = parseFloat(box.style.top);
      document.body.style.cursor = 'move';
      window.addEventListener('pointermove', dragMove);
      window.addEventListener('pointerup', dragEnd);
    });

    function dragMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      const dx = (e.clientX - dragStartX) / scale;
      const dy = (e.clientY - dragStartY) / scale;
      if (selectedBoxes.has(box)) {
        // Move all selected boxes
        selectedBoxes.forEach(b => {
          const startX = parseFloat(b.dataset.dragOriginX);
          const startY = parseFloat(b.dataset.dragOriginY);
          b.style.left = startX + dx + 'px';
          b.style.top = startY + dy + 'px';
        });
      } else {
        box.style.left = boxStartX + dx + 'px';
        box.style.top = boxStartY + dy + 'px';
      }
      drawConnections();
    }

    function dragEnd() {
      if (!isDragging) return;
      isDragging = false;
      document.body.style.cursor = '';
      window.removeEventListener('pointermove', dragMove);
      window.removeEventListener('pointerup', dragEnd);
      saveCurrentMapDebounced();
    }

    // Shift + click to select multiple
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (!e.shiftKey) {
        clearSelectedBoxes();
        selectBox(box);
      } else {
        if (selectedBoxes.has(box)) {
          deselectBox(box);
        } else {
          selectBox(box);
        }
      }
    });

    function selectBox(box) {
      if (!selectedBoxes.has(box)) {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
      // Save drag origins for group move
      selectedBoxes.forEach(b => {
        b.dataset.dragOriginX = parseFloat(b.style.left);
        b.dataset.dragOriginY = parseFloat(b.style.top);
      });
    }

    function deselectBox(box) {
      selectedBoxes.delete(box);
      box.classList.remove('selected');
    }

    function clearSelectedBoxes() {
      selectedBoxes.forEach(b => b.classList.remove('selected'));
      selectedBoxes.clear();
    }

    // Delete box
    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      deleteBox(id);
    });

    // Font size buttons
    fontSizePlusBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      let fs = parseInt(content.style.fontSize);
      if (fs < 36) {
        fs++;
        content.style.fontSize = fs + 'px';
        saveCurrentMapDebounced();
      }
    });
    fontSizeMinusBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      let fs = parseInt(content.style.fontSize);
      if (fs > 8) {
        fs--;
        content.style.fontSize = fs + 'px';
        saveCurrentMapDebounced();
      }
    });

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        // Cancel connect mode
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (connectionStartBoxId === null) {
        // Start connect mode
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else {
        // Complete connection
        if (connectionStartBoxId !== id) {
          addConnection(connectionStartBoxId, id);
        }
        // Reset connect mode toggles
        clearConnectToggles();
        connectionStartBoxId = null;
      }
    });

    // Content editable changes
    content.addEventListener('input', e => {
      saveCurrentMapDebounced();
    });

    // Resize handlers
    ['nw','ne','sw','se'].forEach(pos => {
      const handle = box.querySelector('.resize-handle.' + pos);
      let startW, startH, startXr, startYr, startMX, startMY;
      let resizing = false;

      handle.addEventListener('pointerdown', e => {
        e.stopPropagation();
        if (!editMode) return;
        resizing = true;
        startW = box.offsetWidth;
        startH = box.offsetHeight;
        startXr = parseFloat(box.style.left);
        startYr = parseFloat(box.style.top);
        startMX = e.clientX;
        startMY = e.clientY;
        document.body.style.cursor = handle.style.cursor;
        window.addEventListener('pointermove', resizeMove);
        window.addEventListener('pointerup', resizeEnd);
      });

      function resizeMove(e) {
        if (!resizing) return;
        e.preventDefault();
        const dx = (e.clientX - startMX) / scale;
        const dy = (e.clientY - startMY) / scale;
        let newW = startW;
        let newH = startH;
        let newX = startXr;
        let newY = startYr;
        if (pos.includes('e')) newW = Math.max(40, startW + dx);
        if (pos.includes('s')) newH = Math.max(24, startH + dy);
        if (pos.includes('w')) {
          newW = Math.max(40, startW - dx);
          newX = startXr + dx;
        }
        if (pos.includes('n')) {
          newH = Math.max(24, startH - dy);
          newY = startYr + dy;
        }
        box.style.width = newW + 'px';
        box.style.height = newH + 'px';
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';
        drawConnections();
      }

      function resizeEnd() {
        if (!resizing) return;
        resizing = false;
        document.body.style.cursor = '';
        window.removeEventListener('pointermove', resizeMove);
        window.removeEventListener('pointerup', resizeEnd);
        saveCurrentMapDebounced();
      }
    });

    canvas.appendChild(box);
    boxesMap.set(id, { element: box, content, fontSize: parseInt(content.style.fontSize) });
  }

  function deleteBox(id) {
    if (!boxesMap.has(id)) return;
    const boxData = boxesMap.get(id);
    const box = boxData.element;
    // Remove connections related
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    box.remove();
    boxesMap.delete(id);
    undoStack.push({ type: 'deleteBox', data: { id, boxData, connections: JSON.parse(JSON.stringify(connections)) } });
    updateUndoBtn();
    drawConnections();
    saveCurrentMapDebounced();
  }

  // Connections

  function addConnection(fromId, toId) {
    if (connections.find(c => c.from === fromId && c.to === toId)) return; // avoid duplicates
    connections.push({ from: fromId, to: toId });
    drawConnections();
    saveCurrentMapDebounced();
  }

  function clearConnectToggles() {
    boxesMap.forEach(({element}) => {
      const toggle = element.querySelector('.connect-toggle');
      toggle.classList.remove('active');
    });
  }

  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.firstChild.remove();

    connections.forEach(({from, to}) => {
      const fromBox = boxesMap.get(from);
      const toBox = boxesMap.get(to);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.element.getBoundingClientRect();
      const toRect = toBox.element.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      const startX = (fromRect.left + fromRect.width / 2 - vpRect.left - panX) / scale;
      const startY = (fromRect.top + fromRect.height / 2 - vpRect.top - panY) / scale;
      const endX = (toRect.left + toRect.width / 2 - vpRect.left - panX) / scale;
      const endY = (toRect.top + toRect.height / 2 - vpRect.top - panY) / scale;

      // Bezier curve control points for nice curve
      const dx = endX - startX;
      const dy = endY - startY;
      const ctrl1X = startX + dx * 0.25;
      const ctrl1Y = startY;
      const ctrl2X = startX + dx * 0.75;
      const ctrl2Y = endY;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", `M${startX},${startY} C${ctrl1X},${ctrl1Y} ${ctrl2X},${ctrl2Y} ${endX},${endY}`);
      path.setAttribute("stroke", "#000");
      path.setAttribute("stroke-width", "1.5");
      path.setAttribute("fill", "none");

      connectionLayer.appendChild(path);
    });
  }

  // Undo handling

  function updateUndoBtn() {
    undoBtn.disabled = undoStack.length === 0;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const action = undoStack.pop();
    if (action.type === 'deleteBox') {
      // Restore box
      const { id, boxData, connections: oldConnections } = action.data;
      const { element, content, fontSize } = boxData;
      canvas.appendChild(element);
      boxesMap.set(id, boxData);
      connections.length = 0;
      connections.push(...oldConnections);
      drawConnections();
      saveCurrentMapDebounced();
    }
    updateUndoBtn();
  });

  // Save/load map

  async function saveCurrentMap() {
    if (!currentMapId) return;
    const boxes = [];
    boxesMap.forEach(({element, content}) => {
      boxes.push({
        id: element.dataset.id,
        x: parseFloat(element.style.left),
        y: parseFloat(element.style.top),
        width: parseFloat(element.style.width),
        height: parseFloat(element.style.height),
        text: content.textContent,
        fontSize: parseInt(content.style.fontSize)
      });
    });
    const mapData = {
      boxes,
      connections,
      center: { x: panX, y: panY, scale }
    };
    try {
      await setDoc(doc(db, "maps", currentMapId), mapData);
      saveStatus.textContent = "Saved ✔";
      setTimeout(() => { saveStatus.textContent = ""; }, 1500);
      mapsCache.set(currentMapId, mapData);
    } catch(e) {
      saveStatus.textContent = "Save failed!";
      console.error(e);
    }
  }

  const saveCurrentMapDebounced = debounce(saveCurrentMap, 800);

  async function loadMap(mapId) {
    if (!mapId) return;
    clearCanvas();
    currentMapId = mapId;
    if (mapsCache.has(mapId)) {
      const data = mapsCache.get(mapId);
      loadMapData(data);
    } else {
      try {
        const docSnap = await getDocs(collection(db, "maps"));
        // Just load from cache below:
        await loadMapsList();
        const data = mapsCache.get(mapId);
        if (data) loadMapData(data);
        else clearCanvas();
      } catch(e) {
        console.error("Error loading map:", e);
      }
    }
  }

  function loadMapData(data) {
    clearCanvas();
    if (!data) return;
    if (data.boxes) {
      data.boxes.forEach(b => createBox(b.id, b.x, b.y, b.width, b.height, b.text, b.fontSize || 14));
    }
    connections.length = 0;
    if (data.connections) {
      connections.push(...data.connections);
    }
    if (data.center) {
      panX = data.center.x;
      panY = data.center.y;
      scale = data.center.scale;
    } else {
      panX = 0;
      panY = 0;
      scale = 1;
    }
    updateTransform();
    drawConnections();
  }

  function clearCanvas() {
    boxesMap.forEach(({element}) => element.remove());
    boxesMap.clear();
    connections.length = 0;
    drawConnections();
    clearSelectedBoxes();
  }

  // Load map list from Firestore

  async function loadMapsList() {
    mapSelect.innerHTML = '';
    mapsCache.clear();
    const mapsCol = collection(db, "maps");
    const docsSnap = await getDocs(mapsCol);
    docsSnap.forEach(docSnap => {
      const mapId = docSnap.id;
      const data = docSnap.data();
      mapsCache.set(mapId, { name: mapId, ...data });
      const option = document.createElement('option');
      option.value = mapId;
      option.textContent = mapId;
      mapSelect.appendChild(option);
    });
    if (mapsCache.size > 0) {
      currentMapId = mapSelect.options[0].value;
      mapSelect.value = currentMapId;
      await loadMap(currentMapId);
    } else {
      clearCanvas();
      currentMapId = null;
    }
  }

  // Map select change handler

  mapSelect.addEventListener('change', async e => {
    if (e.target.value === currentMapId) return;
    await loadMap(e.target.value);
  });

  // New map button

  newMapBtn.addEventListener('click', async () => {
    let newName = prompt("Enter new map name (no spaces):");
    if (!newName) return;
    newName = newName.trim().replace(/\s+/g, '_');
    if (mapsCache.has(newName)) {
      alert("Map name already exists!");
      return;
    }
    mapsCache.set(newName, { boxes: [], connections: [], center: { x:0, y:0, scale:1 }});
    const option = document.createElement('option');
    option.value = newName;
    option.textContent = newName;
    mapSelect.appendChild(option);
    mapSelect.value = newName;
    currentMapId = newName;
    clearCanvas();
    saveCurrentMapDebounced();
  });

  // Rename map button

  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    let newName = prompt("Enter new name for map (no spaces):", currentMapId);
    if (!newName) return;
    newName = newName.trim().replace(/\s+/g, '_');
    if (newName === currentMapId) return;
    if (mapsCache.has(newName)) {
      alert("Map name already exists!");
      return;
    }
    // Save current map data under new name
    const data = mapsCache.get(currentMapId);
    mapsCache.set(newName, data);
    mapsCache.delete(currentMapId);
    // Remove old doc, save new doc
    await deleteDoc(doc(db, "maps", currentMapId));
    currentMapId = newName;
    await saveCurrentMap();
    // Update select options
    const option = [...mapSelect.options].find(o => o.value === currentMapId);
    if (option) option.value = newName;
    await loadMapsList();
  });

  // Delete map button

  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return;
    if (!confirm(`Delete map "${currentMapId}"? This cannot be undone.`)) return;
    await deleteDoc(doc(db, "maps", currentMapId));
    mapsCache.delete(currentMapId);
    await loadMapsList();
  });

  // Save button

  saveMapBtn.addEventListener('click', saveCurrentMap);

  // Center and mark buttons

  goCenterBtn.addEventListener('click', () => {
    panX = 0; panY = 0; scale = 1;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    // Save current pan and zoom as center in map data
    if (!currentMapId) return;
    if (!mapsCache.has(currentMapId)) return;
    const data = mapsCache.get(currentMapId);
    data.center = { x: panX, y: panY, scale };
    mapsCache.set(currentMapId, data);
    saveCurrentMapDebounced();
  });

  // Toggle edit mode button

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    boxesMap.forEach(({element, content}) => {
      content.contentEditable = editMode;
      element.querySelectorAll('button').forEach(btn => btn.style.display = editMode ? '' : 'none');
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  // How To modal

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Utility debounce function
  function debounce(fn, delay) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), delay);
    };
  }

  // Initialize

  (async () => {
    await loadMapsList();
  })();

  // Double click to create box

  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    // Calculate coordinates relative to canvas (taking pan and scale into account)
    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    const id = generateId();
    createBox(id, x, y);
    saveCurrentMapDebounced();
  });
</script>
</body>
</html>
