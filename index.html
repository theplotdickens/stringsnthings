<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
      user-select: none;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
      user-select: none;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: text;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
      z-index: 20;
    }
    .box.selected {
      outline: 3px solid #3377ff;
      outline-offset: -3px;
    }
    .box-header {
      background: #ddd;
      padding: 1px 4px;
      display: flex;
      justify-content: flex-start; /* Sidebar on left */
      align-items: center;
      gap: 4px;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      height: 18px;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    /* Sidebar container for buttons, stacked vertically */
    .box-header > button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      margin-right: 2px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      user-select: none;
      padding: 0;
      font-weight: bold;
      font-size: 14px;
      line-height: 1;
      transition: background-color 0.25s ease;
    }
    .delete-btn {
      color: red;
      background: transparent;
    }
    .connect-toggle {
      background-color: blue;
      color: white;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .box-content {
      flex: 1;
      padding: 6px 8px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow: auto;
      outline: none;
      cursor: text;
      font-size: 16px;
      line-height: 1.2;
      min-height: 24px;
      word-break: break-word;
      box-sizing: border-box;
      resize: none;
      user-select: text;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 25;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: auto;
      z-index: 5;
    }
    path.connection {
      stroke: black;
      stroke-width: 2;
      fill: none;
      cursor: pointer;
      transition: stroke 0.2s ease;
    }
    path.connection.selected {
      stroke: #3377ff;
      stroke-width: 3;
    }

    /* Selection rectangle */
    #selectionRect {
      position: fixed;
      border: 1px dashed #3377ff;
      background: rgba(50, 120, 255, 0.15);
      display: none;
      pointer-events: none;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <div id="viewport" tabindex="0">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
    <div id="selectionRect"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="selectModeBtn" class="floatingBtn">Select Mode: OFF</button>
    <button id="deleteSelectedBtn" class="floatingBtn" disabled>Delete Selected</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
  </div>

  <div id="zoomDisplay">Zoom: 100%</div>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

  <script>
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
      authDomain: "stringsnthings-65aa0.firebaseapp.com",
      projectId: "stringsnthings-65aa0",
      storageBucket: "stringsnthings-65aa0.firebasestorage.app",
      messagingSenderId: "35780192306",
      appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    const canvas = document.getElementById('canvas');
    const viewport = document.getElementById('viewport');
    const undoBtn = document.getElementById('undoBtn');
    const selectModeBtn = document.getElementById('selectModeBtn');
    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    const goCenterBtn = document.getElementById('goCenterBtn');
    const markCenterBtn = document.getElementById('markCenterBtn');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const connectionLayer = document.getElementById('connectionLayer');
    const selectionRect = document.getElementById('selectionRect');

    let scale = 1, panX = 0, panY = 0;
    let isPanning = false, startX, startY;

    let undoStack = [];

    let connections = [];

    let selectedBoxes = new Set();
    let selectedConnections = new Set();

    let selectMode = false; // Toggle select mode on/off

    // Utilities
    function generateId() {
      return 'id_' + Math.random().toString(36).substr(2, 9);
    }

    // Pan and zoom with limits
    const MIN_SCALE = 0.5;
    const MAX_SCALE = 3;

    function updateTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      connectionLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      zoomDisplay.textContent = `Zoom: ${Math.round(scale*100)}%`;
      drawConnections();
      if (centerMarker) updateCenterMarkerPosition();
    }

    // Panning handlers
    viewport.addEventListener('pointerdown', e => {
      if (selectMode) return; // Disable pan if select mode active
      if (e.target.closest('.box') || e.target.closest('button') || e.target === connectionLayer) return;
      isPanning = true;
      const coords = {x: e.clientX, y: e.clientY};
      startX = coords.x;
      startY = coords.y;
      viewport.setPointerCapture(e.pointerId);
      viewport.style.cursor = 'grabbing';
    });
    viewport.addEventListener('pointermove', e => {
      if (!isPanning) return;
      const coords = {x: e.clientX, y: e.clientY};
      panX += coords.x - startX;
      panY += coords.y - startY;
      startX = coords.x;
      startY = coords.y;
      updateTransform();
    });
    viewport.addEventListener('pointerup', e => {
      if (!isPanning) return;
      isPanning = false;
      viewport.releasePointerCapture(e.pointerId);
      viewport.style.cursor = 'grab';
      saveAll();
    });
    viewport.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
      let newScale = scale * dir;
      newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const wx = (mouseX - panX) / scale;
      const wy = (mouseY - panY) / scale;
      scale = newScale;
      panX = mouseX - wx * scale;
      panY = mouseY - wy * scale;
      updateTransform();
      saveAll();
    }, {passive: false});

    // Boxes and selection management
    function createBox(x, y, text='Text box', id=null, width=180, height=80, fontSize='16px') {
      const box = document.createElement('div');
      box.className = 'box';
      box.style.left = x + 'px';
      box.style.top = y + 'px';
      box.style.width = width + 'px';
      box.style.height = height + 'px';
      box.spellcheck = false;

      const header = document.createElement('div');
      header.className = 'box-header';

      const connectToggle = document.createElement('button');
      connectToggle.className = 'connect-toggle';
      connectToggle.title = 'Connect';
      connectToggle.textContent = '⛓';

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = '×';

      header.appendChild(connectToggle);
      header.appendChild(delBtn);

      const content = document.createElement('div');
      content.contentEditable = true;
      content.className = 'box-content';
      content.textContent = text;
      content.style.fontSize = fontSize;

      box.appendChild(header);
      box.appendChild(content);

      // Resize handles
      const handles = {};
      ['nw','ne','sw','se'].forEach(pos => {
        const h = document.createElement('div');
        h.className = 'resize-handle ' + pos;
        box.appendChild(h);
        handles[pos] = h;
      });

      // State vars
      let dragging = false;
      let resizing = false;
      let resizeDir = null;
      let offsetX = 0, offsetY = 0;
      let startWidth, startHeight, startXpos, startYpos, startClientX, startClientY;

      // Drag box by header (only if not select mode)
      header.addEventListener('pointerdown', e => {
        if (selectMode) return;
        if (e.target === delBtn || e.target === connectToggle) return;
        dragging = true;
        offsetX = e.clientX - box.offsetLeft;
        offsetY = e.clientY - box.offsetTop;
        startXpos = box.offsetLeft;
        startYpos = box.offsetTop;
        e.preventDefault();
        box.setPointerCapture(e.pointerId);
      });
      header.addEventListener('pointermove', e => {
        if (!dragging) return;
        e.preventDefault();
        let newX = e.clientX - offsetX;
        let newY = e.clientY - offsetY;
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';
        drawConnections();
      });
      header.addEventListener('pointerup', e => {
        if (!dragging) return;
        dragging = false;
        box.releasePointerCapture(e.pointerId);
        saveAll();
      });

      // Resize handles logic
      Object.entries(handles).forEach(([dir, handle]) => {
        handle.addEventListener('pointerdown', e => {
          if (selectMode) return;
          e.stopPropagation();
          resizing = true;
          resizeDir = dir;
          startWidth = box.offsetWidth;
          startHeight = box.offsetHeight;
          startXpos = box.offsetLeft;
          startYpos = box.offsetTop;
          startClientX = e.clientX;
          startClientY = e.clientY;
          handle.setPointerCapture(e.pointerId);
          e.preventDefault();
        });
        handle.addEventListener('pointermove', e => {
          if (!resizing || !handle.hasPointerCapture(e.pointerId)) return;
          e.preventDefault();
          const dx = e.clientX - startClientX;
          const dy = e.clientY - startClientY;
          let newLeft = startXpos;
          let newTop = startYpos;
          let newWidth = startWidth;
          let newHeight = startHeight;
          if (resizeDir.includes('e')) newWidth = Math.max(80, startWidth + dx);
          if (resizeDir.includes('s')) newHeight = Math.max(40, startHeight + dy);
          if (resizeDir.includes('w')) {
            newWidth = Math.max(80, startWidth - dx);
            newLeft = startXpos + dx;
          }
          if (resizeDir.includes('n')) {
            newHeight = Math.max(40, startHeight - dy);
            newTop = startYpos + dy;
          }
          box.style.width = newWidth + 'px';
          box.style.height = newHeight + 'px';
          box.style.left = newLeft + 'px';
          box.style.top = newTop + 'px';
          smoothAdjustFontSize(content, box);
          drawConnections();
        });
        handle.addEventListener('pointerup', e => {
          if (!resizing) return;
          resizing = false;
          resizeDir = null;
          handle.releasePointerCapture(e.pointerId);
          saveAll();
        });
      });

      // Connect toggle
      connectToggle.addEventListener('click', e => {
        e.stopPropagation();
        if (!selectMode) return; // only allow connections in select mode
        if (selectedBoxes.has(box.dataset.id)) {
          selectedBoxes.delete(box.dataset.id);
          connectToggle.classList.remove('active');
          updateSelectionVisuals();
          return;
        }
        selectedBoxes.add(box.dataset.id);
        updateSelectionVisuals();
      });

      // Delete button on box (only in select mode)
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (!selectMode) return;
        deleteBox(box.dataset.id);
      });

      // Click on box for selection (only in select mode)
      box.addEventListener('click', e => {
        if (!selectMode) return;
        e.stopPropagation();
        if (e.shiftKey) {
          if (selectedBoxes.has(box.dataset.id)) selectedBoxes.delete(box.dataset.id);
          else selectedBoxes.add(box.dataset.id);
        } else {
          selectedBoxes.clear();
          selectedConnections.clear();
          selectedBoxes.add(box.dataset.id);
        }
        updateSelectionVisuals();
      });

      // Text content input updates save & font size
      content.addEventListener('input', () => {
        smoothAdjustFontSize(content, box);
        saveAll();
      });

      // Assign id or generate
      box.dataset.id = id || generateId();

      canvas.appendChild(box);
      smoothAdjustFontSize(content, box);
      updateSelectionVisuals();

      return box;
    }

    // Adjust font size to fill box nicely
    function smoothAdjustFontSize(contentDiv, box) {
      const padding = 14;
      const maxWidth = box.clientWidth - padding;
      const maxHeight = box.clientHeight - padding;
      let minSize = 8;
      let maxSize = 72;
      let fontSize = 16;
      while (minSize <= maxSize) {
        const mid = Math.floor((minSize + maxSize) / 2);
        contentDiv.style.fontSize = mid + 'px';
        if (contentDiv.scrollWidth <= maxWidth && contentDiv.scrollHeight <= maxHeight) {
          fontSize = mid;
          minSize = mid + 1;
        } else {
          maxSize = mid - 1;
        }
      }
      contentDiv.style.fontSize = fontSize + 'px';
    }

    // Draw connections as curved paths under boxes
    function drawConnections() {
      connectionLayer.innerHTML = '';
      connections.forEach(conn => {
        const fromBox = document.querySelector(`.box[data-id='${conn.from}']`);
        const toBox = document.querySelector(`.box[data-id='${conn.to}']`);
        if (!fromBox || !toBox) return;
        const fromRect = fromBox.getBoundingClientRect();
        const toRect = toBox.getBoundingClientRect();
        const viewportRect = viewport.getBoundingClientRect();

        // Calculate points relative to viewport
        const startX = (fromRect.left + fromRect.width / 2 - viewportRect.left - panX) / scale;
        const startY = (fromRect.top + fromRect.height / 2 - viewportRect.top - panY) / scale;
        const endX = (toRect.left + toRect.width / 2 - viewportRect.left - panX) / scale;
        const endY = (toRect.top + toRect.height / 2 - viewportRect.top - panY) / scale;

        // Simple cubic bezier curve for smooth connection
        const deltaX = Math.abs(endX - startX);
        const controlX1 = startX + deltaX / 2;
        const controlY1 = startY;
        const controlX2 = endX - deltaX / 2;
        const controlY2 = endY;

        const pathString = `M${startX},${startY} C${controlX1},${controlY1} ${controlX2},${controlY2} ${endX},${endY}`;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathString);
        path.setAttribute('class', 'connection');
        path.dataset.from = conn.from;
        path.dataset.to = conn.to;

        if (selectedConnections.has(conn.id)) {
          path.classList.add('selected');
        }

        path.addEventListener('click', e => {
          if (!selectMode) return;
          e.stopPropagation();
          if (selectedConnections.has(conn.id)) {
            selectedConnections.delete(conn.id);
          } else {
            selectedConnections.add(conn.id);
          }
          updateSelectionVisuals();
        });

        connectionLayer.appendChild(path);
      });
    }

    // Selection visuals sync
    function updateSelectionVisuals() {
      document.querySelectorAll('.box').forEach(box => {
        const id = box.dataset.id;
        if (selectedBoxes.has(id)) {
          box.classList.add('selected');
          box.querySelector('.connect-toggle').classList.add('active');
        } else {
          box.classList.remove('selected');
          box.querySelector('.connect-toggle').classList.remove('active');
        }
      });
      drawConnections();
      deleteSelectedBtn.disabled = (selectedBoxes.size === 0 && selectedConnections.size === 0);
    }

    // Delete box and related connections
    function deleteBox(id) {
      const box = document.querySelector(`.box[data-id='${id}']`);
      if (!box) return;
      const relatedConns = connections.filter(c => c.from === id || c.to === id);
      undoStack.push({
        type: 'delete',
        boxes: [{ id: id, text: box.querySelector('.box-content').textContent, left: box.offsetLeft, top: box.offsetTop, width: box.offsetWidth, height: box.offsetHeight, fontSize: box.querySelector('.box-content').style.fontSize }],
        connections: relatedConns.slice()
      });
      box.remove();
      connections = connections.filter(c => c.from !== id && c.to !== id);
      selectedBoxes.delete(id);
      selectedConnections.clear();
      updateSelectionVisuals();
      undoBtn.disabled = false;
      saveAll();
    }
    // Delete connections
    function deleteConnection(connId) {
      const idx = connections.findIndex(c => c.id === connId);
      if (idx < 0) return;
      const removed = connections.splice(idx, 1)[0];
      undoStack.push({type:'delete', boxes:[], connections:[removed]});
      selectedConnections.delete(connId);
      updateSelectionVisuals();
      undoBtn.disabled = false;
      saveAll();
    }

    // Undo delete
    undoBtn.addEventListener('click', () => {
      if (undoStack.length === 0) return;
      const last = undoStack.pop();
      if (last.type === 'delete') {
        last.boxes.forEach(b => {
          const box = createBox(b.left, b.top, b.text, b.id, b.width, b.height, b.fontSize);
        });
        connections.push(...last.connections);
        updateSelectionVisuals();
        saveAll();
      }
      undoBtn.disabled = undoStack.length === 0;
    });

    // Select mode toggle
    selectModeBtn.addEventListener('click', () => {
      selectMode = !selectMode;
      if (!selectMode) {
        selectedBoxes.clear();
        selectedConnections.clear();
        updateSelectionVisuals();
        viewport.style.cursor = 'grab';
      } else {
        viewport.style.cursor = 'default';
      }
      selectModeBtn.textContent = `Select Mode: ${selectMode ? 'ON' : 'OFF'}`;
      deleteSelectedBtn.disabled = (selectedBoxes.size === 0 && selectedConnections.size === 0);
    });

    // Delete selected button
    deleteSelectedBtn.addEventListener('click', () => {
      if (!selectMode) return;
      // Delete selected connections
      selectedConnections.forEach(connId => {
        deleteConnection(connId);
      });
      // Delete selected boxes
      selectedBoxes.forEach(boxId => {
        deleteBox(boxId);
      });
      selectedBoxes.clear();
      selectedConnections.clear();
      updateSelectionVisuals();
    });

    // Keyboard shortcuts for delete
    viewport.addEventListener('keydown', e => {
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (!selectMode) return;
        e.preventDefault();
        deleteSelectedBtn.click();
      }
    });

    // Connections between exactly two selected boxes
    function updateConnections() {
      if (selectedBoxes.size !== 2) return;
      const arr = Array.from(selectedBoxes);
      // Check if connection exists
      let existing = connections.find(c => (c.from === arr[0] && c.to === arr[1]) || (c.from === arr[1] && c.to === arr[0]));
      if (existing) return; // Already connected
      // Create connection
      const newConn = { id: generateId(), from: arr[0], to: arr[1] };
      connections.push(newConn);
      updateSelectionVisuals();
      saveAll();
    }

    // When clicking connect toggle, if two boxes selected, create connection
    // Actually here the connect toggle just selects boxes for connection, so we add a button to finalize connection
    // We'll add a "Create Connection" button that only enables if exactly 2 boxes selected
    // But user did not ask for separate connect button. So we implement connection creation on toggling exactly 2 boxes selected.

    // Monitor selection changes and auto connect if 2 boxes selected
    function onSelectionChange() {
      if (selectMode && selectedBoxes.size === 2) {
        updateConnections();
        // After connection creation, clear selection to prevent repeated
        selectedBoxes.clear();
        updateSelectionVisuals();
      }
      deleteSelectedBtn.disabled = (selectedBoxes.size === 0 && selectedConnections.size === 0);
    }

    // Hook selection update to call onSelectionChange
    const originalUpdateSelectionVisuals = updateSelectionVisuals;
    updateSelectionVisuals = function() {
      originalUpdateSelectionVisuals();
      onSelectionChange();
    };

    // Add new box on double-click on empty space
    viewport.addEventListener('dblclick', e => {
      if (e.target !== viewport) return;
      if (selectMode) return; // no new box in select mode
      const rect = viewport.getBoundingClientRect();
      const x = (e.clientX - rect.left - panX) / scale;
      const y = (e.clientY - rect.top - panY) / scale;
      createBox(x, y, 'New Box');
      saveAll();
    });

    // Save/load state to localStorage for persistence
    function saveAll() {
      const boxesData = [];
      document.querySelectorAll('.box').forEach(box => {
        const content = box.querySelector('.box-content');
        boxesData.push({
          id: box.dataset.id,
          left: box.offsetLeft,
          top: box.offsetTop,
          width: box.offsetWidth,
          height: box.offsetHeight,
          text: content.textContent,
          fontSize: content.style.fontSize || '16px',
        });
      });
      const data = {
        boxes: boxesData,
        connections: connections,
        panX, panY, scale,
        centerMarker,
      };
      localStorage.setItem('stringsnthingsData', JSON.stringify(data));
    }
    function loadAll() {
      const dataStr = localStorage.getItem('stringsnthingsData');
      if (!dataStr) return;
      try {
        const data = JSON.parse(dataStr);
        panX = data.panX || 0;
        panY = data.panY || 0;
        scale = data.scale || 1;
        connections = data.connections || [];
        centerMarker = data.centerMarker || null;
        canvas.innerHTML = '';
        data.boxes.forEach(b => {
          createBox(b.left, b.top, b.text, b.id, b.width, b.height, b.fontSize);
        });
        updateTransform();
        updateSelectionVisuals();
      } catch (err) {
        console.error('Load failed', err);
      }
    }

    // Undo stack disabled on load
    undoBtn.disabled = true;

    // Selection rectangle for multi-select
    let selectionStart = null;
    viewport.addEventListener('pointerdown', e => {
      if (!selectMode) return;
      if (e.target.closest('.box') || e.target.closest('button') || e.target === connectionLayer) return;
      selectionStart = {x: e.clientX, y: e.clientY};
      selectionRect.style.left = e.clientX + 'px';
      selectionRect.style.top = e.clientY + 'px';
      selectionRect.style.width = '0px';
      selectionRect.style.height = '0px';
      selectionRect.style.display = 'block';
      viewport.setPointerCapture(e.pointerId);
      e.preventDefault();
    });
    viewport.addEventListener('pointermove', e => {
      if (!selectionStart) return;
      const x = Math.min(e.clientX, selectionStart.x);
      const y = Math.min(e.clientY, selectionStart.y);
      const w = Math.abs(e.clientX - selectionStart.x);
      const h = Math.abs(e.clientY - selectionStart.y);
      selectionRect.style.left = x + 'px';
      selectionRect.style.top = y + 'px';
      selectionRect.style.width = w + 'px';
      selectionRect.style.height = h + 'px';
    });
    viewport.addEventListener('pointerup', e => {
      if (!selectionStart) return;
      selectionRect.style.display = 'none';
      const rect = selectionRect.getBoundingClientRect();
      selectedBoxes.clear();
      selectedConnections.clear();

      document.querySelectorAll('.box').forEach(box => {
        const boxRect = box.getBoundingClientRect();
        if (
          boxRect.left >= rect.left &&
          boxRect.right <= rect.right &&
          boxRect.top >= rect.top &&
          boxRect.bottom <= rect.bottom
        ) {
          selectedBoxes.add(box.dataset.id);
        }
      });
      // We don't select connections by rectangle, only boxes
      updateSelectionVisuals();

      selectionStart = null;
      viewport.releasePointerCapture(e.pointerId);
    });

    // Mark Center and Go to Center logic
    let centerMarker = null;
    let centerMarkerDiv = null;
    function updateCenterMarkerPosition() {
      if (!centerMarkerDiv || !centerMarker) return;
      const rect = viewport.getBoundingClientRect();
      const x = centerMarker.x * scale + panX + rect.left;
      const y = centerMarker.y * scale + panY + rect.top;
      centerMarkerDiv.style.left = x + 'px';
      centerMarkerDiv.style.top = y + 'px';
    }
    markCenterBtn.addEventListener('click', () => {
      const rect = viewport.getBoundingClientRect();
      const centerX = (rect.width / 2 - panX) / scale;
      const centerY = (rect.height / 2 - panY) / scale;
      centerMarker = {x: centerX, y: centerY};
      if (!centerMarkerDiv) {
        centerMarkerDiv = document.createElement('div');
        centerMarkerDiv.style.position = 'fixed';
        centerMarkerDiv.style.width = '20px';
        centerMarkerDiv.style.height = '20px';
        centerMarkerDiv.style.backgroundColor = 'rgba(255,0,0,0.7)';
        centerMarkerDiv.style.borderRadius = '50%';
        centerMarkerDiv.style.pointerEvents = 'none';
        centerMarkerDiv.style.zIndex = 1500;
        document.body.appendChild(centerMarkerDiv);
      }
      updateCenterMarkerPosition();
      saveAll();
    });
    goCenterBtn.addEventListener('click', () => {
      if (!centerMarker) return;
      const rect = viewport.getBoundingClientRect();
      panX = rect.width / 2 - centerMarker.x * scale;
      panY = rect.height / 2 - centerMarker.y * scale;
      updateTransform();
      saveAll();
    });

    // Keyboard shortcuts: Esc clears selections
    viewport.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        if (selectMode) {
          selectedBoxes.clear();
          selectedConnections.clear();
          updateSelectionVisuals();
        }
      }
    });

    // Prevent default tab on contenteditable boxes, allow shift+tab to move out
    canvas.addEventListener('keydown', e => {
      if (e.target.classList.contains('box-content')) {
        if (e.key === 'Tab' && !e.shiftKey) {
          e.preventDefault();
          // insert 2 spaces at caret position
          const sel = window.getSelection();
          if (!sel.rangeCount) return;
          const range = sel.getRangeAt(0);
          const tabNode = document.createTextNode('  ');
          range.insertNode(tabNode);
          range.setStartAfter(tabNode);
          range.setEndAfter(tabNode);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
    });

    // On load, restore saved state
    loadAll();
    updateTransform();

    // Save on unload
    window.addEventListener('beforeunload', () => {
      saveAll();
    });
  </script>
</body>
</html>
