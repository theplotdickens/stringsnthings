<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings with Curvy Lines + Undo + Rounded Label</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
  }
  #canvas {
    position: absolute; top: 0; left: 0; transform-origin: 0 0;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    padding: 8px;
    min-width: 80px;
    min-height: 40px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    user-select: text;
    touch-action: none;
    cursor: text;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    z-index: 10;
  }
  .box > div[contenteditable="true"] {
    outline: none;
    white-space: pre-wrap;
    word-break: break-word;
    font-family: monospace, monospace;
    user-select: text;
    cursor: text;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: 1.2;
  }
  .delete-btn {
    position: absolute;
    top: 2px; right: 4px;
    cursor: pointer;
    color: red;
    font-weight: bold;
    user-select: none;
    pointer-events: auto;
    z-index: 20;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn.active {
    background: rgba(50, 150, 200, 0.8);
    color: white;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }

  /* SVG styling */
  #lineLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    overflow: visible;
    z-index: 5;
  }
  .line-path {
    fill: none;
    stroke: #222;
    stroke-width: 8;
    stroke-linejoin: round;
    stroke-linecap: round;
  }
  .label-group text {
    fill: white;
    font-weight: bold;
    font-size: 14px;
    pointer-events: none;
    user-select: none;
  }
  .label-background {
    fill: rgba(50, 50, 50, 0.8);
    rx: 8;
    ry: 8;
  }
</style>
</head>
<body>
<div id="viewport">
  <svg id="lineLayer" xmlns="http://www.w3.org/2000/svg" aria-label="Lines layer"></svg>
  <div id="canvas"></div>
</div>

<div id="buttonContainer">
  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
  <button id="undoLineBtn" class="floatingBtn" disabled>Undo Line</button>
  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
  <button id="drawLineToggle" class="floatingBtn">Draw Line OFF</button>
</div>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.firebasestorage.app",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const lineLayer = document.getElementById('lineLayer');

  const undoBtn = document.getElementById('undoBtn');
  const undoLineBtn = document.getElementById('undoLineBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const drawLineToggle = document.getElementById('drawLineToggle');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;
  const undoStack = [];
  const undoLineStack = [];

  let drawLineMode = false;
  let selectedBoxes = [];
  let currentPathPoints = [];
  let isDrawingPath = false;

  const boxesCollection = db.collection('boxes');
  const linesCollection = db.collection('lines');

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    lineLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (drawLineMode) return; // no pan when drawing lines
    if (e.target.closest('.box') || e.target === goCenterBtn || e.target === undoBtn || e.target === undoLineBtn || e.target === drawLineToggle) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
  });
  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });
  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    scale *= dir;
    updateTransform();
  });

  // Box dragging variables
  const draggingInfo = {
    dragging: false,
    offsetX: 0,
    offsetY: 0,
    currentBox: null,
  };

  // Map box element => firestore doc id
  const idMap = new Map();
  // Map line doc id => {path, label, startBoxId, endBoxId, svg elements}
  const linesMap = new Map();

  function adjustFontSizeToFit(contentDiv, box) {
    const padding = 8;
    const maxFontSize = 100;
    const minFontSize = 8;
    contentDiv.style.fontSize = maxFontSize + 'px';
    const boxWidth = box.clientWidth - padding * 2;
    const boxHeight = box.clientHeight - padding * 2;
    let fontSize = maxFontSize;
    while (fontSize >= minFontSize) {
      contentDiv.style.fontSize = fontSize + 'px';
      if (contentDiv.scrollWidth <= boxWidth && contentDiv.scrollHeight <= boxHeight) break;
      fontSize -= 1;
    }
    if (fontSize < minFontSize) fontSize = minFontSize;
    contentDiv.style.fontSize = fontSize + 'px';
  }

  function addBox(x, y, text = 'Text box', id = null, width=180, height=80, fontSize='16px') {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = width + 'px';
    box.style.height = height + 'px';

    const content = document.createElement('div');
    content.contentEditable = true;
    content.style.minWidth = '80px';
    content.style.minHeight = '24px';
    content.style.whiteSpace = 'pre-wrap';
    content.style.wordBreak = 'break-word';
    content.style.outline = 'none';
    content.style.fontFamily = 'monospace, monospace';
    content.textContent = text;
    content.style.userSelect = 'text';
    content.style.cursor = 'text';
    content.style.height = '100%';
    content.style.width = '100%';
    content.style.boxSizing = 'border-box';
    content.style.padding = '0';
    content.style.margin = '0';
    content.style.overflow = 'visible';
    content.style.lineHeight = '1.2';
    content.style.fontSize = fontSize || '16px';

    if (fontSize === '16px' || !fontSize) {
      adjustFontSizeToFit(content, box);
    }

    content.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.execCommand('insertHTML', false, '\n');
      }
    });

    const delBtn = document.createElement('span');
    delBtn.className = 'delete-btn';
    delBtn.textContent = 'Ã—';

    // Resize handles - invisible corners
    const resizeHandles = {};
    ['nw','ne','sw','se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = `resize-handle ${pos}`;
      box.appendChild(handle);
      resizeHandles[pos] = handle;
    });

    box.appendChild(content);
    box.appendChild(delBtn);

    // Dragging logic
    box.addEventListener('pointerdown', e => {
      if (e.target === delBtn) return;
      if (Object.values(resizeHandles).includes(e.target)) return; // skip if resizing

      if (drawLineMode) {
        e.stopPropagation();
        handleBoxSelection(box);
        return;
      }
      if (drawLineMode) return; // no drag when drawing lines
      draggingInfo.dragging = true;
      draggingInfo.offsetX = e.clientX - box.getBoundingClientRect().left;
      draggingInfo.offsetY = e.clientY - box.getBoundingClientRect().top;
      draggingInfo.currentBox = box;
      box.setPointerCapture(e.pointerId);
      box.style.cursor = 'grabbing';
    });
    box.addEventListener('pointermove', e => {
      if (!draggingInfo.dragging || draggingInfo.currentBox !== box) return;
      const newX = (e.clientX - draggingInfo.offsetX - panX) / scale;
      const newY = (e.clientY - draggingInfo.offsetY - panY) / scale;
      box.style.left = `${newX}px`;
      box.style.top = `${newY}px`;
      saveBox(box);
      updateLinesForBox(idMap.get(box));
    });
    box.addEventListener('pointerup', e => {
      if (draggingInfo.currentBox === box) {
        draggingInfo.dragging = false;
        draggingInfo.currentBox.style.cursor = 'text';
        draggingInfo.currentBox.releasePointerCapture(e.pointerId);
        draggingInfo.currentBox = null;
      }
    });

    // Resizing logic
    Object.entries(resizeHandles).forEach(([pos, handle]) => {
      let startX, startY, startWidth, startHeight, startLeft, startTop;

      handle.addEventListener('pointerdown', e => {
        e.stopPropagation();
        draggingInfo.dragging = false;
        draggingInfo.currentBox = null;

        startX = e.clientX;
        startY = e.clientY;
        startWidth = box.offsetWidth;
        startHeight = box.offsetHeight;
        startLeft = parseFloat(box.style.left);
        startTop = parseFloat(box.style.top);

        function onPointerMove(ev) {
          ev.preventDefault();
          const dx = (ev.clientX - startX) / scale;
          const dy = (ev.clientY - startY) / scale;

          let newWidth = startWidth;
          let newHeight = startHeight;
          let newLeft = startLeft;
          let newTop = startTop;

          if (pos.includes('e')) {
            newWidth = Math.max(80, startWidth + dx);
          }
          if (pos.includes('s')) {
            newHeight = Math.max(40, startHeight + dy);
          }
          if (pos.includes('w')) {
            newWidth = Math.max(80, startWidth - dx);
            newLeft = startLeft + dx;
          }
          if (pos.includes('n')) {
            newHeight = Math.max(40, startHeight - dy);
            newTop = startTop + dy;
          }

          box.style.width = `${newWidth}px`;
          box.style.height = `${newHeight}px`;
          box.style.left = `${newLeft}px`;
          box.style.top = `${newTop}px`;

          adjustFontSizeToFit(content, box);
          saveBox(box);
          updateLinesForBox(idMap.get(box));
        }

        function onPointerUp(ev) {
          ev.preventDefault();
          window.removeEventListener('pointermove', onPointerMove);
          window.removeEventListener('pointerup', onPointerUp);
        }

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      });
    });

    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      undoStack.push({
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        text: content.textContent,
        width: box.offsetWidth,
        height: box.offsetHeight,
        fontSize: content.style.fontSize,
        id: idMap.get(box)
      });
      if (undoStack.length > 5) undoStack.shift();
      undoBtn.disabled = false;
      if (idMap.has(box)) {
        removeLinesForBox(idMap.get(box));
        boxesCollection.doc(idMap.get(box)).delete();
      }
      box.remove();
    });

    content.addEventListener('input', () => {
      adjustFontSizeToFit(content, box);
      saveBox(box);
    });

    function saveBox(boxElement) {
      const data = {
        x: parseFloat(boxElement.style.left),
        y: parseFloat(boxElement.style.top),
        width: boxElement.offsetWidth,
        height: boxElement.offsetHeight,
        text: boxElement.querySelector('div[contenteditable]').textContent,
        fontSize: boxElement.querySelector('div[contenteditable]').style.fontSize || '16px'
      };
      const boxId = idMap.get(boxElement);
      if (boxId) {
        boxesCollection.doc(boxId).set(data);
      } else {
        boxesCollection.add(data).then(docRef => {
          idMap.set(boxElement, docRef.id);
        });
      }
    }

    canvas.appendChild(box);
    if (!id) {
      boxesCollection.add({
        x, y, width, height,
        text, fontSize
      }).then(docRef => {
        idMap.set(box, docRef.id);
      });
    } else {
      idMap.set(box, id);
    }

    return box;
  }

  // Undo buttons
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastBox = undoStack.pop();
    addBox(lastBox.x, lastBox.y, lastBox.text, null, lastBox.width, lastBox.height, lastBox.fontSize);
    if (undoStack.length === 0) undoBtn.disabled = true;
  });
  undoLineBtn.addEventListener('click', () => {
    if (undoLineStack.length === 0) return;
    const lastLineId = undoLineStack.pop();
    const lineData = linesMap.get(lastLineId);
    if (lineData) {
      drawLine(lineData.startBoxId, lineData.endBoxId, lineData.label, lastLineId);
    }
    if (undoLineStack.length === 0) undoLineBtn.disabled = true;
  });

  // Center view button
  goCenterBtn.addEventListener('click', () => {
    panX = window.innerWidth / 2 - 100; // Rough center offset
    panY = window.innerHeight / 2 - 100;
    scale = 1;
    updateTransform();
  });

  // Draw line toggle button
  drawLineToggle.addEventListener('click', () => {
    drawLineMode = !drawLineMode;
    drawLineToggle.textContent = drawLineMode ? 'Draw Line ON' : 'Draw Line OFF';
    if (!drawLineMode) {
      selectedBoxes = [];
    }
  });

  // Box selection for line drawing
  function handleBoxSelection(box) {
    if (selectedBoxes.includes(box)) {
      selectedBoxes = selectedBoxes.filter(b => b !== box);
      box.style.borderColor = 'black';
    } else {
      selectedBoxes.push(box);
      box.style.borderColor = 'blue';
    }
    if (selectedBoxes.length === 2) {
      const startId = idMap.get(selectedBoxes[0]);
      const endId = idMap.get(selectedBoxes[1]);
      const label = prompt('Label for this connection:', 'connection');
      if (label !== null) {
        createLine(startId, endId, label);
      }
      selectedBoxes.forEach(b => b.style.borderColor = 'black');
      selectedBoxes = [];
    }
  }

  // Create or update a line in Firestore
  function createLine(startBoxId, endBoxId, label) {
    linesCollection.add({ startBoxId, endBoxId, label }).then(docRef => {
      undoLineStack.push(docRef.id);
      undoLineBtn.disabled = false;
      drawLine(startBoxId, endBoxId, label, docRef.id);
    });
  }

  // Draw or update a line given start/end box ids and label
  function drawLine(startId, endId, label, lineId) {
    // Remove old SVG group if exists
    if (linesMap.has(lineId)) {
      const old = linesMap.get(lineId);
      old.svgGroup.remove();
      linesMap.delete(lineId);
    }

    const startBox = [...idMap.entries()].find(([box, id]) => id === startId)?.[0];
    const endBox = [...idMap.entries()].find(([box, id]) => id === endId)?.[0];
    if (!startBox || !endBox) return;

    // Get center coords of each box relative to canvas
    const startRect = startBox.getBoundingClientRect();
    const endRect = endBox.getBoundingClientRect();
    const viewportRect = viewport.getBoundingClientRect();

    const startX = (startRect.left - viewportRect.left - panX) / scale + startRect.width / 2;
    const startY = (startRect.top - viewportRect.top - panY) / scale + startRect.height / 2;

    const endX = (endRect.left - viewportRect.left - panX) / scale + endRect.width / 2;
    const endY = (endRect.top - viewportRect.top - panY) / scale + endRect.height / 2;

    // Quadratic Bezier control point for smooth curve - mid top between start and end + vertical offset
    const cpX = (startX + endX) / 2;
    const cpY = Math.min(startY, endY) - 80;

    const pathD = `M ${startX} ${startY} Q ${cpX} ${cpY} ${endX} ${endY}`;

    // Create group for path and label
    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.classList.add("label-group");

    // Create path
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", pathD);
    path.setAttribute("class", "line-path");
    group.appendChild(path);

    // Create label background rect and text
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.textContent = label;
    text.setAttribute("x", "0");
    text.setAttribute("y", "0");
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    group.appendChild(text);

    const bbox = text.getBBox();

    const paddingX = 12;
    const paddingY = 6;

    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("class", "label-background");
    rect.setAttribute("width", bbox.width + paddingX * 2);
    rect.setAttribute("height", bbox.height + paddingY * 2);
    rect.setAttribute("rx", 8);
    rect.setAttribute("ry", 8);
    rect.setAttribute("x", - (bbox.width / 2) - paddingX);
    rect.setAttribute("y", - (bbox.height / 2) - paddingY);
    group.insertBefore(rect, text);

    // Place label group at midpoint on path
    const totalLength = path.getTotalLength();
    const midpoint = path.getPointAtLength(totalLength / 2);
    group.setAttribute("transform", `translate(${midpoint.x}, ${midpoint.y})`);

    lineLayer.appendChild(group);

    // Save to map for future updates/removal
    linesMap.set(lineId, {
      path, text, rect, group,
      startBoxId: startId,
      endBoxId: endId,
      label
    });
  }

  // Update lines attached to a box when it moves/resizes
  function updateLinesForBox(boxId) {
    for (const [lineId, lineData] of linesMap.entries()) {
      if (lineData.startBoxId === boxId || lineData.endBoxId === boxId) {
        drawLine(lineData.startBoxId, lineData.endBoxId, lineData.label, lineId);
      }
    }
  }

  // Remove lines connected to a box when box deleted
  function removeLinesForBox(boxId) {
    for (const [lineId, lineData] of linesMap.entries()) {
      if (lineData.startBoxId === boxId || lineData.endBoxId === boxId) {
        lineData.group.remove();
        linesMap.delete(lineId);
        undoLineStack.push(lineId);
        undoLineBtn.disabled = false;
        linesCollection.doc(lineId).delete();
      }
    }
  }

  // Load existing boxes and lines from firestore
  function loadBoxesAndLines() {
    boxesCollection.get().then(querySnapshot => {
      querySnapshot.forEach(doc => {
        const data = doc.data();
        addBox(data.x, data.y, data.text, doc.id, data.width, data.height, data.fontSize);
      });
    });
    linesCollection.get().then(querySnapshot => {
      querySnapshot.forEach(doc => {
        const data = doc.data();
        drawLine(data.startBoxId, data.endBoxId, data.label, doc.id);
      });
    });
  }

  loadBoxesAndLines();

</script>
</body>
</html>
