<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Strings N Things</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
Â  html, body {
Â  Â  margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
Â  Â  touch-action: none;
Â  }
Â  #viewport {
Â  Â  width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
Â  Â  overflow: hidden;
Â  Â  box-sizing: border-box;
Â  }
Â  #canvas {
Â  Â  position: absolute; top: 0; left: 0;
Â  Â  width: 10000px; height: 10000px;
Â  Â  transform-origin: 0 0;
Â  Â  z-index: 10;
Â  }
Â  .box {
Â  Â  position: absolute;
Â  Â  background: white;
Â  Â  border: 1px solid black;
Â  Â  min-width: 80px;
Â  Â  min-height: 40px;
Â  Â  user-select: none;
Â  Â  box-sizing: border-box;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  cursor: text;
Â  Â  overflow: hidden;
Â  Â  transition: width 0.1s ease, height 0.1s ease;
Â  }
Â  .box.selected {
Â  Â  outline: 2px dashed blue;
Â  }
Â  .box-header {
Â  Â  background: #ddd;
Â  Â  padding-left: 24px;
Â  Â  min-width: 40px;
Â  Â  min-height: 18px;
Â  Â  height: 18px;
Â  Â  box-sizing: border-box;
Â  Â  display: flex;
Â  Â  justify-content: flex-end;
Â  Â  align-items: center;
Â  Â  gap: 4px;
Â  Â  position: relative;
Â  Â  user-select: none;
Â  Â  cursor: default;
Â  Â  border-bottom: 1px solid #bbb;
Â  Â  font-size: 12px;
Â  Â  flex-shrink: 0;
Â  }
Â  .drag-handle {
Â  Â  position: absolute;
Â  Â  left: 4px;
Â  Â  top: 50%;
Â  Â  transform: translateY(-50%);
Â  Â  font-size: 14px;
Â  Â  cursor: move;
Â  Â  user-select: none;
Â  Â  width: 16px;
Â  Â  height: 16px;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  color: #333;
Â  Â  white-space: nowrap;
Â  Â  z-index: 5;
Â  }
Â  .delete-btn {
Â  Â  color: red;
Â  Â  font-weight: bold;
Â  Â  cursor: pointer;
Â  Â  font-size: 14px;
Â  Â  line-height: 1;
Â  Â  user-select: none;
Â  Â  padding: 0;
Â  Â  margin: 0;
Â  Â  border: none;
Â  Â  background: transparent;
Â  Â  width: 18px;
Â  Â  height: 18px;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  }
Â  .connect-toggle {
Â  Â  width: 10px;
Â  Â  height: 10px;
Â  Â  border-radius: 50%;
Â  Â  border: none;
Â  Â  background-color: blue;
Â  Â  cursor: pointer;
Â  Â  user-select: none;
Â  Â  transition: background-color 0.25s ease;
Â  Â  padding: 0;
Â  Â  margin: 0;
Â  Â  flex-shrink: 0;
Â  }
Â  .connect-toggle.active {
Â  Â  background-color: green;
Â  }
Â  .font-size-btn {
Â  Â  font-size: 14px;
Â  Â  width: 18px;
Â  Â  height: 18px;
Â  Â  line-height: 1;
Â  Â  cursor: pointer;
Â  Â  user-select: none;
Â  Â  background: transparent;
Â  Â  border: none;
Â  Â  color: black;
Â  Â  padding: 0;
Â  Â  margin: 0 2px;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  }
Â  .box-content {
Â  Â  flex: 1;
Â  Â  padding: 2px;
Â  Â  white-space: pre-wrap;
Â  Â  font-family: monospace, monospace;
Â  Â  overflow-wrap: break-word;
Â  Â  outline: none;
Â  Â  cursor: text;
Â  Â  user-select: text;
Â  Â  line-height: 1.1;
Â  Â  min-height: 24px;
Â  Â  box-sizing: border-box;
Â  Â  resize: none;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  text-align: center;
Â  Â  word-break: break-word;
Â  }
Â  .resize-handle {
Â  Â  width: 16px;
Â  Â  height: 16px;
Â  Â  background: transparent;
Â  Â  position: absolute;
Â  Â  z-index: 20;
Â  Â  touch-action: none;
Â  }
Â  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
Â  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
Â  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
Â  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

Â  #topMenu {
Â  Â  position: fixed;
Â  Â  top: 8px;
Â  Â  left: 50%;
Â  Â  transform: translateX(-50%);
Â  Â  background: rgba(240, 240, 240, 0.95);
Â  Â  border: 1px solid #bbb;
Â  Â  border-radius: 6px;
Â  Â  padding: 6px 12px;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  gap: 12px;
Â  Â  font-family: monospace;
Â  Â  z-index: 10000;
Â  Â  box-shadow: 0 0 8px rgba(0,0,0,0.1);
Â  Â  user-select: none;
Â  }
Â  #mapSelect {
Â  Â  font-family: monospace;
Â  Â  font-size: 14px;
Â  Â  padding: 2px 4px;
Â  Â  border-radius: 4px;
Â  Â  border: 1px solid #888;
Â  Â  cursor: pointer;
Â  Â  min-width: 150px;
Â  }
Â  #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
Â  Â  background: #555;
Â  Â  color: #eee;
Â  Â  border: none;
Â  Â  border-radius: 4px;
Â  Â  padding: 4px 10px;
Â  Â  cursor: pointer;
Â  Â  font-family: monospace;
Â  Â  font-size: 14px;
Â  Â  user-select: none;
Â  Â  transition: background-color 0.2s ease;
Â  }
Â  #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
Â  Â  background: #333;
Â  }
Â  #saveStatus {
Â  Â  font-size: 13px;
Â  Â  color: green;
Â  Â  min-width: 90px;
Â  Â  user-select: none;
Â  }

Â  #buttonContainer {
Â  Â  position: fixed;
Â  Â  bottom: 12px;
Â  Â  left: 50%;
Â  Â  transform: translateX(-50%);
Â  Â  display: flex;
Â  Â  gap: 12px;
Â  Â  z-index: 1000;
Â  Â  user-select: none;
Â  }
Â  .floatingBtn {
Â  Â  background: rgba(100, 100, 100, 0.5);
Â  Â  color: #eee;
Â  Â  font-family: monospace, monospace;
Â  Â  font-size: 16px;
Â  Â  padding: 6px 12px;
Â  Â  border: 1px solid #555;
Â  Â  border-radius: 4px;
Â  Â  cursor: pointer;
Â  Â  min-width: 100px;
Â  Â  text-align: center;
Â  Â  box-shadow: 0 0 6px rgba(0,0,0,0.3);
Â  Â  touch-action: manipulation;
Â  Â  transition: background 0.2s ease;
Â  }
Â  .floatingBtn:active {
Â  Â  background: rgba(80, 80, 80, 0.7);
Â  }
Â  .floatingBtn:disabled {
Â  Â  background: rgba(150, 150, 150, 0.3);
Â  Â  cursor: default;
Â  Â  color: #999;
Â  Â  border-color: #999;
Â  Â  box-shadow: none;
Â  }
Â  #zoomDisplay {
Â  Â  position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
Â  Â  background: rgba(0,0,0,0.5); color: white; font-family: monospace;
Â  Â  padding: 4px 8px; border-radius: 4px;
Â  Â  user-select: none; pointer-events: none; z-index: 1001;
Â  }
Â  #connectionLayer {
Â  Â  position: absolute;
Â  Â  top: 0; left: 0;
Â  Â  width: 10000px; height: 10000px;
Â  Â  pointer-events: none;
Â  Â  z-index: 1;
Â  Â  transform-origin: 0 0;
Â  }
Â  #footerInfo {
Â  Â  position: fixed;
Â  Â  bottom: 60px;
Â  Â  left: 50%;
Â  Â  transform: translateX(-50%);
Â  Â  font-family: monospace, monospace;
Â  Â  font-size: 14px;
Â  Â  color: #555;
Â  Â  user-select: none;
Â  Â  z-index: 1002;
Â  Â  background: rgba(255,255,255,0.9);
Â  Â  padding: 4px 8px;
Â  Â  border-radius: 4px;
Â  Â  box-shadow: 0 0 5px rgba(0,0,0,0.1);
Â  Â  pointer-events: none;
Â  Â  width: max-content;
Â  Â  max-width: 90vw;
Â  Â  text-align: center;
Â  }
</style>
</head>
<body>
<div id="topMenu">
Â  <select id="mapSelect" title="Select a mind map"></select>
Â  <button id="saveMapBtn" title="Save current mind map">Save</button>
Â  <button id="renameMapBtn" title="Rename current mind map">Rename</button>
Â  <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
Â  <button id="newMapBtn" title="Create new mind map">New Map</button>
Â  <div id="saveStatus"></div>
</div>

<div id="viewport" tabindex="0">
Â  <svg id="connectionLayer" width="10000" height="10000"></svg>
Â  <div id="canvas"></div>
</div>

<div id="buttonContainer">
Â  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
Â  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
Â  <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
Â  <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
</div>

<script type="module">
Â  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
Â  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

Â  const firebaseConfig = {
Â  Â  apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
Â  Â  authDomain: "stringsnthings-65aa0.firebaseapp.com",
Â  Â  projectId: "stringsnthings-65aa0",
Â  Â  storageBucket: "stringsnthings-65aa0.appspot.com",
Â  Â  messagingSenderId: "35780192306",
Â  Â  appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
Â  };
Â  const app = initializeApp(firebaseConfig);
Â  const db = getFirestore(app);

Â  const canvas = document.getElementById('canvas');
Â  const viewport = document.getElementById('viewport');
Â  const undoBtn = document.getElementById('undoBtn');
Â  const goCenterBtn = document.getElementById('goCenterBtn');
Â  const markCenterBtn = document.getElementById('markCenterBtn');
Â  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
Â  const mapSelect = document.getElementById('mapSelect');
Â  const saveMapBtn = document.getElementById('saveMapBtn');
Â  const renameMapBtn = document.getElementById('renameMapBtn');
Â  const deleteMapBtn = document.getElementById('deleteMapBtn');
Â  const newMapBtn = document.getElementById('newMapBtn');
Â  const saveStatus = document.getElementById('saveStatus');
Â  const connectionLayer = document.getElementById('connectionLayer');

Â  let scale = 1, panX = 0, panY = 0;
Â  let isPanning = false, startX, startY;

Â  const undoStack = [];
Â  const connections = [];
Â  const boxesMap = new Map();

Â  let editMode = true;
Â  let connectionStartBoxId = null;
Â  const selectedBoxes = new Set();

Â  let currentMapId = null;
Â  let mapsCache = new Map();

Â  let markedCenter = null; // {x, y} in canvas coords
Â  
Â  // ðŸ’¡ NEW: Variables for double-tap logic to simulate dblclick on touch devices
Â  let lastTap = 0; 
Â  const tapDelay = 300; 
Â  let dragMoved = false; // ðŸ’¡ NEW: Track if movement happened during a touch sequence

Â  // Helper to get pointer coords
Â  function getClientCoords(e) {
Â  Â  // ðŸ’¡ ORIGINAL: Only checking e.touches[0].clientX
Â  Â  // ðŸ’¡ FIXED: Safely check for touches array existence and use it
Â  Â  if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
Â  Â  // Add fallback for touchend on iPads which use changedTouches
Â  Â  if (e.changedTouches && e.changedTouches.length > 0) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
Â  Â  return { x: e.clientX, y: e.clientY };
Â  }

Â  // Generate unique ID for boxes and maps
Â  function generateId() {
Â  Â  return 'id-' + Math.random().toString(36).slice(2, 11);
Â  }

Â  // Update pan and zoom transform on canvas and connections layer
Â  function updateTransform() {
Â  Â  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
Â  Â  connectionLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
Â  Â  drawConnections();
Â  }

Â  // Pan handling on empty canvas
Â  viewport.addEventListener('pointerdown', e => {
Â  Â  // ðŸ’¡ ORIGINAL: Logic for checking if a box or menu element was clicked
Â  Â  if (e.target.closest('.box-header') || e.target.closest('.drag-handle') || e.target.closest('.resize-handle') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn].includes(e.target) ||
Â  Â  Â  Â  [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) {
Â  Â  Â  Â  Â  dragMoved = false; // Reset dragMoved if clicking on an interactive element
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  isPanning = true;
Â  Â  // ðŸ’¡ NEW: Reset dragMoved when a new pointer interaction (pan) starts
Â  Â  dragMoved = false; 

Â  Â  const coords = getClientCoords(e);
Â  Â  startX = coords.x;
Â  Â  startY = coords.y;
Â  Â  viewport.setPointerCapture(e.pointerId);
Â  Â  // Clear selection on empty space click
Â  Â  selectedBoxes.forEach(b => b.classList.remove('selected'));
Â  Â  selectedBoxes.clear();
Â  });

Â  viewport.addEventListener('pointermove', e => {
Â  Â  if (!isPanning) return;
Â  Â  
Â  Â  // ðŸ’¡ NEW: Set dragMoved flag if movement is detected
Â  Â  dragMoved = true; 

Â  Â  const coords = getClientCoords(e);
Â  Â  panX += coords.x - startX;
Â  Â  panY += coords.y - startY;
Â  Â  startX = coords.x;
Â  Â  startY = coords.y;
Â  Â  updateTransform();
Â  });

Â  viewport.addEventListener('pointerup', e => {
Â  Â  // ðŸ’¡ ORIGINAL: The pan check was correct
Â  Â  if (isPanning) {
Â  Â  Â  isPanning = false;
Â  Â  Â  viewport.releasePointerCapture(e.pointerId);
Â  Â  }
Â  Â  // ðŸ’¡ NEW: If a tap (pointerdown/up without move) occurred on the viewport background, 
Â  Â  // we need to ensure the double-tap logic is still active.
Â  Â  // We reset dragMoved on pointerdown on the viewport, so we check it here for single/double tap detection.
Â  Â  dragMoved = false;
Â  });

Â  // Zoom with mouse wheel
Â  const MIN_SCALE = 0.5;
Â  const MAX_SCALE = 3;

Â  viewport.addEventListener('wheel', e => {
Â  Â  e.preventDefault();
Â  Â  const zoomFactor = 1.1;
Â  Â  const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
Â  Â  let newScale = scale * dir;
Â  Â  newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

Â  Â  const rect = viewport.getBoundingClientRect();
Â  Â  const mx = e.clientX - rect.left;
Â  Â  const my = e.clientY - rect.top;

Â  Â  panX = mx - (mx - panX) * (newScale / scale);
Â  Â  panY = my - (my - panY) * (newScale / scale);

Â  Â  scale = newScale;
Â  Â  updateTransform();
Â  }, { passive: false });

Â  // Create new box element
Â  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
Â  Â  if (boxesMap.has(id)) return;

Â  Â  // ðŸ’¡ NEW: Center the box around the click point, as the original dblclick handler intended
Â  Â  const boxX = x - w / 2;
Â  Â  const boxY = y - h / 2;

Â  Â  const box = document.createElement('div');
Â  Â  box.classList.add('box');
Â  Â  box.style.left = `${boxX}px`; // ðŸ’¡ FIXED variable use
Â  Â  box.style.top = `${boxY}px`; Â // ðŸ’¡ FIXED variable use
Â  Â  box.style.width = w + 'px';
Â  Â  box.style.height = h + 'px';
Â  Â  box.dataset.id = id;
Â  Â  box.style.fontSize = fontSize + 'px';

Â  Â  // Header
Â  Â  const header = document.createElement('div');
Â  Â  header.classList.add('box-header');
Â  Â  header.style.display = editMode ? 'flex' : 'none';

Â  Â  // Drag handle "âœ¥"
Â  Â  const dragHandle = document.createElement('div');
Â  Â  dragHandle.classList.add('drag-handle');
Â  Â  dragHandle.textContent = 'âœ¥';
Â  Â  header.appendChild(dragHandle);

Â  Â  // Connect toggle
Â  Â  const connectToggle = document.createElement('button');
Â  Â  connectToggle.classList.add('connect-toggle');
Â  Â  connectToggle.title = 'Toggle connection for this box';
Â  Â  connectToggle.addEventListener('click', e => {
Â  Â  Â  e.stopPropagation();
Â  Â  Â  connectToggle.classList.toggle('active');
Â  Â  Â  if (connectToggle.classList.contains('active')) {
Â  Â  Â  Â  if (connectionStartBoxId && connectionStartBoxId !== id) {
Â  Â  Â  Â  Â  addConnection(connectionStartBoxId, id);
Â  Â  Â  Â  Â  clearConnectionSelection();
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  connectionStartBoxId = id;
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  if (connectionStartBoxId === id) connectionStartBoxId = null;
Â  Â  Â  }
Â  Â  Â  drawConnections();
Â  Â  });
Â  Â  header.appendChild(connectToggle);

Â  Â  // Font size buttons
Â  Â  const fontDecrease = document.createElement('button');
Â  Â  fontDecrease.classList.add('font-size-btn');
Â  Â  fontDecrease.textContent = 'âˆ’';
Â  Â  fontDecrease.title = 'Decrease font size';
Â  Â  fontDecrease.addEventListener('click', e => {
Â  Â  Â  e.stopPropagation();
Â  Â  Â  let currentSize = parseInt(box.style.fontSize) || fontSize;
Â  Â  Â  currentSize = Math.max(8, currentSize - 1);
Â  Â  Â  box.style.fontSize = currentSize + 'px';
Â  Â  });
Â  Â  header.appendChild(fontDecrease);

Â  Â  const fontIncrease = document.createElement('button');
Â  Â  fontIncrease.classList.add('font-size-btn');
Â  Â  fontIncrease.textContent = '+';
Â  Â  fontIncrease.title = 'Increase font size';
Â  Â  fontIncrease.addEventListener('click', e => {
Â  Â  Â  e.stopPropagation();
Â  Â  Â  let currentSize = parseInt(box.style.fontSize) || fontSize;
Â  Â  Â  currentSize = Math.min(40, currentSize + 1);
Â  Â  Â  box.style.fontSize = currentSize + 'px';
Â  Â  });
Â  Â  header.appendChild(fontIncrease);

Â  Â  // Delete button "Ã—"
Â  Â  const deleteBtn = document.createElement('button');
Â  Â  deleteBtn.classList.add('delete-btn');
Â  Â  deleteBtn.textContent = 'Ã—';
Â  Â  deleteBtn.title = 'Delete this box';
Â  Â  deleteBtn.addEventListener('click', e => {
Â  Â  Â  e.stopPropagation();
Â  Â  Â  deleteBox(id);
Â  Â  });
Â  Â  header.appendChild(deleteBtn);

Â  Â  box.appendChild(header);

Â  Â  // Content editable area
Â  Â  const content = document.createElement('div');
Â  Â  content.classList.add('box-content');
Â  Â  content.contentEditable = editMode;
Â  Â  content.spellcheck = false;
Â  Â  content.textContent = text;
Â  Â  content.style.userSelect = editMode ? 'text' : 'none';
Â  Â  box.appendChild(content);

Â  Â  // Resize handles
Â  Â  ['nw', 'ne', 'sw', 'se'].forEach(pos => {
Â  Â  Â  const handle = document.createElement('div');
Â  Â  Â  handle.classList.add('resize-handle', pos);
Â  Â  Â  box.appendChild(handle);
Â  Â  Â  handle.addEventListener('pointerdown', resizePointerDown);
Â  Â  });

Â  Â  // Dragging ONLY on dragHandle
Â  Â  dragHandle.addEventListener('pointerdown', dragPointerDown);

Â  Â  // Selection on header click
Â  Â  header.addEventListener('click', e => {
Â  Â  Â  if (!editMode) return;
Â  Â  Â  e.stopPropagation();
Â  Â  Â  if (e.shiftKey) {
Â  Â  Â  Â  if (selectedBoxes.has(box)) {
Â  Â  Â  Â  Â  selectedBoxes.delete(box);
Â  Â  Â  Â  Â  box.classList.remove('selected');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  selectedBoxes.add(box);
Â  Â  Â  Â  Â  box.classList.add('selected');
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  selectedBoxes.forEach(b => b.classList.remove('selected'));
Â  Â  Â  Â  selectedBoxes.clear();
Â  Â  Â  Â  selectedBoxes.add(box);
Â  Â  Â  Â  box.classList.add('selected');
Â  Â  Â  }
Â  Â  });

Â  Â  canvas.appendChild(box);
Â  Â  boxesMap.set(id, box);
Â  Â  drawConnections();
Â  }

Â  // Delete a box and related connections
Â  function deleteBox(id) {
Â  Â  const box = boxesMap.get(id);
Â  Â  if (!box) return;

Â  Â  // Save undo data
Â  Â  undoStack.push({
Â  Â  Â  type: 'deleteBox',
Â  Â  Â  id,
Â  Â  Â  data: {
Â  Â  Â  Â  x: parseFloat(box.style.left),
Â  Â  Â  Â  y: parseFloat(box.style.top),
Â  Â  Â  Â  w: parseFloat(box.style.width),
Â  Â  Â  Â  h: parseFloat(box.style.height),
Â  Â  Â  Â  text: box.querySelector('.box-content').textContent,
Â  Â  Â  Â  fontSize: parseInt(box.style.fontSize)
Â  Â  Â  },
Â  Â  Â  connections: connections.filter(c => c.from === id || c.to === id)
Â  Â  });
Â  Â  undoBtn.disabled = false;

Â  Â  box.remove();
Â  Â  boxesMap.delete(id);

Â  Â  for (let i = connections.length - 1; i >= 0; i--) {
Â  Â  Â  if (connections[i].from === id || connections[i].to === id) {
Â  Â  Â  Â  connections.splice(i, 1);
Â  Â  Â  }
Â  Â  }
Â  Â  drawConnections();
Â  }

Â  // Undo deletion
Â  undoBtn.addEventListener('click', () => {
Â  Â  if (undoStack.length === 0) return;
Â  Â  const last = undoStack.pop();
Â  Â  if (last.type === 'deleteBox') {
Â  Â  Â  const d = last.data;
Â  Â  Â  createBox(last.id, d.x, d.y, d.w, d.h, d.text, d.fontSize);
Â  Â  Â  last.connections.forEach(c => connections.push(c));
Â  Â  Â  drawConnections();
Â  Â  }
Â  Â  undoBtn.disabled = undoStack.length === 0;
Â  });

Â  // Drag state
Â  let dragState = null;

Â  // Drag only if pointerdown on dragHandle
Â  function dragPointerDown(e) {
Â  Â  if (!editMode) return;
Â  Â  e.stopPropagation();
Â  Â  e.preventDefault();
Â  Â  const box = e.target.closest('.box');
Â  Â  if (!box) return;

Â  Â  dragState = {
Â  Â  Â  boxesToMove: selectedBoxes.has(box) ? Array.from(selectedBoxes) : [box],
Â  Â  Â  startX: e.clientX,
Â  Â  Â  startY: e.clientY,
Â  Â  Â  origPositions: []
Â  Â  };

Â  Â  dragState.boxesToMove.forEach(b => {
Â  Â  Â  dragState.origPositions.push({
Â  Â  Â  Â  box: b,
Â  Â  Â  Â  left: parseFloat(b.style.left),
Â  Â  Â  Â  top: parseFloat(b.style.top)
Â  Â  Â  });
Â  Â  });

Â  Â  // ðŸ’¡ NEW: Capture pointer ID for reliable touch/pointer movement tracking
Â  Â  e.target.setPointerCapture(e.pointerId);

Â  Â  window.addEventListener('pointermove', dragPointerMove);
Â  Â  window.addEventListener('pointerup', dragPointerUp);
Â  }

Â  function dragPointerMove(e) {
Â  Â  if (!dragState) return;
Â  Â  e.preventDefault();

Â  Â  const dx = (e.clientX - dragState.startX) / scale;
Â  Â  const dy = (e.clientY - dragState.startY) / scale;

Â  Â  dragState.origPositions.forEach(({ box, left, top }) => {
Â  Â  Â  box.style.left = (left + dx) + 'px';
Â  Â  Â  box.style.top = (top + dy) + 'px';
Â  Â  });

Â  Â  drawConnections();
Â  }

Â  function dragPointerUp(e) {
Â  Â  if (!dragState) return;
Â  Â  e.preventDefault();

Â  Â  // ðŸ’¡ NEW: Release pointer capture
Â  Â  if (e.target.hasPointerCapture(e.pointerId)) {
Â  Â  Â  e.target.releasePointerCapture(e.pointerId);
Â  Â  }

Â  Â  dragState = null;
Â  Â  window.removeEventListener('pointermove', dragPointerMove);
Â  Â  window.removeEventListener('pointerup', dragPointerUp);
Â  }

Â  // Resize handlers
Â  let resizeState = null;

Â  function resizePointerDown(e) {
Â  Â  if (!editMode) return;
Â  Â  e.stopPropagation();
Â  Â  e.preventDefault();
Â  Â  const handle = e.target;
Â  Â  const box = handle.closest('.box');
Â  Â  if (!box) return;
Â  Â  let dir = null;
Â  Â  if (handle.classList.contains('nw')) dir = 'nw';
Â  Â  else if (handle.classList.contains('ne')) dir = 'ne';
Â  Â  else if (handle.classList.contains('sw')) dir = 'sw';
Â  Â  else if (handle.classList.contains('se')) dir = 'se';
Â  Â  if (!dir) return;

Â  Â  resizeState = {
Â  Â  Â  box,
Â  Â  Â  dir,
Â  Â  Â  startX: e.clientX,
Â  Â  Â  startY: e.clientY,
Â  Â  Â  origLeft: parseFloat(box.style.left),
Â  Â  Â  origTop: parseFloat(box.style.top),
Â  Â  Â  origWidth: parseFloat(box.style.width),
Â  Â  Â  origHeight: parseFloat(box.style.height)
Â  Â  };
Â  Â  
Â  Â  // ðŸ’¡ NEW: Capture pointer ID for reliable touch/pointer movement tracking
Â  Â  e.target.setPointerCapture(e.pointerId);

Â  Â  window.addEventListener('pointermove', resizePointerMove);
Â  Â  window.addEventListener('pointerup', resizePointerUp);
Â  }

Â  function resizePointerMove(e) {
Â  Â  if (!resizeState) return;
Â  Â  e.preventDefault();

Â  Â  let dx = (e.clientX - resizeState.startX) / scale;
Â  Â  let dy = (e.clientY - resizeState.startY) / scale;

Â  Â  let newLeft = resizeState.origLeft;
Â  Â  let newTop = resizeState.origTop;
Â  Â  let newWidth = resizeState.origWidth;
Â  Â  let newHeight = resizeState.origHeight;

Â  Â  switch (resizeState.dir) {
Â  Â  Â  case 'nw':
Â  Â  Â  Â  newLeft += dx;
Â  Â  Â  Â  newTop += dy;
Â  Â  Â  Â  newWidth -= dx;
Â  Â  Â  Â  newHeight -= dy;
Â  Â  Â  Â  break;
Â  Â  Â  case 'ne':
Â  Â  Â  Â  newTop += dy;
Â  Â  Â  Â  newWidth += dx;
Â  Â  Â  Â  newHeight -= dy;
Â  Â  Â  Â  break;
Â  Â  Â  case 'sw':
Â  Â  Â  Â  newLeft += dx;
Â  Â  Â  Â  newWidth -= dx;
Â  Â  Â  Â  newHeight += dy;
Â  Â  Â  Â  break;
Â  Â  Â  case 'se':
Â  Â  Â  Â  newWidth += dx;
Â  Â  Â  Â  newHeight += dy;
Â  Â  Â  Â  break;
Â  Â  }

Â  Â  if (newWidth < 50) newWidth = 50;
Â  Â  if (newHeight < 30) newHeight = 30;
Â  Â  
Â  Â  // ðŸ’¡ ORIGINAL: These bounds checks caused issues if you zoomed out and tried to resize near the edge
Â  Â  // The original intention seems to be preventing negative size, which the lines above handle.
Â  Â  // Keeping the original code's bounds check logic, but noting the common minimum size fix above.
Â  Â  if (newLeft < 0) newLeft = 0;
Â  Â  if (newTop < 0) newTop = 0;

Â  Â  resizeState.box.style.left = newLeft + 'px';
Â  Â  resizeState.box.style.top = newTop + 'px';
Â  Â  resizeState.box.style.width = newWidth + 'px';
Â  Â  resizeState.box.style.height = newHeight + 'px';

Â  Â  drawConnections();
Â  }

Â  function resizePointerUp(e) {
Â  Â  if (!resizeState) return;
Â  Â  e.preventDefault();

Â  Â  // ðŸ’¡ NEW: Release pointer capture
Â  Â  if (e.target.hasPointerCapture(e.pointerId)) {
Â  Â  Â  e.target.releasePointerCapture(e.pointerId);
Â  Â  }

Â  Â  resizeState = null;
Â  Â  window.removeEventListener('pointermove', resizePointerMove);
Â  Â  window.removeEventListener('pointerup', resizePointerUp);
Â  }

Â  // Connections
Â  function addConnection(fromId, toId) {
Â  Â  if (!fromId || !toId || fromId === toId) return;
Â  Â  if (connections.some(c => (c.from === fromId && c.to === toId) || (c.from === toId && c.to === fromId))) return;
Â  Â  connections.push({ from: fromId, to: toId });
Â  }

Â  function clearConnectionSelection() {
Â  Â  connectionStartBoxId = null;
Â  Â  boxesMap.forEach(box => {
Â  Â  Â  const btn = box.querySelector('.connect-toggle');
Â  Â  Â  btn.classList.remove('active');
Â  Â  });
Â  }

Â  function drawConnections() {
Â  Â  while (connectionLayer.firstChild) {
Â  Â  Â  connectionLayer.removeChild(connectionLayer.firstChild);
Â  Â  }
Â  Â  connections.forEach(c => {
Â  Â  Â  const boxFrom = boxesMap.get(c.from);
Â  Â  Â  const boxTo = boxesMap.get(c.to);
Â  Â  Â  if (!boxFrom || !boxTo) return;

Â  Â  Â  // coords in canvas space:
Â  Â  Â  const x1 = parseFloat(boxFrom.style.left) + parseFloat(boxFrom.style.width) / 2;
Â  Â  Â  const y1 = parseFloat(boxFrom.style.top) + parseFloat(boxFrom.style.height) / 2;
Â  Â  Â  const x2 = parseFloat(boxTo.style.left) + parseFloat(boxTo.style.width) / 2;
Â  Â  Â  const y2 = parseFloat(boxTo.style.top) + parseFloat(boxTo.style.height) / 2;

Â  Â  Â  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
Â  Â  Â  path.setAttribute('stroke', 'black');
Â  Â  Â  path.setAttribute('stroke-width', '2');
Â  Â  Â  path.setAttribute('fill', 'none');

Â  Â  Â  const dx = x2 - x1;
Â  Â  Â  const dy = y2 - y1;
Â  Â  Â  const curveFactor = 0.3;

Â  Â  Â  const cx1 = x1 + dx * curveFactor;
Â  Â  Â  const cy1 = y1;
Â  Â  Â  const cx2 = x2 - dx * curveFactor;
Â  Â  Â  const cy2 = y2;

Â  Â  Â  const d = `M${x1},${y1} C${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
Â  Â  Â  path.setAttribute('d', d);

Â  Â  Â  connectionLayer.appendChild(path);
Â  Â  });
Â  }

Â  // DOUBLE CLICK to create box on viewport (NOT canvas)
Â  // ðŸ’¡ ORIGINAL: dblclick listener for desktop
Â  viewport.addEventListener('dblclick', e => {
Â  Â  if (!editMode) return;

Â  Â  // Ignore dblclick on boxes or their children:
Â  Â  if (e.target.closest('.box')) return;

Â  Â  const rect = viewport.getBoundingClientRect();
Â  Â  // Calculate canvas coords where clicked (account for pan & scale):
Â  Â  const clickX = (e.clientX - rect.left - panX) / scale;
Â  Â  const clickY = (e.clientY - rect.top - panY) / scale;

Â  Â  const id = generateId();
Â  Â  createBox(id, clickX, clickY, 150, 100, '', 14);
Â  });
Â  
Â  // ðŸ’¡ NEW: Touch-end listener for double-tap (to simulate double-click on iPad)
Â  viewport.addEventListener('touchend', e => {
Â  Â  // Only process if a touch ended and no dragging/panning occurred on the touch sequence
Â  Â  if (dragMoved || !editMode || e.target.closest('.box') || e.target.closest('#topMenu') || e.target.closest('#buttonContainer')) return;
Â  Â  
Â  Â  const now = Date.now();
Â  Â  if (now - lastTap < tapDelay) {
Â  Â  Â  // This is a double-tap
Â  Â  Â  e.preventDefault();
Â  Â  Â  // Use the single createBox logic, passing coordinates
Â  Â  Â  const coords = getClientCoords(e);
Â  Â  Â  const rect = viewport.getBoundingClientRect();
Â  Â  Â  const clickX = (coords.x - rect.left - panX) / scale;
Â  Â  Â  const clickY = (coords.y - rect.top - panY) / scale;
Â  Â  Â  
Â  Â  Â  const id = generateId();
Â  Â  Â  createBox(id, clickX, clickY, 150, 100, '', 14); 
Â  Â  Â  
Â  Â  Â  lastTap = 0; // Reset tap tracking
Â  Â  } else {
Â  Â  Â  lastTap = now;
Â  Â  }
Â  });


Â  // Center controls
Â  markCenterBtn.addEventListener('click', () => {
Â  Â  markedCenter = { x: -panX / scale, y: -panY / scale };
Â  Â  alert('Center marked at canvas coords: ' + JSON.stringify(markedCenter));
Â  });

Â  goCenterBtn.addEventListener('click', () => {
Â  Â  if (!markedCenter) return;
Â  Â  panX = -markedCenter.x * scale;
Â  Â  panY = -markedCenter.y * scale;
Â  Â  updateTransform();
Â  });

Â  // Toggle edit mode
Â  toggleEditModeBtn.addEventListener('click', () => {
Â  Â  editMode = !editMode;
Â  Â  canvas.querySelectorAll('.box').forEach(box => {
Â  Â  Â  box.querySelector('.box-header').style.display = editMode ? 'flex' : 'none';
Â  Â  Â  box.querySelector('.box-content').contentEditable = editMode;
Â  Â  Â  box.querySelector('.box-content').style.userSelect = editMode ? 'text' : 'none';
Â  Â  });
Â  });

Â  // Load maps from Firebase Firestore
Â  async function loadMaps() {
Â  Â  mapSelect.innerHTML = '';
Â  Â  const colSnap = collection(db, 'maps');
Â  Â  const snap = await getDocs(colSnap);
Â  Â  mapsCache.clear();
Â  Â  snap.forEach(doc => {
Â  Â  Â  mapsCache.set(doc.id, doc.data());
Â  Â  Â  const option = document.createElement('option');
Â  Â  Â  option.value = doc.id;
Â  Â  Â  option.textContent = doc.data().name || doc.id;
Â  Â  Â  mapSelect.appendChild(option);
Â  Â  });
Â  Â  if (mapSelect.options.length > 0) {
Â  Â  Â  currentMapId = mapSelect.options[0].value;
Â  Â  Â  mapSelect.value = currentMapId;
Â  Â  Â  await loadMap(currentMapId);
Â  Â  }
Â  }

Â  // Load one map by id
Â  async function loadMap(id) {
Â  Â  const docSnap = await getDoc(doc(db, 'maps', id));
Â  Â  if (!docSnap.exists()) return;
Â  Â  clearCanvas();
Â  Â  currentMapId = id;
Â  Â  const data = docSnap.data();
Â  Â  data.boxes.forEach(b => {
Â  Â  Â  createBox(b.id, b.x, b.y, b.w, b.h, b.text, b.fontSize);
Â  Â  });
Â  Â  connections.length = 0;
Â  Â  data.connections.forEach(c => connections.push(c));
Â  Â  drawConnections();
Â  Â  saveStatus.textContent = 'Loaded "' + (data.name || id) + '"';
Â  }

Â  // Clear canvas & reset state
Â  function clearCanvas() {
Â  Â  boxesMap.forEach(b => b.remove());
Â  Â  boxesMap.clear();
Â  Â  connections.length = 0;
Â  Â  drawConnections();
Â  Â  selectedBoxes.clear();
Â  }

Â  // Save current map state to Firestore
Â  async function saveMap() {
Â  Â  if (!currentMapId) {
Â  Â  Â  alert('No map selected');
Â  Â  Â  return;
Â  Â  }
Â  Â  const data = {
Â  Â  Â  name: mapSelect.options[mapSelect.selectedIndex].textContent,
Â  Â  Â  boxes: Array.from(boxesMap.entries()).map(([id, box]) => ({
Â  Â  Â  Â  id,
Â  Â  Â  Â  x: parseFloat(box.style.left),
Â  Â  Â  Â  y: parseFloat(box.style.top),
Â  Â  Â  Â  w: parseFloat(box.style.width),
Â  Â  Â  Â  h: parseFloat(box.style.height),
Â  Â  Â  Â  text: box.querySelector('.box-content').textContent,
Â  Â  Â  Â  fontSize: parseInt(box.style.fontSize)
Â  Â  Â  })),
Â  Â  Â  connections: connections.slice()
Â  Â  };
Â  Â  await setDoc(doc(db, 'maps', currentMapId), data);
Â  Â  saveStatus.textContent = 'Saved "' + data.name + '"';
Â  }

Â  // New map creation
Â  newMapBtn.addEventListener('click', async () => {
Â  Â  const newId = generateId();
Â  Â  const newName = prompt('Enter new map name', 'New Map');
Â  Â  if (!newName) return;
Â  Â  currentMapId = newId;
Â  Â  mapsCache.set(newId, { name: newName, boxes: [], connections: [] });
Â  Â  const option = document.createElement('option');
Â  Â  option.value = newId;
Â  Â  option.textContent = newName;
Â  Â  mapSelect.appendChild(option);
Â  Â  mapSelect.value = newId;
Â  Â  clearCanvas();
Â  Â  await saveMap();
Â  });

Â  // Rename map
Â  renameMapBtn.addEventListener('click', async () => {
Â  Â  if (!currentMapId) return;
Â  Â  const newName = prompt('Enter new name for this map', mapSelect.options[mapSelect.selectedIndex].textContent);
Â  Â  if (!newName) return;
Â  Â  mapSelect.options[mapSelect.selectedIndex].textContent = newName;
Â  Â  await saveMap();
Â  });

Â  // Delete map
Â  deleteMapBtn.addEventListener('click', async () => {
Â  Â  if (!currentMapId) return;
Â  Â  if (!confirm('Delete map "' + mapSelect.options[mapSelect.selectedIndex].textContent + '"?')) return;
Â  Â  await deleteDoc(doc(db, 'maps', currentMapId));
Â  Â  mapsCache.delete(currentMapId);
Â  Â  mapSelect.remove(mapSelect.selectedIndex);
Â  Â  if (mapSelect.options.length > 0) {
Â  Â  Â  currentMapId = mapSelect.options[0].value;
Â  Â  Â  await loadMap(currentMapId);
Â  Â  } else {
Â  Â  Â  currentMapId = null;
Â  Â  Â  clearCanvas();
Â  Â  }
Â  });

Â  // Change map selection
Â  mapSelect.addEventListener('change', async () => {
Â  Â  if (mapSelect.value) {
Â  Â  Â  currentMapId = mapSelect.value;
Â  Â  Â  await loadMap(currentMapId);
Â  Â  }
Â  });

Â  saveMapBtn.addEventListener('click', saveMap);

Â  // Initialize
Â  loadMaps();
Â  updateTransform();
</script>
</body>
</html>
