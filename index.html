<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV3withFirebase</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
    <button id="saveBtn" class="floatingBtn">Save to Firebase</button>
    <button id="loadBtn" class="floatingBtn">Load from Firebase</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red × to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      The page loads at the saved center from Firebase.
      **New:** Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use "Save to Firebase" to save your work; "Load from Firebase" to reload.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  // Firebase SDK import from CDN
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getDatabase, ref, set, get, child } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // --- Main app code below ---

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const connectionLayer = document.getElementById('connectionLayer');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    // deselect on background click
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wx = (mouseX - panX) / scale;
    const wy = (mouseY - panY) / scale;
    scale = newScale;
    panX = mouseX - wx * scale;
    panY = mouseY - wy * scale;
    updateTransform();
  });

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  let lastTap = 0;
  viewport.addEventListener('pointerdown', e => {
    if ([undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn, saveBtn, loadBtn].includes(e.target)) return;
    const now = Date.now();
    if (now - lastTap < 400 && !e.target.closest('.box')) {
      const x = (e.clientX - panX) / scale;
      const y = (e.clientY - panY) / scale;
      addBox(x, y);
    }
    lastTap = now;
  });

  markCenterBtn.addEventListener('click', async () => {
    const rect = viewport.getBoundingClientRect();
    const centerX = (rect.width / 2 - panX) / scale;
    const centerY = (rect.height / 2 - panY) / scale;
    try {
      await set(ref(db, 'appState/center'), { x: centerX, y: centerY });
      alert('Center marked and saved to Firebase at: ' + Math.round(centerX) + ', ' + Math.round(centerY));
    } catch (e) {
      alert('Failed to save center to Firebase: ' + e.message);
    }
  });

  goCenterBtn.addEventListener('click', async () => {
    try {
      const snapshot = await get(child(ref(db), 'appState/center'));
      if (snapshot.exists()) {
        const c = snapshot.val();
        const rect = viewport.getBoundingClientRect();
        panX = rect.width / 2 - c.x * scale;
        panY = rect.height / 2 - c.y * scale;
        updateTransform();
      } else {
        alert('No center saved in Firebase yet.');
      }
    } catch (e) {
      alert('Failed to load center from Firebase: ' + e.message);
    }
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    document.querySelectorAll('.box-header').forEach(header => {
      header.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.connect-toggle').forEach(toggle => {
      toggle.style.display = editMode ? 'inline-block' : 'none';
    });
    document.querySelectorAll('.font-size-btn').forEach(btn => {
      btn.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.drag-handle').forEach(handle => {
      handle.style.display = editMode ? 'flex' : 'none';
    });
    document.querySelectorAll('.box-content').forEach(content => {
      content.contentEditable = editMode;
      content.style.cursor = editMode ? 'text' : 'default';
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(({ fromId, toId }) => {
      const boxA = boxesMap.get(fromId);
      const boxB = boxesMap.get(toId);
      if (!boxA || !boxB) return;
      const ax = parseFloat(boxA.style.left) + boxA.offsetWidth / 2;
      const ay = parseFloat(boxA.style.top) + boxA.offsetHeight / 2;
      const bx = parseFloat(boxB.style.left) + boxB.offsetWidth / 2;
      const by = parseFloat(boxB.style.top) + boxB.offsetHeight / 2;
      const startX = ax * scale + panX;
      const startY = ay * scale + panY;
      const endX = bx * scale + panX;
      const endY = by * scale + panY;
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const dx = endX - startX;
      const dy = endY - startY;
      const distance = Math.sqrt(dx*dx + dy*dy);
      if (distance === 0) return;
      const normX = dx / distance;
      const normY = dy / distance;
      const cpOffset = 40;
      const cp1X = startX + normX * cpOffset;
      const cp1Y = startY + normY * cpOffset;
      const cp2X = endX - normX * cpOffset;
      const cp2Y = endY - normY * cpOffset;
      path.setAttribute('d', `M${startX},${startY} C${cp1X},${cp1Y} ${cp2X},${cp2Y} ${endX},${endY}`);
      path.setAttribute('stroke', 'black');
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-width', '2');
      connectionLayer.appendChild(path);
    });
  }

  function addBox(x, y, id = null, content = '', fontSize = 14, width = 120, height = 60) {
    if (!id) id = 'box_' + Date.now() + '_' + Math.floor(Math.random() * 10000);
    if (boxesMap.has(id)) return;
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    // Drag handle (✥)
    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    // Font size buttons: - and +
    const fontMinus = document.createElement('button');
    fontMinus.className = 'font-size-btn';
    fontMinus.textContent = '−';
    header.appendChild(fontMinus);
    const fontPlus = document.createElement('button');
    fontPlus.className = 'font-size-btn';
    fontPlus.textContent = '+';
    header.appendChild(fontPlus);

    // Connection toggle button (blue circle)
    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Connect this box';
    header.appendChild(connectToggle);

    // Delete button (red ×)
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    // Content editable div centered text
    const contentDiv = document.createElement('div');
    contentDiv.className = 'box-content';
    contentDiv.contentEditable = editMode;
    contentDiv.style.fontSize = fontSize + 'px';
    contentDiv.textContent = content;
    box.appendChild(contentDiv);

    // Resize handles (only bottom-right corner for simplicity)
    const resizeHandle = document.createElement('div');
    resizeHandle.className = 'resize-handle se';
    box.appendChild(resizeHandle);

    canvas.appendChild(box);
    boxesMap.set(id, box);

    // Font size events
    fontMinus.addEventListener('click', () => {
      let currentSize = parseInt(contentDiv.style.fontSize) || 14;
      currentSize = Math.max(8, currentSize - 1);
      contentDiv.style.fontSize = currentSize + 'px';
      saveNeeded = true;
    });
    fontPlus.addEventListener('click', () => {
      let currentSize = parseInt(contentDiv.style.fontSize) || 14;
      currentSize = Math.min(48, currentSize + 1);
      contentDiv.style.fontSize = currentSize + 'px';
      saveNeeded = true;
    });

    // Delete event
    deleteBtn.addEventListener('click', () => {
      deleteBox(id);
    });

    // Connect toggle event
    connectToggle.addEventListener('click', () => {
      if (!editMode) return;
      if (connectionStartBoxId === null) {
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else {
        // Add connection
        connections.push({ fromId: connectionStartBoxId, toId: id });
        clearConnectToggles();
        connectionStartBoxId = null;
        drawConnections();
        saveNeeded = true;
      }
    });

    // Dragging the box
    let isDragging = false;
    let dragOffsetX, dragOffsetY;

    function dragStart(e) {
      if (!editMode) return;
      e.preventDefault();
      isDragging = true;
      const rect = box.getBoundingClientRect();
      const coords = getClientCoords(e);
      dragOffsetX = coords.x - rect.left;
      dragOffsetY = coords.y - rect.top;
      if (e.shiftKey) {
        // Multi-select drag
        if (!selectedBoxes.has(box)) {
          selectedBoxes.forEach(b => b.classList.remove('selected'));
          selectedBoxes.clear();
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
        dragGroupStart(coords.x, coords.y);
      } else {
        // Normal drag
        if (!selectedBoxes.has(box)) {
          selectedBoxes.forEach(b => b.classList.remove('selected'));
          selectedBoxes.clear();
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      }
      window.addEventListener('pointermove', dragging);
      window.addEventListener('pointerup', dragEnd);
    }

    function dragging(e) {
      if (!isDragging) return;
      e.preventDefault();
      const coords = getClientCoords(e);
      if (draggingGroup) {
        dragGroupMove(coords.x, coords.y);
      } else {
        const newX = (coords.x - dragOffsetX - panX) / scale;
        const newY = (coords.y - dragOffsetY - panY) / scale;
        box.style.left = newX + 'px';
        box.style.top = newY + 'px';
        drawConnections();
        saveNeeded = true;
      }
    }

    function dragEnd(e) {
      isDragging = false;
      window.removeEventListener('pointermove', dragging);
      window.removeEventListener('pointerup', dragEnd);
      draggingGroup = false;
    }

    dragHandle.addEventListener('pointerdown', dragStart);

    // Multi-select via Shift+click on header (including drag handle)
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (e.shiftKey) {
        e.preventDefault();
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
      }
    });

    // Resize handling
    let isResizing = false;
    let resizeStartX, resizeStartY, startWidth, startHeight;
    resizeHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.preventDefault();
      isResizing = true;
      const rect = box.getBoundingClientRect();
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      startWidth = rect.width;
      startHeight = rect.height;
      window.addEventListener('pointermove', resizing);
      window.addEventListener('pointerup', resizeEnd);
    });

    function resizing(e) {
      if (!isResizing) return;
      e.preventDefault();
      const dx = e.clientX - resizeStartX;
      const dy = e.clientY - resizeStartY;
      const newWidth = Math.max(50, startWidth + dx / scale);
      const newHeight = Math.max(30, startHeight + dy / scale);
      box.style.width = newWidth + 'px';
      box.style.height = newHeight + 'px';
      drawConnections();
      saveNeeded = true;
    }

    function resizeEnd(e) {
      isResizing = false;
      window.removeEventListener('pointermove', resizing);
      window.removeEventListener('pointerup', resizeEnd);
    }

    // Content editable change triggers saveNeeded
    contentDiv.addEventListener('input', () => {
      saveNeeded = true;
    });

    return box;
  }

  function deleteBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    undoStack.push({
      id: id,
      left: parseFloat(box.style.left),
      top: parseFloat(box.style.top),
      width: parseFloat(box.style.width),
      height: parseFloat(box.style.height),
      content: box.querySelector('.box-content').textContent,
      fontSize: parseInt(box.querySelector('.box-content').style.fontSize) || 14,
      connectionsFrom: connections.filter(c => c.fromId === id),
      connectionsTo: connections.filter(c => c.toId === id)
    });
    undoBtn.disabled = false;

    // Remove connections involving this box
    for (let i = connections.length -1; i >= 0; i--) {
      if (connections[i].fromId === id || connections[i].toId === id) {
        connections.splice(i, 1);
      }
    }

    box.remove();
    boxesMap.delete(id);
    drawConnections();
    saveNeeded = true;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    const restoredBox = addBox(last.left, last.top, last.id, last.content, last.fontSize, last.width, last.height);
    last.connectionsFrom.forEach(c => connections.push(c));
    last.connectionsTo.forEach(c => connections.push(c));
    drawConnections();
    if (undoStack.length === 0) undoBtn.disabled = true;
    saveNeeded = true;
  });

  // Clear connect toggles
  function clearConnectToggles() {
    document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
  }

  // Multi-drag support
  let draggingGroup = false;
  let dragGroupOrigin = null;
  let dragGroupOffsets = new Map();

  function dragGroupStart(clientX, clientY) {
    draggingGroup = true;
    dragGroupOrigin = { x: clientX, y: clientY };
    dragGroupOffsets.clear();
    selectedBoxes.forEach(box => {
      const left = parseFloat(box.style.left);
      const top = parseFloat(box.style.top);
      dragGroupOffsets.set(box, { left, top });
    });
  }

  function dragGroupMove(clientX, clientY) {
    if (!draggingGroup) return;
    const dx = (clientX - dragGroupOrigin.x) / scale;
    const dy = (clientY - dragGroupOrigin.y) / scale;
    selectedBoxes.forEach(box => {
      const orig = dragGroupOffsets.get(box);
      box.style.left = (orig.left + dx) + 'px';
      box.style.top = (orig.top + dy) + 'px';
    });
    drawConnections();
    saveNeeded = true;
  }

  // Save/load data to/from Firebase
  let saveNeeded = false;

  async function saveToFirebase() {
    const allBoxes = [];
    boxesMap.forEach(box => {
      allBoxes.push({
        id: box.dataset.id,
        left: parseFloat(box.style.left),
        top: parseFloat(box.style.top),
        width: parseFloat(box.style.width),
        height: parseFloat(box.style.height),
        content: box.querySelector('.box-content').textContent,
        fontSize: parseInt(box.querySelector('.box-content').style.fontSize) || 14
      });
    });

    try {
      await set(ref(db, 'appState'), {
        boxes: allBoxes,
        connections,
        center: await getCenterFromFirebase() || {x:0,y:0}
      });
      alert('Saved to Firebase!');
      saveNeeded = false;
    } catch (e) {
      alert('Save failed: ' + e.message);
    }
  }

  async function getCenterFromFirebase() {
    try {
      const snapshot = await get(child(ref(db), 'appState/center'));
      if (snapshot.exists()) {
        return snapshot.val();
      }
    } catch (e) {
      // ignore
    }
    return null;
  }

  async function loadFromFirebase() {
    try {
      const snapshot = await get(ref(db, 'appState'));
      if (!snapshot.exists()) {
        alert('No saved data found in Firebase.');
        return;
      }
      const data = snapshot.val();
      // Clear current
      boxesMap.forEach(box => box.remove());
      boxesMap.clear();
      connections.length = 0;
      undoStack.length = 0;
      undoBtn.disabled = true;
      selectedBoxes.clear();
      clearConnectToggles();

      // Load boxes
      if (data.boxes && Array.isArray(data.boxes)) {
        data.boxes.forEach(b => {
          addBox(b.left, b.top, b.id, b.content, b.fontSize, b.width, b.height);
        });
      }
      // Load connections
      if (data.connections && Array.isArray(data.connections)) {
        connections.push(...data.connections);
      }
      drawConnections();

      // Load center and set viewport
      if (data.center) {
        const rect = viewport.getBoundingClientRect();
        panX = rect.width / 2 - data.center.x * scale;
        panY = rect.height / 2 - data.center.y * scale;
        updateTransform();
      }

      alert('Loaded from Firebase!');
      saveNeeded = false;
    } catch (e) {
      alert('Load failed: ' + e.message);
    }
  }

  saveBtn.addEventListener('click', () => {
    saveToFirebase();
  });

  loadBtn.addEventListener('click', () => {
    loadFromFirebase();
  });

  // Initial setup
  toggleEditModeBtn.click();

  // Draw connections on window resize
  window.addEventListener('resize', () => {
    drawConnections();
  });

  // Periodic autosave every 20 seconds if changes pending
  setInterval(() => {
    if (saveNeeded) {
      saveToFirebase();
    }
  }, 20000);

</script>
</body>
</html>
