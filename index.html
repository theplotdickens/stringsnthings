<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    dragHandle.title = 'Drag box';
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectBtn = document.createElement('button');
    connectBtn.className = 'connect-toggle';
    connectBtn.title = 'Connect box';
    header.appendChild(connectBtn);

    // Font size controls
    const fontDecBtn = document.createElement('button');
    fontDecBtn.textContent = '−';
    fontDecBtn.className = 'font-size-btn';
    fontDecBtn.title = 'Decrease font size';

    const fontIncBtn = document.createElement('button');
    fontIncBtn.textContent = '+';
    fontIncBtn.className = 'font-size-btn';
    fontIncBtn.title = 'Increase font size';

    header.appendChild(fontDecBtn);
    header.appendChild(fontIncBtn);

    // Delete button
    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.textContent = '×';
    delBtn.title = 'Delete box';
    header.appendChild(delBtn);

    box.appendChild(header);

    // Content editable area
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const rh = document.createElement('div');
      rh.className = 'resize-handle ' + pos;
      box.appendChild(rh);
    });

    canvas.appendChild(box);

    boxesMap.set(id, { element: box, fontSize });

    // Event listeners

    // Dragging boxes
    let isDragging = false;
    let dragStartX, dragStartY, boxStartX, boxStartY;
    function onPointerDownDrag(e) {
      if (!editMode) return;
      if (!e.target.classList.contains('drag-handle') && !selectedBoxes.has(box)) return;

      if (e.shiftKey && !selectedBoxes.has(box)) {
        selectedBoxes.add(box);
        box.classList.add('selected');
      } else if (!e.shiftKey) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }

      isDragging = true;
      const coords = getClientCoords(e);
      dragStartX = coords.x;
      dragStartY = coords.y;
      boxStartX = parseFloat(box.style.left);
      boxStartY = parseFloat(box.style.top);

      // For multi-select drag, save start positions of all selected boxes
      selectedBoxes.forEach(b => {
        b.dataset.dragStartX = b.style.left;
        b.dataset.dragStartY = b.style.top;
      });

      e.preventDefault();
      e.stopPropagation();
      box.setPointerCapture(e.pointerId);
    }
    function onPointerMoveDrag(e) {
      if (!isDragging) return;
      const coords = getClientCoords(e);
      const dx = coords.x - dragStartX;
      const dy = coords.y - dragStartY;

      // Move all selected boxes
      selectedBoxes.forEach(b => {
        const startX = parseFloat(b.dataset.dragStartX);
        const startY = parseFloat(b.dataset.dragStartY);
        b.style.left = (startX + dx) + 'px';
        b.style.top = (startY + dy) + 'px';
      });
      drawConnections();
    }
    function onPointerUpDrag(e) {
      if (!isDragging) return;
      isDragging = false;
      box.releasePointerCapture(e.pointerId);
      saveCurrentMapToUndo();
    }

    dragHandle.addEventListener('pointerdown', onPointerDownDrag);
    viewport.addEventListener('pointermove', onPointerMoveDrag);
    viewport.addEventListener('pointerup', onPointerUpDrag);

    // Resize handling
    let resizing = false;
    let resizeDir = '';
    let resizeStartX, resizeStartY, boxStartWidth, boxStartHeight;
    function onPointerDownResize(e) {
      if (!editMode) return;
      if (!e.target.classList.contains('resize-handle')) return;
      resizing = true;
      resizeDir = e.target.classList[1];
      const coords = getClientCoords(e);
      resizeStartX = coords.x;
      resizeStartY = coords.y;
      boxStartWidth = box.offsetWidth;
      boxStartHeight = box.offsetHeight;
      e.preventDefault();
      e.stopPropagation();
      box.setPointerCapture(e.pointerId);
    }
    function onPointerMoveResize(e) {
      if (!resizing) return;
      const coords = getClientCoords(e);
      let dx = coords.x - resizeStartX;
      let dy = coords.y - resizeStartY;
      let newWidth = boxStartWidth;
      let newHeight = boxStartHeight;
      let newLeft = parseFloat(box.style.left);
      let newTop = parseFloat(box.style.top);

      if (resizeDir.includes('e')) newWidth = Math.max(40, boxStartWidth + dx);
      if (resizeDir.includes('s')) newHeight = Math.max(30, boxStartHeight + dy);
      if (resizeDir.includes('w')) {
        newWidth = Math.max(40, boxStartWidth - dx);
        newLeft = parseFloat(box.style.left) + dx;
      }
      if (resizeDir.includes('n')) {
        newHeight = Math.max(30, boxStartHeight - dy);
        newTop = parseFloat(box.style.top) + dy;
      }

      box.style.width = newWidth + 'px';
      box.style.height = newHeight + 'px';
      box.style.left = newLeft + 'px';
      box.style.top = newTop + 'px';

      drawConnections();
    }
    function onPointerUpResize(e) {
      if (!resizing) return;
      resizing = false;
      box.releasePointerCapture(e.pointerId);
      saveCurrentMapToUndo();
    }

    box.addEventListener('pointerdown', onPointerDownResize);
    viewport.addEventListener('pointermove', onPointerMoveResize);
    viewport.addEventListener('pointerup', onPointerUpResize);

    // Content editable text updates
    content.addEventListener('input', e => {
      // Center text horizontally and vertically in the box
      content.style.justifyContent = 'center';
      content.style.alignItems = 'center';

      saveCurrentMapToUndo();
    });

    // Font size buttons
    fontIncBtn.addEventListener('click', e => {
      e.stopPropagation();
      const currentSize = boxesMap.get(id).fontSize;
      const newSize = Math.min(36, currentSize + 1);
      boxesMap.get(id).fontSize = newSize;
      content.style.fontSize = newSize + 'px';
      saveCurrentMapToUndo();
    });
    fontDecBtn.addEventListener('click', e => {
      e.stopPropagation();
      const currentSize = boxesMap.get(id).fontSize;
      const newSize = Math.max(8, currentSize - 1);
      boxesMap.get(id).fontSize = newSize;
      content.style.fontSize = newSize + 'px';
      saveCurrentMapToUndo();
    });

    // Delete button
    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(id);
      saveCurrentMapToUndo();
    });

    // Connect toggle button
    connectBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (!connectBtn.classList.contains('active')) {
        // Start connection
        connectionStartBoxId = id;
        clearAllConnectToggles();
        connectBtn.classList.add('active');
      } else {
        // Cancel connection
        connectionStartBoxId = null;
        connectBtn.classList.remove('active');
      }
    });

    // Box click for connection creation
    box.addEventListener('click', e => {
      if (!editMode) return;
      if (connectionStartBoxId && connectionStartBoxId !== id) {
        // Create connection
        connections.push({ from: connectionStartBoxId, to: id });
        connectionStartBoxId = null;
        clearAllConnectToggles();
        drawConnections();
        saveCurrentMapToUndo();
      }
    });

    // Shift+click header to multi-select
    header.addEventListener('click', e => {
      if (e.shiftKey) {
        if (selectedBoxes.has(box)) {
          selectedBoxes.delete(box);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box);
          box.classList.add('selected');
        }
        e.stopPropagation();
      }
    });

    boxesMap.set(id, { element: box, fontSize });

    return box;
  }

  function clearAllConnectToggles() {
    document.querySelectorAll('.connect-toggle.active').forEach(btn => btn.classList.remove('active'));
  }

  function deleteBox(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    // Remove connections involving this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }
    boxData.element.remove();
    boxesMap.delete(id);
    selectedBoxes.delete(boxData.element);
    drawConnections();
  }

  // Connections rendering

  function drawConnections() {
    const svgNS = "http://www.w3.org/2000/svg";
    connectionLayer.innerHTML = '';
    connectionLayer.setAttribute('width', viewport.clientWidth);
    connectionLayer.setAttribute('height', viewport.clientHeight);

    connections.forEach(conn => {
      const fromBox = boxesMap.get(conn.from);
      const toBox = boxesMap.get(conn.to);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.element.getBoundingClientRect();
      const toRect = toBox.element.getBoundingClientRect();

      // Get viewport offset
      const vpRect = viewport.getBoundingClientRect();

      // Calculate center points relative to viewport
      const startX = fromRect.left + fromRect.width / 2 - vpRect.left;
      const startY = fromRect.top + fromRect.height / 2 - vpRect.top;
      const endX = toRect.left + toRect.width / 2 - vpRect.left;
      const endY = toRect.top + toRect.height / 2 - vpRect.top;

      // Create path with smooth curve
      const path = document.createElementNS(svgNS, 'path');
      const deltaX = endX - startX;
      const deltaY = endY - startY;
      const controlX1 = startX + deltaX * 0.25;
      const controlY1 = startY;
      const controlX2 = startX + deltaX * 0.75;
      const controlY2 = endY;
      const d = `M${startX},${startY} C${controlX1},${controlY1} ${controlX2},${controlY2} ${endX},${endY}`;
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      connectionLayer.appendChild(path);
    });
  }

  // Undo stack management
  function saveCurrentMapToUndo() {
    if (!currentMapId) return;
    const mapData = serializeCurrentMap();
    undoStack.push(JSON.stringify(mapData));
    undoBtn.disabled = false;
  }

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    undoStack.pop(); // discard current state
    const lastState = undoStack.pop();
    if (!lastState) return;
    loadMapFromData(JSON.parse(lastState));
    undoBtn.disabled = undoStack.length === 0;
  });

  // Serialize current map
  function serializeCurrentMap() {
    const boxes = [];
    boxesMap.forEach(({element, fontSize}, id) => {
      boxes.push({
        id,
        x: parseFloat(element.style.left),
        y: parseFloat(element.style.top),
        w: element.offsetWidth,
        h: element.offsetHeight,
        text: element.querySelector('.box-content').textContent,
        fontSize
      });
    });
    return {
      boxes,
      connections: [...connections],
      center: { panX, panY, scale }
    };
  }

  // Load map from data
  function loadMapFromData(data) {
    // Clear old
    boxesMap.forEach(({element}) => element.remove());
    boxesMap.clear();
    connections.length = 0;
    selectedBoxes.clear();

    // Load boxes
    data.boxes.forEach(b => {
      createBox(b.id, b.x, b.y, b.w, b.h, b.text, b.fontSize || 14);
    });
    // Load connections
    connections.push(...(data.connections || []));
    // Load center
    if (data.center) {
      panX = data.center.panX || 0;
      panY = data.center.panY || 0;
      scale = data.center.scale || 1;
    } else {
      panX = 0; panY = 0; scale = 1;
    }
    updateTransform();
    drawConnections();
  }

  // Firebase load/save

  async function loadMapsList() {
    mapSelect.innerHTML = '';
    mapsCache.clear();
    try {
      const querySnapshot = await getDocs(collection(db, "mindmaps"));
      querySnapshot.forEach(docSnap => {
        const data = docSnap.data();
        mapsCache.set(docSnap.id, data);
        const option = document.createElement('option');
        option.value = docSnap.id;
        option.textContent = data.name || docSnap.id;
        mapSelect.appendChild(option);
      });
      if (mapsCache.size > 0) {
        currentMapId = mapSelect.options[0].value;
        mapSelect.value = currentMapId;
        await loadMapById(currentMapId);
      } else {
        createNewMap(); // no maps exist yet
      }
    } catch (e) {
      console.error("Failed to load mindmaps list:", e);
      alert("Error loading mindmaps list.");
    }
  }

  async function loadMapById(mapId) {
    if (!mapId) return;
    try {
      const docSnap = await getDoc(doc(db, "mindmaps", mapId));
      if (!docSnap.exists()) {
        alert("Map does not exist!");
        return;
      }
      currentMapId = mapId;
      mapSelect.value = mapId;
      const data = docSnap.data();
      loadMapFromData(data);
      saveStatus.textContent = "";
    } catch (e) {
      console.error("Failed to load mindmap:", e);
      alert("Error loading mindmap.");
    }
  }

  async function saveCurrentMapToFirestore() {
    if (!currentMapId) return;
    try {
      const mapData = serializeCurrentMap();
      await setDoc(doc(db, "mindmaps", currentMapId), mapData);
      saveStatus.textContent = "Saved";
      setTimeout(() => { saveStatus.textContent = ""; }, 1500);
    } catch (e) {
      console.error("Failed to save mindmap:", e);
      alert("Error saving mindmap.");
    }
  }

  async function renameCurrentMap() {
    if (!currentMapId) return;
    const newName = prompt("Enter new map name:");
    if (!newName) return;
    try {
      const data = (await getDoc(doc(db, "mindmaps", currentMapId))).data() || {};
      data.name = newName;
      await setDoc(doc(db, "mindmaps", currentMapId), data);
      await loadMapsList();
      mapSelect.value = currentMapId;
      saveStatus.textContent = "Renamed";
      setTimeout(() => { saveStatus.textContent = ""; }, 1500);
    } catch (e) {
      console.error("Failed to rename mindmap:", e);
      alert("Error renaming mindmap.");
    }
  }

  async function deleteCurrentMap() {
    if (!currentMapId) return;
    if (!confirm("Delete current map? This cannot be undone.")) return;
    try {
      await deleteDoc(doc(db, "mindmaps", currentMapId));
      await loadMapsList();
      saveStatus.textContent = "Deleted";
      setTimeout(() => { saveStatus.textContent = ""; }, 1500);
    } catch (e) {
      console.error("Failed to delete mindmap:", e);
      alert("Error deleting mindmap.");
    }
  }

  async function createNewMap() {
    const newId = generateId();
    currentMapId = newId;
    mapSelect.value = newId;
    const newMapData = {
      name: "New Map",
      boxes: [],
      connections: [],
      center: { panX: 0, panY: 0, scale: 1 }
    };
    try {
      await setDoc(doc(db, "mindmaps", newId), newMapData);
      await loadMapsList();
      mapSelect.value = newId;
      loadMapFromData(newMapData);
      saveStatus.textContent = "New map created";
      setTimeout(() => { saveStatus.textContent = ""; }, 1500);
    } catch (e) {
      console.error("Failed to create new mindmap:", e);
      alert("Error creating new mindmap.");
    }
  }

  // Event listeners for top menu

  mapSelect.addEventListener('change', async e => {
    if (e.target.value !== currentMapId) {
      await loadMapById(e.target.value);
      undoStack.length = 0;
      undoBtn.disabled = true;
    }
  });

  saveMapBtn.addEventListener('click', async () => {
    await saveCurrentMapToFirestore();
  });

  renameMapBtn.addEventListener('click', async () => {
    await renameCurrentMap();
  });

  deleteMapBtn.addEventListener('click', async () => {
    await deleteCurrentMap();
  });

  newMapBtn.addEventListener('click', async () => {
    await createNewMap();
    undoStack.length = 0;
    undoBtn.disabled = true;
  });

  // Keyboard shortcuts

  window.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      clearAllConnectToggles();
      connectionStartBoxId = null;
    }
  });

  // Undo stack disabled at start
  undoBtn.disabled = true;

  // Bottom button handlers

  goCenterBtn.addEventListener('click', () => {
    panX = 0;
    panY = 0;
    scale = 1;
    updateTransform();
  });

  let markedCenter = null;

  markCenterBtn.addEventListener('click', () => {
    markedCenter = { panX, panY, scale };
    saveStatus.textContent = "Center marked";
    setTimeout(() => { saveStatus.textContent = ""; }, 1000);
  });

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? "Toggle Edit Mode" : "View Only Mode";

    boxesMap.forEach(({element}) => {
      element.querySelector('.box-content').contentEditable = editMode;
      element.querySelector('.delete-btn').style.display = editMode ? '' : 'none';
      element.querySelector('.connect-toggle').style.display = editMode ? '' : 'none';
      element.querySelectorAll('.resize-handle').forEach(rh => rh.style.display = editMode ? '' : 'none');
      element.querySelector('.font-size-btn:nth-child(3)').style.display = editMode ? '' : 'none';
      element.querySelector('.font-size-btn:nth-child(4)').style.display = editMode ? '' : 'none';
      element.querySelector('.drag-handle').style.display = editMode ? '' : 'none';
    });
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });

  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Double click to create box

  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target.closest('.box')) return; // don't create if dblclick on box
    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;
    const id = generateId();
    createBox(id, x, y);
    saveCurrentMapToUndo();
  });

  // Initialization

  loadMapsList();

  // Animate loop for continuous rendering

  function loop() {
    requestAnimationFrame(loop);
  }
  loop();
</script>
</body>
</html>
