<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV4LandingMap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
      padding-top: 48px; /* space for top bar */
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topBar {
      position: fixed;
      top: 0; left: 50%;
      transform: translateX(-50%);
      background: #222;
      color: white;
      font-family: monospace, monospace;
      height: 40px;
      line-height: 40px;
      border-bottom: 2px solid #444;
      display: flex;
      gap: 12px;
      padding: 0 16px;
      align-items: center;
      z-index: 2000;
      user-select: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
      border-radius: 0 0 8px 8px;
      min-width: 400px;
      max-width: 90vw;
    }
    #topBar select, #topBar input[type="text"] {
      height: 24px;
      font-size: 14px;
      font-family: monospace, monospace;
      border-radius: 4px;
      border: 1px solid #666;
      padding: 0 6px;
      color: black;
      user-select: text;
    }
    #topBar button {
      height: 28px;
      font-size: 14px;
      font-family: monospace, monospace;
      border-radius: 4px;
      border: none;
      background: #4caf50;
      color: white;
      cursor: pointer;
      user-select: none;
      padding: 0 12px;
      transition: background 0.2s ease;
    }
    #topBar button:disabled {
      background: #999;
      cursor: default;
    }
    #topBar button:hover:not(:disabled) {
      background: #45a049;
    }

    #saveStatus {
      font-size: 14px;
      font-family: monospace, monospace;
      color: #6f6;
      margin-left: 12px;
      min-width: 80px;
      user-select: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    /* Align topBar elements vertically center */
    #topBar > * {
      display: flex;
      align-items: center;
      height: 28px;
    }
  </style>
</head>
<body>
  <div id="topBar" aria-label="Mind map controls">
    <select id="mindMapSelect" aria-label="Select mind map"></select>
    <input id="newMindMapName" type="text" placeholder="New map name" aria-label="New mind map name" />
    <button id="saveMapBtn" aria-label="Save mind map">Save</button>
    <span id="saveStatus" role="alert" aria-live="polite"></span>
  </div>

  <div id="viewport" tabindex="0" aria-label="Mind map viewport">
    <svg id="connectionLayer" aria-hidden="true"></svg>
    <div id="canvas" role="region" aria-label="Mind map canvas"></div>
  </div>

  <div id="buttonContainer" role="region" aria-label="Mind map actions">
    <button id="undoBtn" class="floatingBtn" disabled aria-label="Undo delete">Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn" aria-label="Go to center">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn" aria-label="Mark center">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn" aria-label="Toggle edit/view mode">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn" aria-label="How to use">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red × to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "Mark Center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Select mind maps from the dropdown at the top and save with the Save button.
      The first mind map created is named "landing map" and loads automatically on start.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-app.js";
  import { getFirestore, collection, doc, getDoc, setDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const mindMapSelect = document.getElementById('mindMapSelect');
  const newMindMapName = document.getElementById('newMindMapName');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;

  // --- Firestore collection for mind maps ---
  const mindMapsCol = collection(db, 'mindmaps');

  // Helpers
  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  // Transform update for zoom and pan
  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Draw bezier connections between boxes
  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(({ fromId, toId }) => {
      const boxA = boxesMap.get(fromId);
      const boxB = boxesMap.get(toId);
      if (!boxA || !boxB) return;
      const ax = parseFloat(boxA.style.left) + boxA.offsetWidth / 2;
      const ay = parseFloat(boxA.style.top) + boxA.offsetHeight / 2;
      const bx = parseFloat(boxB.style.left) + boxB.offsetWidth / 2;
      const by = parseFloat(boxB.style.top) + boxB.offsetHeight / 2;
      const startX = ax * scale + panX;
      const startY = ay * scale + panY;
      const endX = bx * scale + panX;
      const endY = by * scale + panY;
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const dx = endX - startX;
      const dy = endY - startY;
      const distance = Math.sqrt(dx*dx + dy*dy);
      if (distance === 0) return;
      const normX = dx / distance;
      const normY = dy / distance;
      const cpOffset = 40;
      const cpX = (startX + endX) / 2 - normY * cpOffset;
      const cpY = (startY + endY) / 2 + normX * cpOffset;
      path.setAttribute('d', `M${startX},${startY} Q${cpX},${cpY} ${endX},${endY}`);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      path.style.cursor = 'pointer';
      connectionLayer.appendChild(path);
    });
  }

  // Save current mind map to Firestore
  async function saveCurrentMap() {
    if (!currentMapId) {
      alert('No mind map selected to save.');
      return;
    }
    const boxesData = [];
    boxesMap.forEach(box => {
      const contentDiv = box.querySelector('.box-content');
      boxesData.push({
        id: box.dataset.id,
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        width: box.offsetWidth,
        height: box.offsetHeight,
        text: contentDiv.textContent,
        fontSize: window.getComputedStyle(contentDiv).fontSize,
        connections: getConnectionsForBox(box.dataset.id),
      });
    });

    const docRef = doc(mindMapsCol, currentMapId);
    await setDoc(docRef, { boxes: boxesData, center: { panX, panY, scale } });
    showSaveStatus('Saved');
  }

  // Get connections involving a box id as fromId or toId
  function getConnectionsForBox(boxId) {
    return connections
      .filter(c => c.fromId === boxId || c.toId === boxId)
      .map(c => ({ fromId: c.fromId, toId: c.toId }));
  }

  // Show save confirmation briefly
  function showSaveStatus(msg) {
    saveStatus.textContent = msg;
    saveStatus.style.opacity = '1';
    setTimeout(() => {
      saveStatus.style.opacity = '0';
    }, 1200);
  }

  // Load a mind map from Firestore by ID
  async function loadMindMap(mapId) {
    if (!mapId) return;
    currentMapId = mapId;
    clearMindMap();
    try {
      const docRef = doc(mindMapsCol, mapId);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists()) {
        // if no data, create landing map for first use
        if (mapId === 'landing map') {
          createNewMindMap('landing map');
          return;
        }
        alert('Mind map data not found.');
        return;
      }
      const data = docSnap.data();
      if (data.center) {
        panX = data.center.panX;
        panY = data.center.panY;
        scale = data.center.scale;
      }
      updateTransform();
      if (data.boxes && Array.isArray(data.boxes)) {
        data.boxes.forEach(boxData => {
          addBoxFromData(boxData);
        });
      }
      if (data.boxes) {
        connections.length = 0;
        data.boxes.forEach(box => {
          if (box.connections) {
            box.connections.forEach(conn => {
              if (!connections.find(c => c.fromId === conn.fromId && c.toId === conn.toId)) {
                connections.push(conn);
              }
            });
          }
        });
      }
      updateMindMapSelect();
      drawConnections();
    } catch (err) {
      alert('Error loading mind map: ' + err);
    }
  }

  // Clear all boxes and connections
  function clearMindMap() {
    boxesMap.clear();
    connections.length = 0;
    canvas.innerHTML = '';
    drawConnections();
    undoStack.length = 0;
    undoBtn.disabled = true;
    selectedBoxes.clear();
  }

  // Add box from saved data
  function addBoxFromData(boxData) {
    const box = createBox(boxData.x, boxData.y, boxData.width, boxData.height, boxData.text, boxData.fontSize);
    box.dataset.id = boxData.id;
    boxesMap.set(boxData.id, box);
  }

  // Generate unique id
  function generateId() {
    return 'box-' + Math.random().toString(36).slice(2, 10);
  }

  // Create new box element and add to canvas
  function createBox(x = 50, y = 50, width = 120, height = 60, text = '', fontSize = '14px') {
    const id = generateId();
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    box.dataset.id = id;

    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    dragHandle.title = 'Drag to move box';
    header.appendChild(dragHandle);

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.title = 'Click to connect this box';
    header.appendChild(connectToggle);

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.title = 'Delete box';
    header.appendChild(deleteBtn);

    box.appendChild(header);

    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.textContent = text;
    content.style.fontSize = fontSize || '14px';
    box.appendChild(content);

    // Resize handles
    ['nw','ne','sw','se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    canvas.appendChild(box);

    // Add event listeners
    addBoxEventListeners(box, dragHandle, deleteBtn, connectToggle, content);

    return box;
  }

  // Add all event listeners for a box
  function addBoxEventListeners(box, dragHandle, deleteBtn, connectToggle, content) {
    let dragging = false, dragOffsetX, dragOffsetY;
    let resizing = false, resizeDir, startWidth, startHeight, startX, startY;

    // Drag box move
    dragHandle.addEventListener('mousedown', e => {
      if (!editMode) return;
      dragging = true;
      dragOffsetX = e.clientX - box.offsetLeft;
      dragOffsetY = e.clientY - box.offsetTop;
      selectedBoxes.clear();
      selectedBoxes.add(box.dataset.id);
      box.classList.add('selected');
      document.body.style.cursor = 'grabbing';
      e.preventDefault();
    });

    // Multi-select shift+click on header including drag handle
    box.querySelector('.box-header').addEventListener('click', e => {
      if (!editMode) return;
      if (e.shiftKey) {
        if (selectedBoxes.has(box.dataset.id)) {
          selectedBoxes.delete(box.dataset.id);
          box.classList.remove('selected');
        } else {
          selectedBoxes.add(box.dataset.id);
          box.classList.add('selected');
        }
        e.preventDefault();
      } else {
        // single select clears others
        selectedBoxes.forEach(id => {
          if (id !== box.dataset.id) {
            const b = boxesMap.get(id);
            if (b) b.classList.remove('selected');
          }
        });
        selectedBoxes.clear();
        selectedBoxes.add(box.dataset.id);
        box.classList.add('selected');
      }
    });

    // Drag move multiple selected boxes
    document.addEventListener('mousemove', e => {
      if (dragging) {
        let newLeft = e.clientX - dragOffsetX;
        let newTop = e.clientY - dragOffsetY;

        // Move all selected boxes
        selectedBoxes.forEach(id => {
          const b = boxesMap.get(id);
          if (!b) return;
          const offsetX = parseFloat(b.style.left) - parseFloat(box.style.left);
          const offsetY = parseFloat(b.style.top) - parseFloat(box.style.top);
          b.style.left = (newLeft + offsetX) + 'px';
          b.style.top = (newTop + offsetY) + 'px';
        });
        drawConnections();
      }
      if (resizing) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        let newWidth = startWidth;
        let newHeight = startHeight;
        if (resizeDir.includes('e')) {
          newWidth = Math.max(40, startWidth + dx);
        }
        if (resizeDir.includes('s')) {
          newHeight = Math.max(24, startHeight + dy);
        }
        if (resizeDir.includes('w')) {
          newWidth = Math.max(40, startWidth - dx);
          if (newWidth > 40) box.style.left = startX + dx + 'px';
        }
        if (resizeDir.includes('n')) {
          newHeight = Math.max(24, startHeight - dy);
          if (newHeight > 24) box.style.top = startY + dy + 'px';
        }
        box.style.width = newWidth + 'px';
        box.style.height = newHeight + 'px';
        drawConnections();
      }
    });
    document.addEventListener('mouseup', e => {
      if (dragging) {
        dragging = false;
        document.body.style.cursor = '';
      }
      if (resizing) {
        resizing = false;
      }
    });

    // Resize handles
    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('mousedown', e => {
        if (!editMode) return;
        resizing = true;
        resizeDir = handle.classList.contains('nw') ? 'nw' :
                    handle.classList.contains('ne') ? 'ne' :
                    handle.classList.contains('sw') ? 'sw' : 'se';
        startWidth = box.offsetWidth;
        startHeight = box.offsetHeight;
        startX = e.clientX;
        startY = e.clientY;
        e.preventDefault();
      });
    });

    // Delete box
    deleteBtn.addEventListener('click', e => {
      if (!editMode) return;
      removeBox(box.dataset.id);
      e.stopPropagation();
    });

    // Connect toggle
    connectToggle.addEventListener('click', e => {
      if (!editMode) return;
      if (connectionStartBoxId === box.dataset.id) {
        // cancel connection
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (connectionStartBoxId) {
        // connect from connectionStartBoxId to this box id
        if (connectionStartBoxId !== box.dataset.id) {
          connections.push({ fromId: connectionStartBoxId, toId: box.dataset.id });
        }
        // Clear all toggles
        boxesMap.forEach(b => {
          const toggle = b.querySelector('.connect-toggle');
          toggle.classList.remove('active');
        });
        connectionStartBoxId = null;
        drawConnections();
      } else {
        // start connection
        connectionStartBoxId = box.dataset.id;
        connectToggle.classList.add('active');
      }
      e.stopPropagation();
    });

    // Content editing font size controls
    const fontSizeMinus = document.createElement('button');
    fontSizeMinus.className = 'font-size-btn';
    fontSizeMinus.textContent = '−';
    fontSizeMinus.title = 'Decrease font size';
    header.appendChild(fontSizeMinus);

    const fontSizePlus = document.createElement('button');
    fontSizePlus.className = 'font-size-btn';
    fontSizePlus.textContent = '+';
    fontSizePlus.title = 'Increase font size';
    header.appendChild(fontSizePlus);

    fontSizeMinus.addEventListener('click', e => {
      e.preventDefault();
      let currentSize = parseInt(window.getComputedStyle(content).fontSize);
      currentSize = Math.max(8, currentSize - 1);
      content.style.fontSize = currentSize + 'px';
    });
    fontSizePlus.addEventListener('click', e => {
      e.preventDefault();
      let currentSize = parseInt(window.getComputedStyle(content).fontSize);
      currentSize = Math.min(72, currentSize + 1);
      content.style.fontSize = currentSize + 'px';
    });

    // Content editable toggle on editMode change
    content.contentEditable = editMode;

    // Center text in content
    content.style.display = 'flex';
    content.style.justifyContent = 'center';
    content.style.alignItems = 'center';
    content.style.textAlign = 'center';

    return box;
  }

  // Remove box and save undo
  function removeBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    undoStack.push({
      type: 'delete',
      boxData: {
        id,
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        width: box.offsetWidth,
        height: box.offsetHeight,
        text: box.querySelector('.box-content').textContent,
        fontSize: window.getComputedStyle(box.querySelector('.box-content')).fontSize,
        connections: getConnectionsForBox(id),
      }
    });
    undoBtn.disabled = false;
    // Remove box
    canvas.removeChild(box);
    boxesMap.delete(id);
    // Remove connections involving this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].fromId === id || connections[i].toId === id) {
        connections.splice(i, 1);
      }
    }
    drawConnections();
  }

  // Undo delete box
  function undoDelete() {
    if (undoStack.length === 0) return;
    const action = undoStack.pop();
    if (action.type === 'delete') {
      const boxData = action.boxData;
      const box = createBox(boxData.x, boxData.y, boxData.width, boxData.height, boxData.text, boxData.fontSize);
      box.dataset.id = boxData.id;
      boxesMap.set(boxData.id, box);
      boxData.connections.forEach(conn => {
        if (!connections.find(c => c.fromId === conn.fromId && c.toId === conn.toId)) {
          connections.push(conn);
        }
      });
      drawConnections();
    }
    undoBtn.disabled = undoStack.length === 0;
  }

  // Zoom and pan handlers
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = -e.deltaY * 0.002;
    const oldScale = scale;
    scale = Math.min(3, Math.max(0.3, scale + delta));

    // Zoom to cursor
    const rect = viewport.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    panX -= (offsetX / oldScale) * (scale - oldScale);
    panY -= (offsetY / oldScale) * (scale - oldScale);
    updateTransform();
  });

  viewport.addEventListener('mousedown', e => {
    if (e.target !== viewport) return;
    isPanning = true;
    startX = e.clientX - panX;
    startY = e.clientY - panY;
    viewport.style.cursor = 'grabbing';
  });
  window.addEventListener('mouseup', e => {
    isPanning = false;
    viewport.style.cursor = 'grab';
  });
  window.addEventListener('mousemove', e => {
    if (!isPanning) return;
    panX = e.clientX - startX;
    panY = e.clientY - startY;
    updateTransform();
  });

  // Double click to create new box
  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / scale;
    const y = (e.clientY - rect.top) / scale;
    const box = createBox(x, y, 120, 60, '');
    boxesMap.set(box.dataset.id, box);
  });

  // Toggle edit/view mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    boxesMap.forEach(box => {
      box.querySelector('.box-content').contentEditable = editMode;
      box.querySelector('.connect-toggle').disabled = !editMode;
      box.querySelector('.delete-btn').disabled = !editMode;
      box.querySelectorAll('.resize-handle').forEach(h => h.style.display = editMode ? 'block' : 'none');
      box.querySelector('.drag-handle').style.display = editMode ? 'flex' : 'none';
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'Toggle View Mode';
  });

  // Undo delete
  undoBtn.addEventListener('click', undoDelete);

  // Go to center
  goCenterBtn.addEventListener('click', () => {
    panX = savedCenter.panX || 0;
    panY = savedCenter.panY || 0;
    scale = savedCenter.scale || 1;
    updateTransform();
  });

  // Mark center
  const savedCenter = { panX: 0, panY: 0, scale: 1 };
  markCenterBtn.addEventListener('click', () => {
    savedCenter.panX = panX;
    savedCenter.panY = panY;
    savedCenter.scale = scale;
    alert('Center marked! Use "Go to Center" to return here.');
  });

  // How to modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Mind map select dropdown change loads map immediately
  mindMapSelect.addEventListener('change', async () => {
    const selected = mindMapSelect.value;
    if (selected) {
      await loadMindMap(selected);
      newMindMapName.value = '';
    }
  });

  // Save button creates new map or saves existing
  saveMapBtn.addEventListener('click', async () => {
    let name = currentMapId;
    if (!name || name === 'landing map') {
      // if current is landing map and input provided, rename and save
      if (newMindMapName.value.trim()) {
        name = newMindMapName.value.trim();
        currentMapId = name;
      } else {
        alert('Please enter a name for your mind map.');
        return;
      }
    }
    await saveCurrentMap();
    await updateMindMapSelect(name);
    newMindMapName.value = '';
  });

  // Update mind map dropdown options from Firestore
  async function updateMindMapSelect(selectedId) {
    mindMapSelect.innerHTML = '';
    try {
      const querySnapshot = await getDocs(mindMapsCol);
      const ids = [];
      querySnapshot.forEach(docSnap => {
        ids.push(docSnap.id);
      });
      // if empty, add landing map default
      if (ids.length === 0) {
        ids.push('landing map');
      }
      ids.sort((a, b) => a.localeCompare(b));
      ids.forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = id;
        mindMapSelect.appendChild(opt);
      });
      if (selectedId && ids.includes(selectedId)) {
        mindMapSelect.value = selectedId;
      } else {
        mindMapSelect.value = ids[0];
      }
    } catch (e) {
      alert('Failed to fetch mind maps list: ' + e);
    }
  }

  // Create landing map if none exist
  async function createNewMindMap(name) {
    currentMapId = name;
    clearMindMap();
    const box = createBox(50, 50, 120, 60, 'Welcome to your landing map');
    boxesMap.set(box.dataset.id, box);
    panX = 0;
    panY = 0;
    scale = 1;
    updateTransform();
    await saveCurrentMap();
    await updateMindMapSelect(name);
  }

  // Initialize app: load mind maps and first load or create landing map
  async function init() {
    await updateMindMapSelect();
    if (mindMapSelect.options.length === 0) {
      await createNewMindMap('landing map');
    } else {
      currentMapId = mindMapSelect.value;
      await loadMindMap(currentMapId);
    }
  }

  // Start
  init();

</script>
</body>
</html>
