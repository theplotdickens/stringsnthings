<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>stringsnthings with Curvy Lines + Undo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
    touch-action: none;
  }
  #viewport {
    width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
    overflow: hidden;
    box-sizing: border-box;
  }
  #canvas {
    position: absolute; top: 0; left: 0; transform-origin: 0 0;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    padding: 8px;
    min-width: 80px;
    min-height: 40px;
    white-space: pre-wrap;
    font-family: monospace, monospace;
    user-select: text;
    touch-action: none;
    cursor: text;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    z-index: 10;
  }
  .box > div[contenteditable="true"] {
    outline: none;
    white-space: pre-wrap;
    word-break: break-word;
    font-family: monospace, monospace;
    user-select: text;
    cursor: text;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: 1.2;
  }
  .delete-btn {
    position: absolute;
    top: 2px; right: 4px;
    cursor: pointer;
    color: red;
    font-weight: bold;
    user-select: none;
    pointer-events: auto;
    z-index: 20;
  }
  .resize-handle {
    width: 16px;
    height: 16px;
    background: transparent;
    position: absolute;
    z-index: 20;
    touch-action: none;
  }
  .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
  .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
  .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

  #buttonContainer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    z-index: 1000;
  }
  .floatingBtn {
    background: rgba(100, 100, 100, 0.5);
    color: #eee;
    font-family: monospace, monospace;
    font-size: 16px;
    padding: 6px 12px;
    border: 1px solid #555;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    min-width: 100px;
    text-align: center;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    touch-action: manipulation;
    transition: background 0.2s ease;
  }
  .floatingBtn.active {
    background: rgba(50, 150, 200, 0.8);
    color: white;
  }
  .floatingBtn:active {
    background: rgba(80, 80, 80, 0.7);
  }
  .floatingBtn:disabled {
    background: rgba(150, 150, 150, 0.3);
    cursor: default;
    color: #999;
    border-color: #999;
    box-shadow: none;
  }

  /* SVG styling */
  #lineLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    overflow: visible;
    z-index: 5;
  }
  .line-path {
    fill: none;
    stroke: black;
    stroke-width: 2;
  }
  .line-label {
    font-family: monospace, monospace;
    font-size: 14px;
    fill: black;
    pointer-events: none;
    user-select: none;
  }
</style>
</head>
<body>
<div id="viewport">
  <svg id="lineLayer"></svg>
  <div id="canvas"></div>
</div>

<div id="buttonContainer">
  <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
  <button id="undoLineBtn" class="floatingBtn" disabled>Undo Line</button>
  <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
  <button id="drawLineToggle" class="floatingBtn">Draw Line OFF</button>
</div>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.firebasestorage.app",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const lineLayer = document.getElementById('lineLayer');

  const undoBtn = document.getElementById('undoBtn');
  const undoLineBtn = document.getElementById('undoLineBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const drawLineToggle = document.getElementById('drawLineToggle');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;
  const undoStack = [];
  const undoLineStack = [];

  let drawLineMode = false;
  let selectedBoxes = [];
  let currentPathPoints = [];
  let isDrawingPath = false;

  const boxesCollection = db.collection('boxes');
  const linesCollection = db.collection('lines');

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    lineLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  viewport.addEventListener('pointerdown', e => {
    if (drawLineMode) return; // no pan when drawing lines
    if (e.target.closest('.box') || e.target === goCenterBtn || e.target === undoBtn || e.target === undoLineBtn || e.target === drawLineToggle) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
  });
  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });
  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    scale *= dir;
    updateTransform();
  });

  // Box dragging variables
  const draggingInfo = {
    dragging: false,
    offsetX: 0,
    offsetY: 0,
    currentBox: null,
  };

  // Map box element => firestore doc id
  const idMap = new Map();
  // Map line doc id => {path, label, startBoxId, endBoxId, svg elements}
  const linesMap = new Map();

  function adjustFontSizeToFit(contentDiv, box) {
    const padding = 8;
    const maxFontSize = 100;
    const minFontSize = 8;
    contentDiv.style.fontSize = maxFontSize + 'px';
    const boxWidth = box.clientWidth - padding * 2;
    const boxHeight = box.clientHeight - padding * 2;
    let fontSize = maxFontSize;
    while (fontSize >= minFontSize) {
      contentDiv.style.fontSize = fontSize + 'px';
      if (contentDiv.scrollWidth <= boxWidth && contentDiv.scrollHeight <= boxHeight) break;
      fontSize -= 1;
    }
    if (fontSize < minFontSize) fontSize = minFontSize;
    contentDiv.style.fontSize = fontSize + 'px';
  }

  function addBox(x, y, text = 'Text box', id = null, width=180, height=80, fontSize='16px') {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = width + 'px';
    box.style.height = height + 'px';

    const content = document.createElement('div');
    content.contentEditable = true;
    content.style.minWidth = '80px';
    content.style.minHeight = '24px';
    content.style.whiteSpace = 'pre-wrap';
    content.style.wordBreak = 'break-word';
    content.style.outline = 'none';
    content.style.fontFamily = 'monospace, monospace';
    content.textContent = text;
    content.style.userSelect = 'text';
    content.style.cursor = 'text';
    content.style.height = '100%';
    content.style.width = '100%';
    content.style.boxSizing = 'border-box';
    content.style.padding = '0';
    content.style.margin = '0';
    content.style.overflow = 'visible';
    content.style.lineHeight = '1.2';
    content.style.fontSize = fontSize || '16px';

    if (fontSize === '16px' || !fontSize) {
      adjustFontSizeToFit(content, box);
    }

    content.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.execCommand('insertHTML', false, '\n');
      }
    });

    const delBtn = document.createElement('span');
    delBtn.className = 'delete-btn';
    delBtn.textContent = 'Ã—';

    box.appendChild(content);
    box.appendChild(delBtn);

    // Dragging logic
    box.addEventListener('pointerdown', e => {
      if (e.target === delBtn) return;
      if (drawLineMode) {
        e.stopPropagation();
        handleBoxSelection(box);
        return;
      }
      if (drawLineMode) return; // no drag when drawing lines
      draggingInfo.dragging = true;
      draggingInfo.offsetX = e.clientX - box.getBoundingClientRect().left;
      draggingInfo.offsetY = e.clientY - box.getBoundingClientRect().top;
      draggingInfo.currentBox = box;
      box.setPointerCapture(e.pointerId);
      box.style.cursor = 'grabbing';
    });
    box.addEventListener('pointermove', e => {
      if (!draggingInfo.dragging || draggingInfo.currentBox !== box) return;
      const newX = (e.clientX - draggingInfo.offsetX - panX) / scale;
      const newY = (e.clientY - draggingInfo.offsetY - panY) / scale;
      box.style.left = `${newX}px`;
      box.style.top = `${newY}px`;
      saveBox(box);
      updateLinesForBox(idMap.get(box));
    });
    box.addEventListener('pointerup', e => {
      if (draggingInfo.currentBox === box) {
        draggingInfo.dragging = false;
        draggingInfo.currentBox.style.cursor = 'text';
        draggingInfo.currentBox.releasePointerCapture(e.pointerId);
        draggingInfo.currentBox = null;
      }
    });

    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      undoStack.push({
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        text: content.textContent,
        width: box.offsetWidth,
        height: box.offsetHeight,
        fontSize: content.style.fontSize,
        id: idMap.get(box)
      });
      if (undoStack.length > 5) undoStack.shift();
      undoBtn.disabled = false;
      if (idMap.has(box)) {
        removeLinesForBox(idMap.get(box));
        boxesCollection.doc(idMap.get(box)).delete();
      }
      box.remove();
    });

    content.addEventListener('input', () => {
      adjustFontSizeToFit(content, box);
      saveBox(box);
    });

    function saveBox(boxElement) {
      const data = {
        x: parseFloat(boxElement.style.left),
        y: parseFloat(boxElement.style.top),
        width: boxElement.offsetWidth,
        height: boxElement.offsetHeight,
        text: boxElement.querySelector('div[contenteditable]').textContent,
        fontSize: boxElement.querySelector('div[contenteditable]').style.fontSize || '16px'
      };
      const boxId = idMap.get(boxElement);
      if (boxId) {
        boxesCollection.doc(boxId).set(data);
      } else {
        boxesCollection.add(data).then(docRef => {
          idMap.set(boxElement, docRef.id);
        });
      }
    }

    canvas.appendChild(box);
    if (!id) {
      boxesCollection.add({
        x, y, width, height,
        text, fontSize
      }).then(docRef => {
        idMap.set(box, docRef.id);
      });
    } else {
      idMap.set(box, id);
    }

    return box;
  }

  // Undo buttons
  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastBox = undoStack.pop();
    addBox(lastBox.x, lastBox.y, lastBox.text, null, lastBox.width, lastBox.height, lastBox.fontSize);
    if (undoStack.length === 0) undoBtn.disabled = true;
  });
  undoLineBtn.addEventListener('click', () => {
    if (undoLineStack.length === 0) return;
    const lastLineId = undoLineStack.pop();
    if (!lastLineId) return;
    linesCollection.doc(lastLineId).delete();
    if (undoLineStack.length === 0) undoLineBtn.disabled = true;
  });

  goCenterBtn.addEventListener('click', () => {
    panX = 0; panY = 0; updateTransform();
  });

  drawLineToggle.addEventListener('click', () => {
    drawLineMode = !drawLineMode;
    drawLineToggle.textContent = drawLineMode ? 'Draw Line ON' : 'Draw Line OFF';
    if (drawLineMode) {
      // Lock box dragging & editing: disable contentEditable and pointer events on boxes except click selection
      document.querySelectorAll('.box').forEach(box => {
        box.style.userSelect = 'none';
        box.querySelector('div[contenteditable]').contentEditable = false;
      });
    } else {
      document.querySelectorAll('.box').forEach(box => {
        box.style.userSelect = 'text';
        box.querySelector('div[contenteditable]').contentEditable = true;
      });
      selectedBoxes.forEach(box => box.style.borderColor = '');
      selectedBoxes = [];
      if (isDrawingPath) stopDrawingPath();
    }
  });

  // Handle box selection for line drawing
  function handleBoxSelection(box) {
    if (selectedBoxes.length === 0) {
      selectedBoxes.push(box);
      box.style.borderColor = 'blue';
    } else if (selectedBoxes.length === 1 && box !== selectedBoxes[0]) {
      selectedBoxes.push(box);
      box.style.borderColor = 'blue';
      startFreehandDrawing();
    }
  }

  let pathElement, labelElement;

  function startFreehandDrawing() {
    isDrawingPath = true;
    currentPathPoints = [];

    pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathElement.classList.add('line-path');
    lineLayer.appendChild(pathElement);

    labelElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelElement.classList.add('line-label');
    lineLayer.appendChild(labelElement);

    viewport.style.cursor = 'crosshair';

    viewport.addEventListener('pointerdown', pointerDownDraw);
    viewport.addEventListener('pointermove', pointerMoveDraw);
    viewport.addEventListener('pointerup', pointerUpDraw);
  }

  function pointerDownDraw(e) {
    if (!isDrawingPath) return;
    currentPathPoints = [];
    const pt = screenToCanvas(e.clientX, e.clientY);
    currentPathPoints.push(pt);
  }
  function pointerMoveDraw(e) {
    if (!isDrawingPath || currentPathPoints.length === 0) return;
    const pt = screenToCanvas(e.clientX, e.clientY);
    currentPathPoints.push(pt);
    redrawPath();
  }
  function pointerUpDraw(e) {
    if (!isDrawingPath) return;
    const label = prompt("Enter label for the line:", "");
    if (label === null) {
      cancelLineDrawing();
      return;
    }
    saveLine(label);
    stopDrawingPath();
  }

  function stopDrawingPath() {
    if (!isDrawingPath) return;
    viewport.style.cursor = 'grab';
    isDrawingPath = false;
    currentPathPoints = [];
    if (pathElement) {
      pathElement.remove();
      pathElement = null;
    }
    if (labelElement) {
      labelElement.remove();
      labelElement = null;
    }
    viewport.removeEventListener('pointerdown', pointerDownDraw);
    viewport.removeEventListener('pointermove', pointerMoveDraw);
    viewport.removeEventListener('pointerup', pointerUpDraw);
    selectedBoxes.forEach(box => box.style.borderColor = '');
    selectedBoxes = [];
  }

  function cancelLineDrawing() {
    if (!isDrawingPath) return;
    if (pathElement) pathElement.remove();
    if (labelElement) labelElement.remove();
    currentPathPoints = [];
    isDrawingPath = false;
    viewport.style.cursor = 'grab';
    selectedBoxes.forEach(box => box.style.borderColor = '');
    selectedBoxes = [];
  }

  // Convert screen coords to canvas coords accounting for pan/zoom
  function screenToCanvas(x, y) {
    return {
      x: (x - panX) / scale,
      y: (y - panY) / scale
    };
  }

  // Chaikinâ€™s algorithm for curve smoothing
  function smoothPoints(points, iterations = 3) {
    if (points.length < 3) return points;
    let pts = points.slice();
    for (let i = 0; i < iterations; i++) {
      let newPts = [];
      newPts.push(pts[0]);
      for (let j = 0; j < pts.length - 1; j++) {
        const p0 = pts[j];
        const p1 = pts[j+1];
        const Q = { x: 0.75 * p0.x + 0.25 * p1.x, y: 0.75 * p0.y + 0.25 * p1.y };
        const R = { x: 0.25 * p0.x + 0.75 * p1.x, y: 0.25 * p0.y + 0.75 * p1.y };
        newPts.push(Q);
        newPts.push(R);
      }
      newPts.push(pts[pts.length - 1]);
      pts = newPts;
    }
    return pts;
  }

  function redrawPath() {
    if (currentPathPoints.length < 2) return;
    const smoothPts = smoothPoints(currentPathPoints, 4);
    const d = createPathD(smoothPts);
    pathElement.setAttribute('d', d);

    // Update label position roughly halfway along path
    const midPt = getPathMidPoint(d);
    if (midPt) {
      labelElement.setAttribute('x', midPt.x);
      labelElement.setAttribute('y', midPt.y);
      labelElement.textContent = currentPathPoints.length > 10 ? labelElement.textContent : '';
    }
  }

  // Create SVG path data string with cubic Bezier from points
  function createPathD(points) {
    if (points.length < 2) return '';
    let d = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      const midX = (points[i-1].x + points[i].x) / 2;
      const midY = (points[i-1].y + points[i].y) / 2;
      d += ` Q ${points[i-1].x} ${points[i-1].y}, ${midX} ${midY}`;
    }
    // last point line
    const last = points[points.length -1];
    d += ` T ${last.x} ${last.y}`;
    return d;
  }

  // Get midpoint on SVG path string approximately
  function getPathMidPoint(d) {
    try {
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', d);
      const len = path.getTotalLength();
      const pt = path.getPointAtLength(len/2);
      return {x: pt.x, y: pt.y};
    } catch {
      return null;
    }
  }

  function saveLine(label) {
    if (selectedBoxes.length !== 2) return;
    const startBoxId = idMap.get(selectedBoxes[0]);
    const endBoxId = idMap.get(selectedBoxes[1]);
    if (!startBoxId || !endBoxId) return;

    const pointsToSave = currentPathPoints.map(p => ({x: p.x, y: p.y}));
    linesCollection.add({
      startBoxId,
      endBoxId,
      points: pointsToSave,
      label
    }).then(docRef => {
      undoLineStack.push(docRef.id);
      if (undoLineStack.length > 5) undoLineStack.shift();
      undoLineBtn.disabled = false;

      linesMap.set(docRef.id, {
        points: pointsToSave,
        label,
        startBoxId,
        endBoxId,
        svgPath: pathElement,
        svgLabel: labelElement
      });

      pathElement = null;
      labelElement = null;
      currentPathPoints = [];
    });

    selectedBoxes.forEach(box => box.style.borderColor = '');
    selectedBoxes = [];
  }

  // Remove all lines connected to a box when box is deleted
  function removeLinesForBox(boxId) {
    const toRemove = [];
    linesMap.forEach((line, lineId) => {
      if (line.startBoxId === boxId || line.endBoxId === boxId) toRemove.push(lineId);
    });
    toRemove.forEach(lineId => {
      linesCollection.doc(lineId).delete();
      const line = linesMap.get(lineId);
      if (line) {
        line.svgPath.remove();
        line.svgLabel.remove();
      }
      linesMap.delete(lineId);
    });
  }

  // Update lines when box moves
  function updateLinesForBox(boxId) {
    linesMap.forEach((line, lineId) => {
      if (line.startBoxId === boxId || line.endBoxId === boxId) {
        const startBox = [...idMap.entries()].find(([el, id]) => id === line.startBoxId)?.[0];
        const endBox = [...idMap.entries()].find(([el, id]) => id === line.endBoxId)?.[0];
        if (!startBox || !endBox) return;

        const oldStart = line.points[0];
        const oldEnd = line.points[line.points.length - 1];
        const newStart = {
          x: parseFloat(startBox.style.left) + startBox.offsetWidth / 2,
          y: parseFloat(startBox.style.top) + startBox.offsetHeight / 2
        };
        const newEnd = {
          x: parseFloat(endBox.style.left) + endBox.offsetWidth / 2,
          y: parseFloat(endBox.style.top) + endBox.offsetHeight / 2
        };

        const dx = newStart.x - oldStart.x;
        const dy = newStart.y - oldStart.y;
        const dxEnd = newEnd.x - oldEnd.x;
        const dyEnd = newEnd.y - oldEnd.y;

        const newPoints = line.points.map((pt, i) => {
          if (i === 0) return newStart;
          if (i === line.points.length - 1) return newEnd;
          const t = i / (line.points.length - 1);
          return {
            x: pt.x + dx * (1 - t) + dxEnd * t,
            y: pt.y + dy * (1 - t) + dyEnd * t
          };
        });

        line.points = newPoints;
        const d = createPathD(smoothPoints(newPoints, 4));
        line.svgPath.setAttribute('d', d);

        const midPt = getPathMidPoint(d);
        if (midPt) {
          line.svgLabel.setAttribute('x', midPt.x);
          line.svgLabel.setAttribute('y', midPt.y);
          line.svgLabel.textContent = line.label;
        }

        linesCollection.doc(lineId).set({
          startBoxId: line.startBoxId,
          endBoxId: line.endBoxId,
          points: newPoints,
          label: line.label
        });
      }
    });
  }

  // Load existing boxes and lines
  function loadFromFirestore() {
    boxesCollection.onSnapshot(snapshot => {
      snapshot.docChanges().forEach(change => {
        const data = change.doc.data();
        if (change.type === 'added') {
          addBox(data.x, data.y, data.text, change.doc.id, data.width, data.height, data.fontSize);
        } else if (change.type === 'modified') {
          const boxEntry = [...idMap.entries()].find(([el, id]) => id === change.doc.id);
          if (boxEntry) {
            const [boxEl] = boxEntry;
            boxEl.style.left = data.x + 'px';
            boxEl.style.top = data.y + 'px';
            boxEl.style.width = data.width + 'px';
            boxEl.style.height = data.height + 'px';
            const contentDiv = boxEl.querySelector('div[contenteditable]');
            contentDiv.textContent = data.text;
            contentDiv.style.fontSize = data.fontSize;
            adjustFontSizeToFit(contentDiv, boxEl);
            updateLinesForBox(change.doc.id);
          }
        } else if (change.type === 'removed') {
          const boxEntry = [...idMap.entries()].find(([el, id]) => id === change.doc.id);
          if (boxEntry) {
            const [boxEl] = boxEntry;
            boxEl.remove();
            idMap.delete(boxEl);
          }
        }
      });
    });

    linesCollection.onSnapshot(snapshot => {
      snapshot.docChanges().forEach(change => {
        const data = change.doc.data();
        if (change.type === 'added') {
          drawSavedLine(change.doc.id, data);
        } else if (change.type === 'modified') {
          updateSavedLine(change.doc.id, data);
        } else if (change.type === 'removed') {
          removeSavedLine(change.doc.id);
        }
      });
    });
  }

  function drawSavedLine(id, data) {
    if (linesMap.has(id)) return;
    const startBoxEntry = [...idMap.entries()].find(([el, bid]) => bid === data.startBoxId);
    const endBoxEntry = [...idMap.entries()].find(([el, bid]) => bid === data.endBoxId);
    if (!startBoxEntry || !endBoxEntry) return;

    const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathEl.classList.add('line-path');
    lineLayer.appendChild(pathEl);

    const labelEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelEl.classList.add('line-label');
    lineLayer.appendChild(labelEl);

    linesMap.set(id, {
      points: data.points,
      label: data.label,
      startBoxId: data.startBoxId,
      endBoxId: data.endBoxId,
      svgPath: pathEl,
      svgLabel: labelEl
    });

    updateLinesForBox(data.startBoxId);
    updateLinesForBox(data.endBoxId);
  }

  function updateSavedLine(id, data) {
    if (!linesMap.has(id)) return;
    const line = linesMap.get(id);
    line.points = data.points;
    line.label = data.label;
    updateLinesForBox(line.startBoxId);
  }

  function removeSavedLine(id) {
    if (!linesMap.has(id)) return;
    const line = linesMap.get(id);
    line.svgPath.remove();
    line.svgLabel.remove();
    linesMap.delete(id);
  }

  // Create default box if none exist
  boxesCollection.get().then(snapshot => {
    if (snapshot.empty) {
      addBox(100, 100, 'Hello World');
    }
  });

  loadFromFirestore();
</script>
</body>
</html>
