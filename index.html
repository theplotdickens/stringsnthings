<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>stringsnthings</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    font-family: Garamond, serif;
    background: #eee;
  }
  #viewport {
    position: relative;
    width: 100vw; height: 100vh;
    overflow: hidden;
    cursor: grab;
  }
  #lineLayer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 0;
  }
  #boxesContainer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 10;
    user-select: none;
  }
  .box {
    position: absolute;
    background: white;
    border: 1px solid black;
    padding: 8px;
    min-width: 80px; min-height: 40px;
    box-sizing: border-box;
    font-size: 16px;
    cursor: move;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    user-select: text;
    /* smooth font size resize */
    transition: font-size 0.1s;
  }
  .box[contenteditable="true"]:focus {
    outline: 2px solid #09f;
  }
  /* Invisible resize handles */
  .resizer {
    position: absolute;
    width: 16px;
    height: 16px;
    background: transparent;
    /* cursor styles for corners */
  }
  .resizer.top-left { top: -8px; left: -8px; cursor: nwse-resize; }
  .resizer.top-right { top: -8px; right: -8px; cursor: nesw-resize; }
  .resizer.bottom-left { bottom: -8px; left: -8px; cursor: nesw-resize; }
  .resizer.bottom-right { bottom: -8px; right: -8px; cursor: nwse-resize; }

  #menuBar {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: rgba(128,128,128,0.3);
    padding: 6px 10px;
    font-family: Garamond, serif;
    display: flex;
    gap: 12px;
    user-select: none;
    z-index: 20;
  }
  button.floating-button {
    background: rgba(128,128,128,0.3);
    border: none;
    padding: 4px 12px;
    font-family: Garamond, serif;
    cursor: pointer;
    font-size: 16px;
    border-radius: 4px;
    user-select: none;
  }
  button.floating-button:focus {
    outline: 2px solid #09f;
  }
  path.line-path {
    fill: none;
    stroke: black;
    stroke-width: 2;
  }
  text.line-label {
    font-family: Garamond, serif;
    font-size: 14px;
    user-select: none;
    pointer-events: none;
    fill: black;
  }
</style>
</head>
<body>

<div id="viewport">
  <svg id="lineLayer"></svg>
  <div id="boxesContainer"></div>
</div>

<div id="menuBar">
  <button id="btnCenter" class="floating-button">Go to Center</button>
  <button id="btnToggleDraw" class="floating-button">Draw Line OFF</button>
  <button id="btnUndoDelete" class="floating-button" disabled>Undo Delete</button>
  <button id="btnUndoLine" class="floating-button" disabled>Undo Line</button>
</div>

<script>
  const viewport = document.getElementById('viewport');
  const lineLayer = document.getElementById('lineLayer');
  const boxesContainer = document.getElementById('boxesContainer');

  let panX = 0, panY = 0, scale = 1;
  let isPanning = false;
  let panStart = {x:0, y:0};
  let panOrigin = {x:0, y:0};

  let isDrawingPath = false;
  let currentPathPoints = [];
  let pathElement = null;
  let labelElement = null;

  let boxIdCounter = 0;
  const idMap = new Map();

  const undoDeleteStack = [];
  const undoLineStack = [];

  // Pan/zoom handlers
  viewport.addEventListener('pointerdown', e => {
    if (isDrawingPath) return; 
    if (e.target !== viewport) return;
    isPanning = true;
    panStart = {x: e.clientX, y: e.clientY};
    panOrigin = {x: panX, y: panY};
    viewport.style.cursor = 'grabbing';
  });
  window.addEventListener('pointerup', e => {
    if (isPanning) {
      isPanning = false;
      viewport.style.cursor = 'grab';
    }
  });
  window.addEventListener('pointermove', e => {
    if (!isPanning) return;
    panX = panOrigin.x + (e.clientX - panStart.x);
    panY = panOrigin.y + (e.clientY - panStart.y);
    updateTransform();
  });
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    let oldScale = scale;
    scale += e.deltaY * -0.001;
    scale = Math.min(Math.max(0.1, scale), 5);
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    panX -= (mx / oldScale - mx / scale);
    panY -= (my / oldScale - my / scale);
    updateTransform();
  }, { passive: false });

  function updateTransform() {
    boxesContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    lineLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  // Add box with resizers
  function addBox(x, y, text = 'Edit me', id=null) {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.contentEditable = !isDrawingPath;
    box.textContent = text;
    box.style.fontSize = '16px';
    box.dataset.id = id || 'box-' + (++boxIdCounter);
    idMap.set(box, box.dataset.id);

    // Create resizers
    const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    corners.forEach(corner => {
      const resizer = document.createElement('div');
      resizer.className = 'resizer ' + corner;
      box.appendChild(resizer);

      resizer.addEventListener('pointerdown', e => {
        if (isDrawingPath) return;
        e.stopPropagation();
        startResize(box, corner, e);
      });
    });

    // Drag to move box anywhere in box (except resizers)
    let dragStart = null;
    box.addEventListener('pointerdown', e => {
      if (isDrawingPath) return;
      if (e.target.classList.contains('resizer')) return;
      dragStart = {x: e.clientX, y: e.clientY};
      box.style.cursor = 'grabbing';
      e.stopPropagation();
      window.addEventListener('pointermove', dragMove);
      window.addEventListener('pointerup', dragEnd);
    });
    function dragMove(e) {
      if (!dragStart) return;
      let dx = (e.clientX - dragStart.x) / scale;
      let dy = (e.clientY - dragStart.y) / scale;
      const left = parseFloat(box.style.left) + dx;
      const top = parseFloat(box.style.top) + dy;
      box.style.left = left + 'px';
      box.style.top = top + 'px';
      dragStart = {x: e.clientX, y: e.clientY};
      updateLinesForBox(box.dataset.id);
    }
    function dragEnd(e) {
      dragStart = null;
      box.style.cursor = 'move';
      window.removeEventListener('pointermove', dragMove);
      window.removeEventListener('pointerup', dragEnd);
    }

    boxesContainer.appendChild(box);
    return box;
  }

  // Resizing logic
  function startResize(box, corner, e) {
    e.preventDefault();
    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = box.offsetWidth;
    const startHeight = box.offsetHeight;
    const startLeft = parseFloat(box.style.left);
    const startTop = parseFloat(box.style.top);
    function onPointerMove(ev) {
      ev.preventDefault();
      let dx = (ev.clientX - startX) / scale;
      let dy = (ev.clientY - startY) / scale;
      let newWidth = startWidth;
      let newHeight = startHeight;
      let newLeft = startLeft;
      let newTop = startTop;

      switch (corner) {
        case 'top-left':
          newWidth = startWidth - dx;
          newHeight = startHeight - dy;
          newLeft = startLeft + dx;
          newTop = startTop + dy;
          break;
        case 'top-right':
          newWidth = startWidth + dx;
          newHeight = startHeight - dy;
          newTop = startTop + dy;
          break;
        case 'bottom-left':
          newWidth = startWidth - dx;
          newHeight = startHeight + dy;
          newLeft = startLeft + dx;
          break;
        case 'bottom-right':
          newWidth = startWidth + dx;
          newHeight = startHeight + dy;
          break;
      }
      if (newWidth < 40) newWidth = 40;
      if (newHeight < 30) newHeight = 30;

      box.style.width = newWidth + 'px';
      box.style.height = newHeight + 'px';
      box.style.left = newLeft + 'px';
      box.style.top = newTop + 'px';

      // Adjust font size smoothly (fill box)
      adjustFontSize(box);

      updateLinesForBox(box.dataset.id);
    }
    function onPointerUp(ev) {
      window.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
    }
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
  }

  // Adjust font size to fill box with a margin
  function adjustFontSize(box) {
    const padding = 16; // padding left+right inside box
    const maxWidth = box.clientWidth - padding;
    const maxHeight = box.clientHeight - padding;
    const text = box.textContent || "Edit me";
    // Start from 10px up to 72px max font size to fit
    let fontSize = 10;
    const maxFont = 72;

    const testDiv = document.createElement('div');
    testDiv.style.position = 'absolute';
    testDiv.style.visibility = 'hidden';
    testDiv.style.whiteSpace = 'pre-wrap';
    testDiv.style.fontFamily = getComputedStyle(box).fontFamily;
    testDiv.style.fontWeight = getComputedStyle(box).fontWeight;
    testDiv.style.width = maxWidth + 'px';
    testDiv.style.lineHeight = '1.1';
    testDiv.style.padding = '0';
    testDiv.style.margin = '0';
    document.body.appendChild(testDiv);

    for (; fontSize <= maxFont; fontSize += 1) {
      testDiv.style.fontSize = fontSize + 'px';
      testDiv.textContent = text;
      if (testDiv.scrollHeight > maxHeight || testDiv.scrollWidth > maxWidth) {
        fontSize -= 1;
        break;
      }
    }
    document.body.removeChild(testDiv);

    if (fontSize < 10) fontSize = 10;
    box.style.fontSize = fontSize + 'px';
  }

  // Line drawing functions
  function screenToCanvas(x, y) {
    return {
      x: (x - panX) / scale,
      y: (y - panY) / scale
    };
  }

  function pointerDownDraw(e) {
    if (!isDrawingPath) return;
    e.preventDefault();
    currentPathPoints = [screenToCanvas(e.clientX, e.clientY)];
    pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathElement.classList.add('line-path');
    lineLayer.appendChild(pathElement);

    labelElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelElement.classList.add('line-label');
    lineLayer.appendChild(labelElement);
  }

  function pointerMoveDraw(e) {
    if (!isDrawingPath || !pathElement) return;
    e.preventDefault();
    currentPathPoints.push(screenToCanvas(e.clientX, e.clientY));
    const d = createPathD(smoothPoints(currentPathPoints, 4));
    pathElement.setAttribute('d', d);
    const mid = getPathMidPoint(d);
    if (mid) {
      labelElement.setAttribute('x', mid.x);
      labelElement.setAttribute('y', mid.y);
      labelElement.textContent = '';
    }
  }

  function pointerUpDraw(e) {
    if (!isDrawingPath || !pathElement) return;
    e.preventDefault();

    const label = prompt('Label for this line? (optional)') || '';
    labelElement.textContent = label;

    undoLineStack.push({points: currentPathPoints.slice(), label, pathElement, labelElement});
    if (undoLineStack.length > 5) undoLineStack.shift();
    btnUndoLine.disabled = false;

    currentPathPoints = [];
    pathElement = null;
    labelElement = null;
  }

  // Path helpers
  function smoothPoints(points, iterations=3) {
    if (points.length < 3) return points;
    let pts = points.slice();
    for (let i = 0; i < iterations; i++) {
      let newPts = [];
      newPts.push(pts[0]);
      for (let j = 0; j < pts.length - 1; j++) {
        const p0 = pts[j];
        const p1 = pts[j + 1];
        const Q = { x: 0.75 * p0.x + 0.25 * p1.x, y: 0.75 * p0.y + 0.25 * p1.y };
        const R = { x: 0.25 * p0.x + 0.75 * p1.x, y: 0.25 * p0.y + 0.75 * p1.y };
        newPts.push(Q, R);
      }
      newPts.push(pts[pts.length - 1]);
      pts = newPts;
    }
    return pts;
  }
  function createPathD(points) {
    if (points.length < 2) return '';
    let d = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      const midX = (points[i-1].x + points[i].x)/2;
      const midY = (points[i-1].y + points[i].y)/2;
      d += ` Q ${points[i-1].x} ${points[i-1].y}, ${midX} ${midY}`;
    }
    const last = points[points.length - 1];
    d += ` T ${last.x} ${last.y}`;
    return d;
  }
  function getPathMidPoint(d) {
    try {
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', d);
      const len = path.getTotalLength();
      const pt = path.getPointAtLength(len/2);
      return {x: pt.x, y: pt.y};
    } catch {
      return null;
    }
  }

  // Update all lines connected to a box id (stub for now)
  function updateLinesForBox(boxId) {
    // Could implement line endpoints attached to boxes in future
    // For now do nothing
  }

  // Toggle line drawing mode
  const btnToggleDraw = document.getElementById('btnToggleDraw');
  btnToggleDraw.addEventListener('click', () => {
    isDrawingPath = !isDrawingPath;
    if (isDrawingPath) {
      lineLayer.style.pointerEvents = 'auto';
      boxesContainer.style.pointerEvents = 'none';
      viewport.style.cursor = 'crosshair';
      btnToggleDraw.textContent = 'Draw Line ON';
      document.querySelectorAll('.box').forEach(b => {
        b.contentEditable = 'false';
        b.style.cursor = 'default';
      });
    } else {
      lineLayer.style.pointerEvents = 'none';
      boxesContainer.style.pointerEvents = 'auto';
      viewport.style.cursor = 'grab';
      btnToggleDraw.textContent = 'Draw Line OFF';
      document.querySelectorAll('.box').forEach(b => {
        b.contentEditable = 'true';
        b.style.cursor = 'move';
      });
    }
  });

  // Undo buttons (delete and line undo stub)
  const btnUndoDelete = document.getElementById('btnUndoDelete');
  const btnUndoLine = document.getElementById('btnUndoLine');

  btnUndoDelete.addEventListener('click', () => {
    alert('Undo delete not implemented yet');
  });
  btnUndoLine.addEventListener('click', () => {
    if (undoLineStack.length === 0) return;
    const last = undoLineStack.pop();
    if (last.pathElement) lineLayer.removeChild(last.pathElement);
    if (last.labelElement) lineLayer.removeChild(last.labelElement);
    btnUndoLine.disabled = undoLineStack.length === 0;
  });

  // Center button
  const btnCenter = document.getElementById('btnCenter');
  btnCenter.addEventListener('click', () => {
    panX = window.innerWidth/2;
    panY = window.innerHeight/2;
    updateTransform();
  });

  // Add new box on click if not drawing
  viewport.addEventListener('dblclick', e => {
    if (isDrawingPath) return;
    const pt = screenToCanvas(e.clientX, e.clientY);
    addBox(pt.x, pt.y);
  });

  // Line drawing pointer handlers
  lineLayer.style.pointerEvents = 'none';
  lineLayer.addEventListener('pointerdown', pointerDownDraw);
  window.addEventListener('pointermove', pointerMoveDraw);
  window.addEventListener('pointerup', pointerUpDraw);

  // Initial center position
  panX = window.innerWidth/2;
  panY = window.innerHeight/2;
  updateTransform();

  // Load from localStorage on start (boxes and lines)
  function saveData() {
    const boxes = [];
    document.querySelectorAll('.box').forEach(b => {
      boxes.push({
        id: b.dataset.id,
        text: b.textContent,
        left: parseFloat(b.style.left),
        top: parseFloat(b.style.top),
        width: b.offsetWidth,
        height: b.offsetHeight,
        fontSize: b.style.fontSize || '16px',
      });
    });
    const lines = [];
    lineLayer.querySelectorAll('path.line-path').forEach((p, i) => {
      const label = lineLayer.querySelectorAll('text.line-label')[i];
      lines.push({
        d: p.getAttribute('d'),
        label: label ? label.textContent : ''
      });
    });
    localStorage.setItem('stringsnthings_boxes', JSON.stringify(boxes));
    localStorage.setItem('stringsnthings_lines', JSON.stringify(lines));
    localStorage.setItem('stringsnthings_pan', JSON.stringify({panX, panY}));
  }
  function loadData() {
    const boxes = JSON.parse(localStorage.getItem('stringsnthings_boxes')||'[]');
    boxesContainer.innerHTML = '';
    boxes.forEach(b => {
      const box = addBox(b.left, b.top, b.text, b.id);
      box.style.width = b.width + 'px';
      box.style.height = b.height + 'px';
      box.style.fontSize = b.fontSize || '16px';
      adjustFontSize(box);
    });
    const lines = JSON.parse(localStorage.getItem('stringsnthings_lines')||'[]');
    lineLayer.innerHTML = '';
    lines.forEach(line => {
      const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute('d', line.d);
      p.classList.add('line-path');
      lineLayer.appendChild(p);
      if (line.label) {
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.classList.add('line-label');
        const mid = getPathMidPoint(line.d);
        if (mid) {
          t.setAttribute('x', mid.x);
          t.setAttribute('y', mid.y);
          t.textContent = line.label;
          lineLayer.appendChild(t);
        }
      }
    });
    const panData = JSON.parse(localStorage.getItem('stringsnthings_pan')||'null');
    if (panData) {
      panX = panData.panX;
      panY = panData.panY;
      updateTransform();
    }
  }

  // Save data on edits, moves, resize, text input
  function addSaveListeners(box) {
    box.addEventListener('input', () => {
      adjustFontSize(box);
      saveData();
    });
    ['pointerup', 'pointerleave'].forEach(evt => {
      box.addEventListener(evt, () => {
        saveData();
      });
    });
  }

  // Attach save listeners on box creation
  const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
      mutation.addedNodes.forEach(node => {
        if (node.classList && node.classList.contains('box')) {
          addSaveListeners(node);
          adjustFontSize(node);
        }
      });
    });
  });
  observer.observe(boxesContainer, { childList: true });

  loadData();
</script>

</body>
</html>
