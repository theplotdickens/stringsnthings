<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsV4Complete</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
      padding-top: 40px;
    }
    #canvas {
      position: absolute; top: 40px; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 40px; left: 0;
      width: 100%; height: calc(100% - 40px);
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }

    /* Top utility bar */
    #topBar {
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 40px;
      background: #222;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 0 12px;
      font-family: monospace, monospace;
      z-index: 1100;
      user-select: none;
    }
    #mapSelect {
      font-family: monospace, monospace;
      font-size: 14px;
      padding: 4px 8px;
      border-radius: 4px;
      border: none;
      min-width: 180px;
    }
    #mapNameInput {
      font-family: monospace, monospace;
      font-size: 14px;
      padding: 4px 8px;
      border-radius: 4px;
      border: none;
      min-width: 140px;
      box-sizing: border-box;
    }
    #saveMapBtn {
      background: #0066cc;
      border: none;
      padding: 6px 14px;
      border-radius: 4px;
      font-family: monospace, monospace;
      font-size: 14px;
      color: white;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:active {
      background: #004999;
    }
    #savedConfirmation {
      color: #0f0;
      font-family: monospace, monospace;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.5s ease;
      user-select: none;
      min-width: 80px;
      text-align: center;
    }

  </style>
</head>
<body>
  <div id="topBar" aria-label="Mind map controls">
    <select id="mapSelect" aria-label="Select mind map"></select>
    <input id="mapNameInput" type="text" placeholder="New map name" aria-label="Mind map name input" />
    <button id="saveMapBtn" aria-label="Save mind map">Save</button>
    <div id="savedConfirmation" aria-live="polite" role="status">Saved!</div>
  </div>

  <div id="viewport" aria-label="Mind map viewport" role="main" tabindex="0">
    <svg id="connectionLayer" aria-hidden="true"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer" aria-label="Editing controls">
    <button id="undoBtn" class="floatingBtn" disabled aria-label="Undo delete">Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn" aria-label="Go to center">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn" aria-label="Mark center">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn" aria-label="Toggle edit mode">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn" aria-label="How to use instructions">How to Use</button>
  </div>

  <div id="howToModal" style="display:none; position:fixed; top:50%; left:50%; transform: translate(-50%, -50%);
       background:white; border: 2px solid black; padding: 20px; z-index: 2000; width: 80vw; max-width: 600px; max-height: 70vh; overflow-y: auto; font-family: monospace;">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false" style="white-space: pre-wrap; user-select: text;">
Double click anywhere to create a new text box.
Toggle edit mode on and off to make or prevent changes.
Use the ✥ symbol in the top left corner to move boxes.
Use the red x to delete boxes.
Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
Use the resize handles at the corners to resize boxes.
On the bottom of the screen, use "mark center" to fix yourself a return point.
Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
Save your mind map with the Save button on top.
Select another map from the dropdown to load it instantly.
    </p>
    <button id="closeHowToBtn" style="margin-top: 12px; padding: 6px 12px; cursor: pointer;">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import {
    getFirestore,
    collection,
    doc,
    getDocs,
    getDoc,
    setDoc,
    updateDoc,
    deleteDoc,
    query,
    orderBy
  } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9ba9e2ffac0cf42b"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // HTML elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');

  const mapSelect = document.getElementById('mapSelect');
  const mapNameInput = document.getElementById('mapNameInput');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const savedConfirmation = document.getElementById('savedConfirmation');

  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let currentMapName = null;

  // Utility functions

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  function drawConnections() {
    connectionLayer.innerHTML = '';
    connections.forEach(({ fromId, toId }) => {
      const boxA = boxesMap.get(fromId);
      const boxB = boxesMap.get(toId);
      if (!boxA || !boxB) return;
      const ax = parseFloat(boxA.style.left) + boxA.offsetWidth / 2;
      const ay = parseFloat(boxA.style.top) + boxA.offsetHeight / 2;
      const bx = parseFloat(boxB.style.left) + boxB.offsetWidth / 2;
      const by = parseFloat(boxB.style.top) + boxB.offsetHeight / 2;
      const startX = ax * scale + panX;
      const startY = ay * scale + panY;
      const endX = bx * scale + panX;
      const endY = by * scale + panY;
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const dx = endX - startX;
      const dy = endY - startY;
      const distance = Math.sqrt(dx*dx + dy*dy);
      if (distance === 0) return;
      const normX = dx / distance;
      const normY = dy / distance;
      const cpOffset = 40;
      const cpX = (startX + endX) / 2 - normY * cpOffset;
      const cpY = (startY + endY) / 2 + normX * cpOffset;
      path.setAttribute('d', `M${startX},${startY} Q${cpX},${cpY} ${endX},${endY}`);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      path.style.cursor = 'pointer';
      connectionLayer.appendChild(path);
    });
  }

  // Save/load state helpers

  function serializeBoxes() {
    const boxesData = [];
    boxesMap.forEach(box => {
      const contentDiv = box.querySelector('.box-content');
      boxesData.push({
        id: box.dataset.id,
        x: parseFloat(box.style.left),
        y: parseFloat(box.style.top),
        width: box.offsetWidth,
        height: box.offsetHeight,
        text: contentDiv.textContent,
        fontSize: window.getComputedStyle(contentDiv).fontSize
      });
    });
    return boxesData;
  }

  function clearCanvas() {
    boxesMap.forEach(box => box.remove());
    boxesMap.clear();
    connections.length = 0;
    drawConnections();
    undoStack.length = 0;
    undoBtn.disabled = true;
  }

  function addBox(x, y, text = 'Text box', id = null, width=180, height=80, save=true, fontSize = null) {
    const box = document.createElement('div');
    box.className = 'box';
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
    box.style.width = width + 'px';
    box.style.height = height + 'px';
    if (!id) id = generateId();
    box.dataset.id = id;

    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    header.appendChild(dragHandle);

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.setAttribute('aria-label', 'Delete box');
    deleteBtn.textContent = '×';
    header.appendChild(deleteBtn);

    const connectToggle = document.createElement('button');
    connectToggle.className = 'connect-toggle';
    connectToggle.setAttribute('aria-label', 'Toggle connection mode');
    header.appendChild(connectToggle);

    const fontMinus = document.createElement('button');
    fontMinus.className = 'font-size-btn';
    fontMinus.textContent = '−';
    fontMinus.title = 'Decrease font size';
    header.appendChild(fontMinus);

    const fontPlus = document.createElement('button');
    fontPlus.className = 'font-size-btn';
    fontPlus.textContent = '+';
    fontPlus.title = 'Increase font size';
    header.appendChild(fontPlus);

    box.appendChild(header);

    const contentDiv = document.createElement('div');
    contentDiv.className = 'box-content';
    contentDiv.contentEditable = editMode ? 'true' : 'false';
    contentDiv.spellcheck = false;
    contentDiv.textContent = text;
    if (fontSize) contentDiv.style.fontSize = fontSize;
    box.appendChild(contentDiv);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = document.createElement('div');
      handle.className = `resize-handle ${corner}`;
      box.appendChild(handle);
    });

    canvas.appendChild(box);
    boxesMap.set(id, box);

    // Event handlers

    deleteBtn.addEventListener('click', e => {
      e.stopPropagation();
      undoStack.push({
        action: 'deleteBox',
        boxData: getBoxData(box),
        connections: connections.filter(c => c.fromId === id || c.toId === id)
      });
      undoBtn.disabled = false;
      removeBox(id);
    });

    connectToggle.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        // Cancel current connection
        connectionStartBoxId = null;
        connectToggle.classList.remove('active');
      } else if (!connectionStartBoxId) {
        // Start connection
        connectionStartBoxId = id;
        connectToggle.classList.add('active');
      } else {
        // Finish connection
        if (connectionStartBoxId !== id) {
          // Add connection
          if (!connections.find(c => c.fromId === connectionStartBoxId && c.toId === id)) {
            connections.push({ fromId: connectionStartBoxId, toId: id });
          }
          // Clear old active toggle
          const oldBox = boxesMap.get(connectionStartBoxId);
          if (oldBox) {
            const oldToggle = oldBox.querySelector('.connect-toggle');
            if (oldToggle) oldToggle.classList.remove('active');
          }
          connectionStartBoxId = null;
          drawConnections();
        }
      }
    });

    fontMinus.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      const currentSize = parseInt(window.getComputedStyle(contentDiv).fontSize);
      if (currentSize > 8) contentDiv.style.fontSize = (currentSize - 1) + 'px';
    });

    fontPlus.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      const currentSize = parseInt(window.getComputedStyle(contentDiv).fontSize);
      if (currentSize < 72) contentDiv.style.fontSize = (currentSize + 1) + 'px';
    });

    // Drag to move box or group
    dragHandle.addEventListener('mousedown', e => {
      if (!editMode) return;
      e.preventDefault();
      startDragBox(e, id);
    });
    dragHandle.addEventListener('touchstart', e => {
      if (!editMode) return;
      e.preventDefault();
      startDragBox(e, id);
    });

    // Shift+click select/deselect boxes on header area
    header.addEventListener('click', e => {
      if (!editMode) return;
      if (!e.shiftKey) return;
      e.preventDefault();
      toggleSelectBox(id);
    });

    // Resize
    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
      const handle = box.querySelector(`.resize-handle.${corner}`);
      handle.addEventListener('mousedown', e => {
        if (!editMode) return;
        e.preventDefault();
        startResizeBox(e, id, corner);
      });
      handle.addEventListener('touchstart', e => {
        if (!editMode) return;
        e.preventDefault();
        startResizeBox(e, id, corner);
      });
    });

    // Content editable focus/click: stop propagation so drag doesn't interfere
    contentDiv.addEventListener('mousedown', e => e.stopPropagation());
    contentDiv.addEventListener('touchstart', e => e.stopPropagation());

    if (save) saveCurrentMapDebounced();

    return box;
  }

  function removeBox(id) {
    const box = boxesMap.get(id);
    if (!box) return;
    box.remove();
    boxesMap.delete(id);
    // Remove connections linked to this box
    for (let i = connections.length -1; i >= 0; i--) {
      if (connections[i].fromId === id || connections[i].toId === id) {
        connections.splice(i,1);
      }
    }
    drawConnections();
  }

  function getBoxData(box) {
    const contentDiv = box.querySelector('.box-content');
    return {
      id: box.dataset.id,
      x: parseFloat(box.style.left),
      y: parseFloat(box.style.top),
      width: box.offsetWidth,
      height: box.offsetHeight,
      text: contentDiv.textContent,
      fontSize: window.getComputedStyle(contentDiv).fontSize
    };
  }

  function generateId() {
    return 'box-' + Math.random().toString(36).slice(2, 10);
  }

  // Dragging boxes

  let dragInfo = null;

  function startDragBox(e, boxId) {
    if (!editMode) return;
    e.preventDefault();
    const box = boxesMap.get(boxId);
    if (!box) return;

    // Select box if not selected already
    if (!selectedBoxes.has(boxId)) {
      clearSelection();
      addSelection(boxId);
    }

    const clientPos = getClientCoords(e);
    dragInfo = {
      startX: clientPos.x,
      startY: clientPos.y,
      boxesStartPositions: Array.from(selectedBoxes).map(id => {
        const b = boxesMap.get(id);
        return { id, x: parseFloat(b.style.left), y: parseFloat(b.style.top) };
      })
    };

    window.addEventListener('mousemove', dragBoxesMove);
    window.addEventListener('touchmove', dragBoxesMove, { passive: false });
    window.addEventListener('mouseup', dragBoxesEnd);
    window.addEventListener('touchend', dragBoxesEnd);
  }

  function dragBoxesMove(e) {
    e.preventDefault();
    if (!dragInfo) return;
    const clientPos = getClientCoords(e);
    const dx = (clientPos.x - dragInfo.startX) / scale;
    const dy = (clientPos.y - dragInfo.startY) / scale;
    dragInfo.boxesStartPositions.forEach(({ id, x, y }) => {
      const box = boxesMap.get(id);
      if (!box) return;
      box.style.left = (x + dx) + 'px';
      box.style.top = (y + dy) + 'px';
    });
    drawConnections();
  }

  function dragBoxesEnd(e) {
    if (!dragInfo) return;
    saveCurrentMapDebounced();
    dragInfo = null;
    window.removeEventListener('mousemove', dragBoxesMove);
    window.removeEventListener('touchmove', dragBoxesMove);
    window.removeEventListener('mouseup', dragBoxesEnd);
    window.removeEventListener('touchend', dragBoxesEnd);
  }

  // Resize box

  let resizeInfo = null;

  function startResizeBox(e, boxId, corner) {
    if (!editMode) return;
    e.preventDefault();
    const box = boxesMap.get(boxId);
    if (!box) return;

    const clientPos = getClientCoords(e);
    resizeInfo = {
      boxId,
      corner,
      startX: clientPos.x,
      startY: clientPos.y,
      startWidth: box.offsetWidth,
      startHeight: box.offsetHeight,
      startLeft: parseFloat(box.style.left),
      startTop: parseFloat(box.style.top),
    };

    window.addEventListener('mousemove', resizeMove);
    window.addEventListener('touchmove', resizeMove, { passive: false });
    window.addEventListener('mouseup', resizeEnd);
    window.addEventListener('touchend', resizeEnd);
  }

  function resizeMove(e) {
    if (!resizeInfo) return;
    e.preventDefault();
    const clientPos = getClientCoords(e);
    const dx = (clientPos.x - resizeInfo.startX) / scale;
    const dy = (clientPos.y - resizeInfo.startY) / scale;
    const box = boxesMap.get(resizeInfo.boxId);
    if (!box) return;

    let newWidth = resizeInfo.startWidth;
    let newHeight = resizeInfo.startHeight;
    let newLeft = resizeInfo.startLeft;
    let newTop = resizeInfo.startTop;

    const minWidth = 50;
    const minHeight = 30;

    switch(resizeInfo.corner) {
      case 'nw':
        newWidth = resizeInfo.startWidth - dx;
        newHeight = resizeInfo.startHeight - dy;
        newLeft = resizeInfo.startLeft + dx;
        newTop = resizeInfo.startTop + dy;
        break;
      case 'ne':
        newWidth = resizeInfo.startWidth + dx;
        newHeight = resizeInfo.startHeight - dy;
        newTop = resizeInfo.startTop + dy;
        break;
      case 'sw':
        newWidth = resizeInfo.startWidth - dx;
        newHeight = resizeInfo.startHeight + dy;
        newLeft = resizeInfo.startLeft + dx;
        break;
      case 'se':
        newWidth = resizeInfo.startWidth + dx;
        newHeight = resizeInfo.startHeight + dy;
        break;
    }

    if (newWidth < minWidth) {
      newWidth = minWidth;
      if (resizeInfo.corner === 'nw' || resizeInfo.corner === 'sw') {
        newLeft = resizeInfo.startLeft + (resizeInfo.startWidth - minWidth);
      }
    }
    if (newHeight < minHeight) {
      newHeight = minHeight;
      if (resizeInfo.corner === 'nw' || resizeInfo.corner === 'ne') {
        newTop = resizeInfo.startTop + (resizeInfo.startHeight - minHeight);
      }
    }

    box.style.width = newWidth + 'px';
    box.style.height = newHeight + 'px';
    box.style.left = newLeft + 'px';
    box.style.top = newTop + 'px';

    drawConnections();
  }

  function resizeEnd(e) {
    if (!resizeInfo) return;
    saveCurrentMapDebounced();
    resizeInfo = null;
    window.removeEventListener('mousemove', resizeMove);
    window.removeEventListener('touchmove', resizeMove);
    window.removeEventListener('mouseup', resizeEnd);
    window.removeEventListener('touchend', resizeEnd);
  }

  // Selection multi-select

  function toggleSelectBox(id) {
    if (selectedBoxes.has(id)) {
      selectedBoxes.delete(id);
      boxesMap.get(id)?.classList.remove('selected');
    } else {
      selectedBoxes.add(id);
      boxesMap.get(id)?.classList.add('selected');
    }
  }

  function clearSelection() {
    selectedBoxes.forEach(id => boxesMap.get(id)?.classList.remove('selected'));
    selectedBoxes.clear();
  }

  function addSelection(id) {
    selectedBoxes.add(id);
    boxesMap.get(id)?.classList.add('selected');
  }

  // Undo delete box

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const lastAction = undoStack.pop();
    if (lastAction.action === 'deleteBox') {
      const data = lastAction.boxData;
      const box = addBox(data.x, data.y, data.text, data.id, data.width, data.height, false, data.fontSize);
      lastAction.connections.forEach(c => {
        connections.push({ fromId: c.fromId, toId: c.toId });
      });
      drawConnections();
      saveCurrentMapDebounced();
    }
    if (undoStack.length === 0) undoBtn.disabled = true;
  });

  // Zoom & Pan handling

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const oldScale = scale;
    scale *= e.deltaY < 0 ? 1.1 : 0.9;
    scale = Math.min(Math.max(scale, 0.1), 3);

    // Zoom to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX -= (mx / oldScale - mx / scale);
    panY -= (my / oldScale - my / scale);

    updateTransform();
  }, { passive: false });

  viewport.addEventListener('mousedown', e => {
    if (e.target.closest('.box-header') || e.target.closest('.resize-handle') || e.target.closest('.box-content')) return;
    isPanning = true;
    startX = e.clientX - panX;
    startY = e.clientY - panY;
    viewport.style.cursor = 'grabbing';
  });

  viewport.addEventListener('touchstart', e => {
    if (e.target.closest('.box-header') || e.target.closest('.resize-handle') || e.target.closest('.box-content')) return;
    if (e.touches.length === 1) {
      isPanning = true;
      startX = e.touches[0].clientX - panX;
      startY = e.touches[0].clientY - panY;
      viewport.style.cursor = 'grabbing';
    }
  });

  window.addEventListener('mouseup', () => {
    if (isPanning) {
      isPanning = false;
      viewport.style.cursor = 'grab';
    }
  });
  window.addEventListener('touchend', () => {
    if (isPanning) {
      isPanning = false;
      viewport.style.cursor = 'grab';
    }
  });

  window.addEventListener('mousemove', e => {
    if (!isPanning) return;
    e.preventDefault();
    panX = e.clientX - startX;
    panY = e.clientY - startY;
    updateTransform();
  });

  window.addEventListener('touchmove', e => {
    if (!isPanning) return;
    e.preventDefault();
    panX = e.touches[0].clientX - startX;
    panY = e.touches[0].clientY - startY;
    updateTransform();
  }, { passive: false });

  // Double click to create new box

  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target !== viewport && !viewport.contains(e.target)) return;
    // Calculate canvas coordinates
    const rect = viewport.getBoundingClientRect();
    const cx = (e.clientX - rect.left - panX) / scale;
    const cy = (e.clientY - rect.top - panY) / scale;
    addBox(cx, cy, 'New Box');
  });

  // Edit mode toggle

  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'Toggle View Mode';
    boxesMap.forEach(box => {
      box.querySelector('.box-content').contentEditable = editMode ? 'true' : 'false';
      // Show or hide interactive controls
      box.querySelector('.delete-btn').style.display = editMode ? 'inline' : 'none';
      box.querySelector('.connect-toggle').style.display = editMode ? 'inline-block' : 'none';
      box.querySelectorAll('.resize-handle').forEach(rh => rh.style.display = editMode ? 'block' : 'none');
      box.querySelectorAll('.font-size-btn').forEach(btn => btn.style.display = editMode ? 'inline-block' : 'none');
      box.querySelector('.drag-handle').style.display = editMode ? 'flex' : 'none';
    });
  });

  // Go to center button

  goCenterBtn.addEventListener('click', () => {
    panX = -centerPos.x * scale + viewport.clientWidth / 2;
    panY = -centerPos.y * scale + viewport.clientHeight / 2;
    updateTransform();
  });

  // Mark center button

  let centerPos = { x: 0, y: 0 };
  markCenterBtn.addEventListener('click', () => {
    // Center point is canvas coordinate under viewport center
    const cx = (viewport.clientWidth / 2 - panX) / scale;
    const cy = (viewport.clientHeight / 2 - panY) / scale;
    centerPos.x = cx;
    centerPos.y = cy;
    alert(`Center marked at (${cx.toFixed(2)}, ${cy.toFixed(2)})`);
  });

  // How to use modal

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Save/load maps from Firebase

  async function fetchMapList() {
    try {
      const mapsCol = collection(db, 'mindmaps');
      const mapsSnap = await getDocs(mapsCol);
      const maps = [];
      mapsSnap.forEach(docSnap => {
        maps.push({ id: docSnap.id, name: docSnap.data().name || docSnap.id });
      });
      return maps;
    } catch (err) {
      console.error('Failed to fetch map list:', err);
      return [];
    }
  }

  async function loadMap(id) {
    if (!id) return;
    try {
      const docRef = doc(db, 'mindmaps', id);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists()) {
        alert(`Map with ID ${id} not found.`);
        return;
      }
      const data = docSnap.data();
      clearCanvas();
      if (Array.isArray(data.boxes)) {
        data.boxes.forEach(b => {
          addBox(b.x, b.y, b.text, b.id, b.width, b.height, false, b.fontSize);
        });
      }
      connections.length = 0;
      if (Array.isArray(data.connections)) {
        data.connections.forEach(c => connections.push(c));
      }
      currentMapId = id;
      currentMapName = data.name || id;
      mapNameInput.value = currentMapName;
      updateTransform();
      drawConnections();
      savedConfirmation.style.opacity = 0;
    } catch (err) {
      console.error('Failed to load map:', err);
      alert('Failed to load map: ' + err.message);
    }
  }

  async function saveMap() {
    if (!currentMapId) {
      // New map ID from mapNameInput
      let name = mapNameInput.value.trim();
      if (!name) {
        alert('Please enter a map name to save.');
        return;
      }
      // Firebase doc id safe format:
      name = name.replace(/\s+/g, '_').toLowerCase();
      currentMapId = name;
      currentMapName = mapNameInput.value.trim();
      addMapToSelect(currentMapId, currentMapName);
      mapSelect.value = currentMapId;
    } else {
      currentMapName = mapNameInput.value.trim() || currentMapId;
    }

    const boxesData = serializeBoxes();
    const docRef = doc(db, 'mindmaps', currentMapId);
    try {
      await setDoc(docRef, {
        name: currentMapName,
        boxes: boxesData,
        connections: connections,
        updated: Date.now()
      });
      showSavedConfirmation();
      await refreshMapList(); // in case name changed
    } catch (err) {
      console.error('Save failed:', err);
      alert('Save failed: ' + err.message);
    }
  }

  // Debounce save to prevent flooding
  let saveTimeout = null;
  function saveCurrentMapDebounced() {
    if (!currentMapId) return;
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
      saveMap();
    }, 800);
  }

  // Map select handling

  function addMapToSelect(id, name) {
    let option = [...mapSelect.options].find(opt => opt.value === id);
    if (!option) {
      option = document.createElement('option');
      option.value = id;
      mapSelect.appendChild(option);
    }
    option.textContent = name;
  }

  async function refreshMapList() {
    const maps = await fetchMapList();
    mapSelect.innerHTML = '';
    maps.forEach(m => addMapToSelect(m.id, m.name));
    // Always have "landing map" option first if missing
    if (!maps.find(m => m.id === 'landing_map')) {
      addMapToSelect('landing_map', 'Landing Map');
    }
    if (!currentMapId) {
      mapSelect.value = 'landing_map';
    } else {
      mapSelect.value = currentMapId;
    }
  }

  mapSelect.addEventListener('change', async () => {
    const val = mapSelect.value;
    if (!val) return;
    await loadMap(val);
  });

  saveMapBtn.addEventListener('click', () => {
    saveMap();
  });

  function showSavedConfirmation() {
    savedConfirmation.style.opacity = 1;
    clearTimeout(savedConfirmation._timeout);
    savedConfirmation._timeout = setTimeout(() => {
      savedConfirmation.style.opacity = 0;
    }, 1500);
  }

  // Initialize: load landing map or first map available

  async function init() {
    await refreshMapList();
    if (mapSelect.options.length === 0) {
      addMapToSelect('landing_map', 'Landing Map');
      mapSelect.value = 'landing_map';
    }
    await loadMap(mapSelect.value);

    // Set initial edit mode state for existing boxes
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'Toggle View Mode';

    // Show controls for existing boxes per editMode
    boxesMap.forEach(box => {
      box.querySelector('.box-content').contentEditable = editMode ? 'true' : 'false';
      box.querySelector('.delete-btn').style.display = editMode ? 'inline' : 'none';
      box.querySelector('.connect-toggle').style.display = editMode ? 'inline-block' : 'none';
      box.querySelectorAll('.resize-handle').forEach(rh => rh.style.display = editMode ? 'block' : 'none');
      box.querySelectorAll('.font-size-btn').forEach(btn => btn.style.display = editMode ? 'inline-block' : 'none');
      box.querySelector('.drag-handle').style.display = editMode ? 'flex' : 'none';
    });

    updateTransform();
  }

  // Initialize viewport cursor
  viewport.style.cursor = 'grab';

  // Start app
  init();

</script>
</body>
</html>
