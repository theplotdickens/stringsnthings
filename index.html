<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      font-family: sans-serif;
      user-select: none;
      background: #f0f0f0;
    }
    #viewport {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }
    #canvas {
      position: absolute;
      transform-origin: 0 0;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 10px;
      min-width: 100px;
      min-height: 60px;
      resize: both;
      overflow: auto;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .boxHeader {
      display: flex;
      justify-content: flex-end;
      font-size: 10px;
      margin-bottom: 5px;
      gap: 4px;
    }
    .boxHeader button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 10px;
      padding: 0 2px;
    }
    svg {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    #buttonContainer {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 10;
    }
    .floatingBtn {
      margin: 4px;
      padding: 4px 8px;
      font-size: 12px;
    }
    #zoomDisplay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: black;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>
  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
  </div>
  <div id="zoomDisplay">Zoom: 100%</div>
  <script>
    let panX = 0;
    let panY = 0;
    let scale = 1;
    let boxes = [];
    let connections = [];
    let deleted = [];
    let markedPan = { x: 0, y: 0 };

    const viewport = document.getElementById("viewport");
    const canvas = document.getElementById("canvas");
    const connectionLayer = document.getElementById("connectionLayer");
    const zoomDisplay = document.getElementById("zoomDisplay");

    function updateTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      connectionLayer.style.transform = canvas.style.transform;
      zoomDisplay.textContent = `Zoom: ${Math.round(scale * 100)}%`;
      drawConnections();
    }

    function drawConnections() {
      connectionLayer.innerHTML = "";
      connections.forEach(({ from, to }) => {
        const fromBox = document.getElementById(from);
        const toBox = document.getElementById(to);
        if (!fromBox || !toBox) return;
        const x1 = fromBox.offsetLeft + fromBox.offsetWidth / 2;
        const y1 = fromBox.offsetTop + fromBox.offsetHeight / 2;
        const x2 = toBox.offsetLeft + toBox.offsetWidth / 2;
        const y2 = toBox.offsetTop + toBox.offsetHeight / 2;
        const dx = Math.abs(x2 - x1) / 2;
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", `M${x1},${y1} C${x1+dx},${y1} ${x2-dx},${y2} ${x2},${y2}`);
        path.setAttribute("stroke", "black");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-width", "2");
        connectionLayer.appendChild(path);
      });
    }
        let isPanning = false;
    let startX, startY;

    viewport.addEventListener("pointerdown", (e) => {
      if (e.target.closest(".box") || e.target.closest("button")) return;
      isPanning = true;
      startX = e.clientX;
      startY = e.clientY;
      viewport.setPointerCapture(e.pointerId);
    });

    viewport.addEventListener("pointermove", (e) => {
      if (!isPanning) return;
      panX += e.clientX - startX;
      panY += e.clientY - startY;
      startX = e.clientX;
      startY = e.clientY;
      updateTransform();
    });

    viewport.addEventListener("pointerup", (e) => {
      isPanning = false;
      viewport.releasePointerCapture(e.pointerId);
    });

    viewport.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      let newScale = scale * (e.deltaY < 0 ? zoomFactor : 1 / zoomFactor);
      newScale = Math.min(Math.max(newScale, 0.5), 3);
      scale = newScale;
      updateTransform();
    });

    function addBox(x = 100, y = 100, id = null, text = "New box") {
      const box = document.createElement("div");
      box.className = "box";
      box.id = id || `box-${Date.now()}`;
      box.style.left = x + "px";
      box.style.top = y + "px";
      box.contentEditable = true;
      box.textContent = text;
      box.spellcheck = false;

      const header = document.createElement("div");
      header.className = "boxHeader";

      const delBtn = document.createElement("button");
      delBtn.textContent = "Ã—";
      delBtn.title = "Delete box";
      delBtn.onclick = (e) => {
        e.stopPropagation();
        deleteBox(box.id);
      };

      header.appendChild(delBtn);
      box.prepend(header);
      canvas.appendChild(box);

      box.addEventListener("pointerdown", (e) => {
        if (e.target === delBtn) return;
        box.setPointerCapture(e.pointerId);
        box.isDragging = true;
        box.dragStartX = e.clientX - box.offsetLeft;
        box.dragStartY = e.clientY - box.offsetTop;
      });

      box.addEventListener("pointermove", (e) => {
        if (!box.isDragging) return;
        let newX = e.clientX - box.dragStartX;
        let newY = e.clientY - box.dragStartY;
        box.style.left = newX + "px";
        box.style.top = newY + "px";
        drawConnections();
      });

      box.addEventListener("pointerup", (e) => {
        box.isDragging = false;
        box.releasePointerCapture(e.pointerId);
      });

      boxes.push(box.id);
      updateTransform();
      return box;
    }

    function deleteBox(id) {
      const box = document.getElementById(id);
      if (!box) return;
      deleted.push({ id, text: box.textContent, left: box.style.left, top: box.style.top });
      box.remove();
      boxes = boxes.filter((bid) => bid !== id);
      connections = connections.filter((c) => c.from !== id && c.to !== id);
      drawConnections();
      undoBtn.disabled = false;
    }

    undoBtn.onclick = () => {
      if (deleted.length === 0) return;
      const last = deleted.pop();
      addBox(parseInt(last.left), parseInt(last.top), last.id, last.text);
      undoBtn.disabled = deleted.length === 0;
    };

    markCenterBtn.onclick = () => {
      markedPan.x = panX;
      markedPan.y = panY;
    };

    goCenterBtn.onclick = () => {
      panX = markedPan.x;
      panY = markedPan.y;
      updateTransform();
    };

    // Initialize center
    markedPan.x = 0;
    markedPan.y = 0;

    // Add example boxes and connection for testing
    const boxA = addBox(100, 100, "boxA", "Box A");
    const boxB = addBox(300, 200, "boxB", "Box B");
    connections.push({ from: "boxA", to: "boxB" });
    drawConnections();

    updateTransform();
  </script>
</body>
</html>
