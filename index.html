<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    dragHandle.title = 'Drag box';
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectBtn = document.createElement('button');
    connectBtn.className = 'connect-toggle';
    connectBtn.title = 'Connect box';
    header.appendChild(connectBtn);

    // Font size controls
    const fontDecBtn = document.createElement('button');
    fontDecBtn.textContent = '−';
    fontDecBtn.className = 'font-size-btn';
    fontDecBtn.title = 'Decrease font size';

    const fontIncBtn = document.createElement('button');
    fontIncBtn.textContent = '+';
    fontIncBtn.className = 'font-size-btn';
    fontIncBtn.title = 'Increase font size';

    header.appendChild(fontDecBtn);
    header.appendChild(fontIncBtn);

    // Delete button
    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.title = 'Delete box';
    delBtn.textContent = '×';
    header.appendChild(delBtn);

    box.appendChild(header);

    // Content (editable div)
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.spellcheck = false;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw','ne','sw','se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle ' + pos;
      box.appendChild(handle);
    });

    // Add to DOM
    canvas.appendChild(box);
    boxesMap.set(id, { element: box, header, dragHandle, connectBtn, delBtn, content, fontDecBtn, fontIncBtn, fontSize });

    // Event listeners
    setupBoxListeners(id);

    updateBoxFontSize(id);
  }

  function setupBoxListeners(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    const { element, header, dragHandle, connectBtn, delBtn, content, fontDecBtn, fontIncBtn } = boxData;

    // Prevent dragging when editing text
    content.addEventListener('mousedown', e => {
      e.stopPropagation();
    });
    content.addEventListener('touchstart', e => {
      e.stopPropagation();
    });

    // Dragging boxes

    let dragActive = false;
    let dragStartX, dragStartY, origX, origY;

    function dragStart(e) {
      if (!editMode) return;
      e.preventDefault();
      dragActive = true;
      const rect = element.getBoundingClientRect();
      dragStartX = e.clientX || e.touches[0].clientX;
      dragStartY = e.clientY || e.touches[0].clientY;
      origX = parseFloat(element.style.left);
      origY = parseFloat(element.style.top);
      document.addEventListener('mousemove', dragging);
      document.addEventListener('touchmove', dragging, { passive: false });
      document.addEventListener('mouseup', dragEnd);
      document.addEventListener('touchend', dragEnd);
    }

    function dragging(e) {
      if (!dragActive) return;
      e.preventDefault();
      const clientX = e.clientX || e.touches[0].clientX;
      const clientY = e.clientY || e.touches[0].clientY;
      const dx = (clientX - dragStartX) / scale;
      const dy = (clientY - dragStartY) / scale;

      // Move selected boxes together or single box
      if (selectedBoxes.has(element)) {
        // Multi drag
        selectedBoxes.forEach(b => {
          const id = b.dataset.id;
          const boxD = boxesMap.get(id);
          const ox = parseFloat(boxD.element.style.left);
          const oy = parseFloat(boxD.element.style.top);
          boxD.element.style.left = (ox + dx) + 'px';
          boxD.element.style.top = (oy + dy) + 'px';
        });
      } else {
        element.style.left = (origX + dx) + 'px';
        element.style.top = (origY + dy) + 'px';
      }
      drawConnections();
    }

    function dragEnd(e) {
      if (!dragActive) return;
      e.preventDefault();
      dragActive = false;
      document.removeEventListener('mousemove', dragging);
      document.removeEventListener('touchmove', dragging);
      document.removeEventListener('mouseup', dragEnd);
      document.removeEventListener('touchend', dragEnd);
      // Save new positions to undo stack for all moved boxes
      if (selectedBoxes.has(element)) {
        const movedBoxes = [];
        selectedBoxes.forEach(b => {
          const id = b.dataset.id;
          const boxD = boxesMap.get(id);
          movedBoxes.push({id: id, left: parseFloat(boxD.element.style.left), top: parseFloat(boxD.element.style.top)});
        });
        pushUndo({type:'move-multi', boxes: movedBoxes});
      } else {
        pushUndo({type:'move', id: id, left: parseFloat(element.style.left), top: parseFloat(element.style.top)});
      }
    }

    dragHandle.addEventListener('mousedown', dragStart);
    dragHandle.addEventListener('touchstart', dragStart, { passive: false });

    // Header shift+click multi-select
    header.addEventListener('click', e => {
      if (!e.shiftKey) return;
      e.preventDefault();
      if (selectedBoxes.has(element)) {
        element.classList.remove('selected');
        selectedBoxes.delete(element);
      } else {
        selectedBoxes.add(element);
        element.classList.add('selected');
      }
    });

    // Delete box
    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      deleteBox(id);
    });

    // Content editable toggle
    content.contentEditable = editMode;

    // On content input save to undo stack
    content.addEventListener('input', e => {
      if (!editMode) return;
      pushUndo({type: 'edit', id: id, text: content.textContent});
    });

    // Connect toggle
    connectBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        connectionStartBoxId = null;
        connectBtn.classList.remove('active');
      } else if (connectionStartBoxId) {
        if (connectionStartBoxId !== id) {
          // Add connection from connectionStartBoxId to id
          connections.push({from: connectionStartBoxId, to: id, label: ''});
          connectionStartBoxId = null;
          updateConnectButtons();
          drawConnections();
          pushUndo({type:'connect', from: connectionStartBoxId, to: id});
        }
      } else {
        connectionStartBoxId = id;
        updateConnectButtons();
      }
    });

    // Font size controls
    fontDecBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (boxData.fontSize > 6) {
        boxData.fontSize--;
        updateBoxFontSize(id);
        pushUndo({type:'font-size', id: id, fontSize: boxData.fontSize});
      }
    });
    fontIncBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (boxData.fontSize < 48) {
        boxData.fontSize++;
        updateBoxFontSize(id);
        pushUndo({type:'font-size', id: id, fontSize: boxData.fontSize});
      }
    });

    // Resize handling
    const resizeHandles = element.querySelectorAll('.resize-handle');
    resizeHandles.forEach(handle => {
      let resizing = false;
      let startXr, startYr, startW, startH, startLeft, startTop;

      function onResizeStart(ev) {
        if (!editMode) return;
        ev.preventDefault();
        resizing = true;
        startXr = ev.clientX || ev.touches[0].clientX;
        startYr = ev.clientY || ev.touches[0].clientY;
        startW = element.offsetWidth;
        startH = element.offsetHeight;
        startLeft = parseFloat(element.style.left);
        startTop = parseFloat(element.style.top);
        document.addEventListener('mousemove', onResize);
        document.addEventListener('touchmove', onResize, { passive: false });
        document.addEventListener('mouseup', onResizeEnd);
        document.addEventListener('touchend', onResizeEnd);
      }

      function onResize(e) {
        if (!resizing) return;
        e.preventDefault();
        const cx = e.clientX || e.touches[0].clientX;
        const cy = e.clientY || e.touches[0].clientY;
        const dx = (cx - startXr) / scale;
        const dy = (cy - startYr) / scale;

        if (handle.classList.contains('se')) {
          element.style.width = Math.max(40, startW + dx) + 'px';
          element.style.height = Math.max(30, startH + dy) + 'px';
        } else if (handle.classList.contains('sw')) {
          element.style.width = Math.max(40, startW - dx) + 'px';
          element.style.height = Math.max(30, startH + dy) + 'px';
          element.style.left = (startLeft + dx) + 'px';
        } else if (handle.classList.contains('ne')) {
          element.style.width = Math.max(40, startW + dx) + 'px';
          element.style.height = Math.max(30, startH - dy) + 'px';
          element.style.top = (startTop + dy) + 'px';
        } else if (handle.classList.contains('nw')) {
          element.style.width = Math.max(40, startW - dx) + 'px';
          element.style.height = Math.max(30, startH - dy) + 'px';
          element.style.left = (startLeft + dx) + 'px';
          element.style.top = (startTop + dy) + 'px';
        }
        drawConnections();
      }

      function onResizeEnd(e) {
        if (!resizing) return;
        e.preventDefault();
        resizing = false;
        document.removeEventListener('mousemove', onResize);
        document.removeEventListener('touchmove', onResize);
        document.removeEventListener('mouseup', onResizeEnd);
        document.removeEventListener('touchend', onResizeEnd);
        // Save resize to undo
        pushUndo({
          type: 'resize',
          id: id,
          width: element.offsetWidth,
          height: element.offsetHeight,
          left: parseFloat(element.style.left),
          top: parseFloat(element.style.top)
        });
      }

      handle.addEventListener('mousedown', onResizeStart);
      handle.addEventListener('touchstart', onResizeStart, { passive: false });
    });
  }

  function updateBoxFontSize(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    boxData.content.style.fontSize = boxData.fontSize + 'px';
  }

  function deleteBox(id) {
    const boxData = boxesMap.get(id);
    if (!boxData) return;
    const boxElement = boxData.element;

    // Save undo info with full box data including connections
    const boxUndoData = {
      id: id,
      x: parseFloat(boxElement.style.left),
      y: parseFloat(boxElement.style.top),
      w: boxElement.offsetWidth,
      h: boxElement.offsetHeight,
      text: boxData.content.textContent,
      fontSize: boxData.fontSize,
      connectionsFrom: connections.filter(c => c.from === id),
      connectionsTo: connections.filter(c => c.to === id)
    };

    // Remove connections related to this box
    for (let i = connections.length - 1; i >= 0; i--) {
      if (connections[i].from === id || connections[i].to === id) {
        connections.splice(i, 1);
      }
    }

    canvas.removeChild(boxElement);
    boxesMap.delete(id);
    selectedBoxes.delete(boxElement);

    pushUndo({ type: 'delete', box: boxUndoData });

    updateConnectButtons();
    drawConnections();
    updateUndoBtn();
  }

  // Undo system
  function pushUndo(action) {
    undoStack.push(action);
    updateUndoBtn();
  }

  function undo() {
    if (undoStack.length === 0) return;
    const action = undoStack.pop();

    switch (action.type) {
      case 'delete':
        // Restore box and its connections
        const b = action.box;
        createBox(b.id, b.x, b.y, b.w, b.h, b.text, b.fontSize);
        b.connectionsFrom.forEach(c => connections.push(c));
        b.connectionsTo.forEach(c => connections.push(c));
        drawConnections();
        break;
      case 'move':
        {
          const boxData = boxesMap.get(action.id);
          if (boxData) {
            boxData.element.style.left = action.left + 'px';
            boxData.element.style.top = action.top + 'px';
            drawConnections();
          }
        }
        break;
      case 'move-multi':
        action.boxes.forEach(bx => {
          const boxData = boxesMap.get(bx.id);
          if (boxData) {
            boxData.element.style.left = bx.left + 'px';
            boxData.element.style.top = bx.top + 'px';
          }
        });
        drawConnections();
        break;
      case 'edit':
        {
          const boxData = boxesMap.get(action.id);
          if (boxData) {
            boxData.content.textContent = action.text;
          }
        }
        break;
      case 'connect':
        {
          for (let i = connections.length - 1; i >= 0; i--) {
            if (connections[i].from === action.from && connections[i].to === action.to) {
              connections.splice(i, 1);
            }
          }
          drawConnections();
        }
        break;
      case 'font-size':
        {
          const boxData = boxesMap.get(action.id);
          if (boxData) {
            boxData.fontSize = action.fontSize;
            updateBoxFontSize(action.id);
          }
        }
        break;
      case 'resize':
        {
          const boxData = boxesMap.get(action.id);
          if (boxData) {
            boxData.element.style.width = action.width + 'px';
            boxData.element.style.height = action.height + 'px';
            boxData.element.style.left = action.left + 'px';
            boxData.element.style.top = action.top + 'px';
            drawConnections();
          }
        }
        break;
    }

    updateUndoBtn();
  }

  function updateUndoBtn() {
    undoBtn.disabled = undoStack.length === 0;
  }

  undoBtn.addEventListener('click', () => {
    undo();
  });

  // Drawing connections with SVG paths

  function drawConnections() {
    // Clear SVG
    while (connectionLayer.firstChild) {
      connectionLayer.removeChild(connectionLayer.firstChild);
    }

    connections.forEach(conn => {
      const fromBox = boxesMap.get(conn.from);
      const toBox = boxesMap.get(conn.to);
      if (!fromBox || !toBox) return;

      const fromRect = fromBox.element.getBoundingClientRect();
      const toRect = toBox.element.getBoundingClientRect();
      const vpRect = viewport.getBoundingClientRect();

      // Calculate positions relative to viewport and scale
      // We want centers of from and to boxes in canvas coordinates
      const fromX = parseFloat(fromBox.element.style.left) + fromBox.element.offsetWidth / 2;
      const fromY = parseFloat(fromBox.element.style.top) + fromBox.element.offsetHeight / 2;
      const toX = parseFloat(toBox.element.style.left) + toBox.element.offsetWidth / 2;
      const toY = parseFloat(toBox.element.style.top) + toBox.element.offsetHeight / 2;

      const startX = fromX * scale + panX;
      const startY = fromY * scale + panY;
      const endX = toX * scale + panX;
      const endY = toY * scale + panY;

      // Create a smooth cubic bezier curve
      const dx = endX - startX;
      const dy = endY - startY;
      const controlPointDist = Math.min(100, Math.sqrt(dx*dx + dy*dy)/2);

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const d = `M${startX},${startY} C${startX + controlPointDist},${startY} ${endX - controlPointDist},${endY} ${endX},${endY}`;
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      connectionLayer.appendChild(path);

      // Label if any (currently unused)
      if (conn.label) {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.textContent = conn.label;
        text.setAttribute('x', (startX + endX) / 2);
        text.setAttribute('y', (startY + endY) / 2);
        text.setAttribute('font-size', '12');
        text.setAttribute('fill', 'black');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'middle');
        connectionLayer.appendChild(text);
      }
    });
  }

  function updateConnectButtons() {
    boxesMap.forEach(boxData => {
      if (connectionStartBoxId === boxData.element.dataset.id) {
        boxData.connectBtn.classList.add('active');
      } else {
        boxData.connectBtn.classList.remove('active');
      }
    });
  }

  // Create new box on double click on canvas
  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target !== viewport && e.target !== canvas) return;

    const rect = viewport.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale;
    const y = (e.clientY - rect.top - panY) / scale;

    const newId = generateId();
    createBox(newId, x - 60, y - 30);
    pushUndo({type:'create', id: newId});
  });

  // Keyboard shortcuts: Delete selected boxes on Delete key
  document.addEventListener('keydown', e => {
    if (e.key === 'Delete' && editMode) {
      if (selectedBoxes.size > 0) {
        selectedBoxes.forEach(boxElement => {
          const id = boxElement.dataset.id;
          deleteBox(id);
        });
        selectedBoxes.clear();
      }
    }
  });

  // Go to Center and Mark Center buttons
  function getViewportCenter() {
    const vp = viewport.getBoundingClientRect();
    return {
      x: (vp.width / 2 - panX) / scale,
      y: (vp.height / 2 - panY) / scale
    };
  }

  let markedCenter = null;

  goCenterBtn.addEventListener('click', () => {
    if (!markedCenter) return;
    const vp = viewport.getBoundingClientRect();
    panX = vp.width / 2 - markedCenter.x * scale;
    panY = vp.height / 2 - markedCenter.y * scale;
    updateTransform();
  });

  markCenterBtn.addEventListener('click', () => {
    markedCenter = getViewportCenter();
  });

  // Toggle edit mode
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    boxesMap.forEach(boxData => {
      boxData.content.contentEditable = editMode;
      boxData.connectBtn.disabled = !editMode;
      boxData.delBtn.disabled = !editMode;
      boxData.fontDecBtn.disabled = !editMode;
      boxData.fontIncBtn.disabled = !editMode;
      // Show/hide resize handles
      boxData.element.querySelectorAll('.resize-handle').forEach(handle => {
        handle.style.display = editMode ? 'block' : 'none';
      });
    });
  });

  // How to use modal
  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // Local persistence helpers for faster saves before Firebase
  function getMapData() {
    if (!currentMapId) return null;
    const data = {
      boxes: [],
      connections: connections.slice(),
      center: markedCenter,
    };
    boxesMap.forEach((boxData, id) => {
      const el = boxData.element;
      data.boxes.push({
        id: id,
        x: parseFloat(el.style.left),
        y: parseFloat(el.style.top),
        w: el.offsetWidth,
        h: el.offsetHeight,
        text: boxData.content.textContent,
        fontSize: boxData.fontSize
      });
    });
    return data;
  }

  // Save/load from Firebase Firestore

  async function saveMap() {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    const data = getMapData();
    if (!data) return;
    try {
      await setDoc(doc(db, 'mindmaps', currentMapId), {
        name: mapsCache.get(currentMapId).name,
        boxes: data.boxes,
        connections: data.connections,
        center: data.center || null,
        updatedAt: new Date().toISOString()
      });
      saveStatus.textContent = 'Saved at ' + new Date().toLocaleTimeString();
      // Refresh cache
      mapsCache.set(currentMapId, {name: mapsCache.get(currentMapId).name, ...data});
      updateMapSelectOptions();
    } catch (e) {
      alert('Save failed: ' + e.message);
    }
  }

  async function loadMap(mapId) {
    try {
      const docSnap = await getDoc(doc(db, 'mindmaps', mapId));
      if (!docSnap.exists()) {
        alert('Map not found in database');
        return;
      }
      clearCanvas();
      const data = docSnap.data();
      currentMapId = mapId;
      mapsCache.set(mapId, data);
      data.boxes.forEach(b => {
        createBox(b.id, b.x, b.y, b.w, b.h, b.text, b.fontSize);
      });
      connections.length = 0;
      if (Array.isArray(data.connections)) {
        data.connections.forEach(c => connections.push(c));
      }
      if (data.center) {
        markedCenter = data.center;
        panX = 0;
        panY = 0;
        scale = 1;
      } else {
        markedCenter = null;
      }
      updateTransform();
      drawConnections();
      updateMapSelectOptions();
      saveStatus.textContent = '';
    } catch (e) {
      alert('Load failed: ' + e.message);
    }
  }

  async function deleteMapFromDB(mapId) {
    if (!confirm('Delete map "' + mapsCache.get(mapId).name + '"? This cannot be undone.')) return;
    try {
      await deleteDoc(doc(db, 'mindmaps', mapId));
      mapsCache.delete(mapId);
      if (currentMapId === mapId) {
        clearCanvas();
        currentMapId = null;
      }
      updateMapSelectOptions();
      saveStatus.textContent = '';
    } catch (e) {
      alert('Delete failed: ' + e.message);
    }
  }

  async function renameMapInDB(mapId, newName) {
    try {
      await setDoc(doc(db, 'mindmaps', mapId), { name: newName }, { merge: true });
      mapsCache.get(mapId).name = newName;
      updateMapSelectOptions();
    } catch (e) {
      alert('Rename failed: ' + e.message);
    }
  }

  async function fetchAllMaps() {
    mapsCache.clear();
    const colSnap = await getDocs(collection(db, 'mindmaps'));
    colSnap.forEach(docSnap => {
      const data = docSnap.data();
      mapsCache.set(docSnap.id, data);
    });
    updateMapSelectOptions();
  }

  // UI map select
  function updateMapSelectOptions() {
    // Save current selected
    const oldId = mapSelect.value;

    // Clear options
    while (mapSelect.firstChild) mapSelect.removeChild(mapSelect.firstChild);

    // Add maps from cache sorted by name
    const entries = Array.from(mapsCache.entries());
    entries.sort((a,b) => a[1].name.localeCompare(b[1].name));
    entries.forEach(([id, data]) => {
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = data.name || id;
      mapSelect.appendChild(opt);
    });

    if (oldId && mapsCache.has(oldId)) {
      mapSelect.value = oldId;
    } else if (entries.length > 0) {
      mapSelect.value = entries[0][0];
      currentMapId = entries[0][0];
    } else {
      currentMapId = null;
    }
  }

  // Clear canvas completely
  function clearCanvas() {
    boxesMap.forEach(({element}) => {
      canvas.removeChild(element);
    });
    boxesMap.clear();
    connections.length = 0;
    selectedBoxes.clear();
    connectionStartBoxId = null;
    updateConnectButtons();
    drawConnections();
  }

  // Map select change
  mapSelect.addEventListener('change', e => {
    if (!mapSelect.value) return;
    loadMap(mapSelect.value);
  });

  // Save button
  saveMapBtn.addEventListener('click', saveMap);

  // Rename button
  renameMapBtn.addEventListener('click', () => {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    const newName = prompt('Enter new name for map:', mapsCache.get(currentMapId).name);
    if (newName && newName.trim()) {
      renameMapInDB(currentMapId, newName.trim());
    }
  });

  // Delete button
  deleteMapBtn.addEventListener('click', () => {
    if (!currentMapId) {
      alert('No map selected');
      return;
    }
    deleteMapFromDB(currentMapId);
  });

  // New map button
  newMapBtn.addEventListener('click', async () => {
    const name = prompt('Enter name for new map:');
    if (!name || !name.trim()) return;
    const id = generateId();
    mapsCache.set(id, { name: name.trim(), boxes: [], connections: [], center: null });
    updateMapSelectOptions();
    mapSelect.value = id;
    currentMapId = id;
    clearCanvas();
    saveStatus.textContent = '';
    await saveMap();
  });

  // Initial load
  await fetchAllMaps();

  // Initialize edit mode and button states
  toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode (ON)' : 'Toggle Edit Mode (OFF)';
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode (ON)' : 'Toggle Edit Mode (OFF)';
    boxesMap.forEach(boxData => {
      boxData.content.contentEditable = editMode;
      boxData.connectBtn.disabled = !editMode;
      boxData.delBtn.disabled = !editMode;
      boxData.fontDecBtn.disabled = !editMode;
      boxData.fontIncBtn.disabled = !editMode;
      boxData.element.querySelectorAll('.resize-handle').forEach(h => {
        h.style.display = editMode ? 'block' : 'none';
      });
    });
  });

  updateTransform();
  updateUndoBtn();

</script>
</body>
</html>
