<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>stringsnthingsv3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; height: 100%; overflow: hidden; font-family: monospace, monospace;
      touch-action: none;
    }
    #viewport {
      width: 100%; height: 100%; position: relative; background: #f0f0f0; cursor: grab;
      overflow: hidden;
      box-sizing: border-box;
    }
    #canvas {
      position: absolute; top: 0; left: 0; transform-origin: 0 0;
      z-index: 10;
    }
    .box {
      position: absolute;
      background: white;
      border: 1px solid black;
      min-width: 80px;
      min-height: 40px;
      user-select: none;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      cursor: text;
      overflow: hidden;
      transition: width 0.1s ease, height 0.1s ease;
    }
    .box.selected {
      outline: 2px dashed blue;
    }
    .box-header {
      background: #ddd;
      padding-left: 24px;
      min-width: 40px;
      min-height: 18px;
      height: 18px;
      box-sizing: border-box;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 4px;
      position: relative;
      user-select: none;
      cursor: default;
      border-bottom: 1px solid #bbb;
      font-size: 12px;
      flex-shrink: 0;
    }
    .drag-handle {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      cursor: move;
      user-select: none;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      white-space: nowrap;
      z-index: 5;
    }
    .delete-btn {
      color: red;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .connect-toggle {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: none;
      background-color: blue;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.25s ease;
      padding: 0;
      margin: 0;
      flex-shrink: 0;
    }
    .connect-toggle.active {
      background-color: green;
    }
    .font-size-btn {
      font-size: 14px;
      width: 18px;
      height: 18px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      background: transparent;
      border: none;
      color: black;
      padding: 0;
      margin: 0 2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .box-content {
      flex: 1;
      padding: 2px;
      white-space: pre-wrap;
      font-family: monospace, monospace;
      overflow-wrap: break-word;
      outline: none;
      cursor: text;
      user-select: text;
      line-height: 1.1;
      min-height: 24px;
      box-sizing: border-box;
      resize: none;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      word-break: break-word;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: transparent;
      position: absolute;
      z-index: 20;
      touch-action: none;
    }
    .resize-handle.nw { top: -8px; left: -8px; cursor: nwse-resize; }
    .resize-handle.ne { top: -8px; right: -8px; cursor: nesw-resize; }
    .resize-handle.sw { bottom: -8px; left: -8px; cursor: nesw-resize; }
    .resize-handle.se { bottom: -8px; right: -8px; cursor: nwse-resize; }

    #topMenu {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(240, 240, 240, 0.95);
      border: 1px solid #bbb;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: monospace;
      z-index: 10000;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      user-select: none;
    }
    #mapSelect {
      font-family: monospace;
      font-size: 14px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #888;
      cursor: pointer;
      min-width: 150px;
    }
    #saveMapBtn, #renameMapBtn, #deleteMapBtn, #newMapBtn {
      background: #555;
      color: #eee;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #saveMapBtn:hover, #renameMapBtn:hover, #deleteMapBtn:hover, #newMapBtn:hover {
      background: #333;
    }
    #saveStatus {
      font-size: 13px;
      color: green;
      min-width: 90px;
      user-select: none;
    }

    #buttonContainer {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 1000;
      user-select: none;
    }
    .floatingBtn {
      background: rgba(100, 100, 100, 0.5);
      color: #eee;
      font-family: monospace, monospace;
      font-size: 16px;
      padding: 6px 12px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
      transition: background 0.2s ease;
    }
    .floatingBtn:active {
      background: rgba(80, 80, 80, 0.7);
    }
    .floatingBtn:disabled {
      background: rgba(150, 150, 150, 0.3);
      cursor: default;
      color: #999;
      border-color: #999;
      box-shadow: none;
    }
    #zoomDisplay {
      position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.5); color: white; font-family: monospace;
      padding: 4px 8px; border-radius: 4px;
      user-select: none; pointer-events: none; z-index: 1001;
    }
    #connectionLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    #footerInfo {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace, monospace;
      font-size: 14px;
      color: #555;
      user-select: none;
      z-index: 1002;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      pointer-events: none;
      width: max-content;
      max-width: 90vw;
      text-align: center;
    }
    #howToModal {
      display:none;
      position:fixed; top:50%; left:50%;
      transform: translate(-50%, -50%);
      background:white;
      border: 2px solid black;
      padding: 20px;
      z-index: 2000;
      width: 80vw;
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
      font-family: monospace;
    }
    #howToModal h2 {
      margin-top: 0;
    }
    #howToContent {
      white-space: pre-wrap;
      user-select: text;
    }
    #closeHowToBtn {
      margin-top: 12px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="topMenu">
    <select id="mapSelect" title="Select a mind map"></select>
    <button id="saveMapBtn" title="Save current mind map">Save</button>
    <button id="renameMapBtn" title="Rename current mind map">Rename</button>
    <button id="deleteMapBtn" title="Delete current mind map">Delete</button>
    <button id="newMapBtn" title="Create new mind map">New Map</button>
    <div id="saveStatus"></div>
  </div>

  <div id="viewport">
    <svg id="connectionLayer"></svg>
    <div id="canvas"></div>
  </div>

  <div id="buttonContainer">
    <button id="undoBtn" class="floatingBtn" disabled>Undo Delete</button>
    <button id="goCenterBtn" class="floatingBtn">Go to Center</button>
    <button id="markCenterBtn" class="floatingBtn">Mark Center</button>
    <button id="toggleEditModeBtn" class="floatingBtn">Toggle Edit Mode</button>
    <button id="howToBtn" class="floatingBtn">How to Use</button>
  </div>

  <div id="howToModal">
    <h2>How to Use</h2>
    <p id="howToContent" contenteditable="false">
      Double click anywhere to create a new text box.
      Toggle edit mode on and off to make or prevent changes.
      Use the ✥ symbol in the top left corner to move boxes.
      Use the red x to delete boxes.
      Use the blue button to connect boxes with lines. Click one blue button, turn it green, then click the blue button on your target box.
      Use the resize handles at the corners to resize boxes.
      On the bottom of the screen, use "mark center" to fix yourself a return point.
      Shift+click any part of the header (including ✥) to multi-select boxes. Drag any selected box to move the group.
      Use the + and − buttons to increase or decrease font size inside the box.
    </p>
    <button id="closeHowToBtn">Close</button>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

  // Firebase config and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyCpp42OH-1mTZxu5iq44dmMQc8ahQdvnL0",
    authDomain: "stringsnthings-65aa0.firebaseapp.com",
    projectId: "stringsnthings-65aa0",
    storageBucket: "stringsnthings-65aa0.appspot.com",
    messagingSenderId: "35780192306",
    appId: "1:35780192306:web:80aedf9baea2ffac0cf42b"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // DOM elements
  const canvas = document.getElementById('canvas');
  const viewport = document.getElementById('viewport');
  const undoBtn = document.getElementById('undoBtn');
  const goCenterBtn = document.getElementById('goCenterBtn');
  const markCenterBtn = document.getElementById('markCenterBtn');
  const toggleEditModeBtn = document.getElementById('toggleEditModeBtn');
  const howToBtn = document.getElementById('howToBtn');
  const howToModal = document.getElementById('howToModal');
  const closeHowToBtn = document.getElementById('closeHowToBtn');
  const mapSelect = document.getElementById('mapSelect');
  const saveMapBtn = document.getElementById('saveMapBtn');
  const renameMapBtn = document.getElementById('renameMapBtn');
  const deleteMapBtn = document.getElementById('deleteMapBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const saveStatus = document.getElementById('saveStatus');
  const connectionLayer = document.getElementById('connectionLayer');

  // State
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX, startY;

  const undoStack = [];
  const connections = [];
  const boxesMap = new Map();

  let editMode = true;
  let connectionStartBoxId = null;
  const selectedBoxes = new Set();

  let currentMapId = null;
  let mapsCache = new Map(); // mapId => {name, boxes, connections, center}

  // Helpers

  function getClientCoords(e) {
    if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9);
  }

  // Transform & pan/zoom

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    drawConnections();
  }

  // Event handlers for panning and zooming

  viewport.addEventListener('pointerdown', e => {
    if (e.target.closest('.box-header') || [undoBtn, goCenterBtn, markCenterBtn, toggleEditModeBtn, howToBtn].includes(e.target) ||
        [saveMapBtn, renameMapBtn, deleteMapBtn, newMapBtn, mapSelect].includes(e.target)) return;
    isPanning = true;
    const coords = getClientCoords(e);
    startX = coords.x;
    startY = coords.y;
    viewport.setPointerCapture(e.pointerId);
    selectedBoxes.forEach(b => b.classList.remove('selected'));
    selectedBoxes.clear();
  });

  viewport.addEventListener('pointermove', e => {
    if (!isPanning) return;
    const coords = getClientCoords(e);
    panX += coords.x - startX;
    panY += coords.y - startY;
    startX = coords.x;
    startY = coords.y;
    updateTransform();
  });

  viewport.addEventListener('pointerup', e => {
    isPanning = false;
    viewport.releasePointerCapture(e.pointerId);
  });

  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3;

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.1;
    const dir = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
    let newScale = scale * dir;
    newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, newScale));

    // Zoom relative to mouse position
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    updateTransform();
  }, { passive: false });

  // Boxes management

  function createBox(id, x, y, w = 120, h = 60, text = '', fontSize = 14) {
    if (boxesMap.has(id)) return;

    const box = document.createElement('div');
    box.classList.add('box');
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
    box.dataset.id = id;

    // Header
    const header = document.createElement('div');
    header.className = 'box-header';

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = '✥';
    dragHandle.title = 'Drag box';
    header.appendChild(dragHandle);

    // Connect toggle button
    const connectBtn = document.createElement('button');
    connectBtn.className = 'connect-toggle';
    connectBtn.title = 'Connect box';
    header.appendChild(connectBtn);

    // Font size controls
    const fontDecBtn = document.createElement('button');
    fontDecBtn.textContent = '−';
    fontDecBtn.className = 'font-size-btn';
    fontDecBtn.title = 'Decrease font size';

    const fontIncBtn = document.createElement('button');
    fontIncBtn.textContent = '+';
    fontIncBtn.className = 'font-size-btn';
    fontIncBtn.title = 'Increase font size';

    header.appendChild(fontDecBtn);
    header.appendChild(fontIncBtn);

    // Delete button
    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.title = 'Delete box';
    delBtn.textContent = 'x';
    header.appendChild(delBtn);

    box.appendChild(header);

    // Content
    const content = document.createElement('div');
    content.className = 'box-content';
    content.contentEditable = editMode;
    content.style.fontSize = fontSize + 'px';
    content.textContent = text;
    box.appendChild(content);

    // Resize handles
    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
      const handle = document.createElement('div');
      handle.className = `resize-handle ${pos}`;
      box.appendChild(handle);
    });

    canvas.appendChild(box);
    boxesMap.set(id, { element: box, fontSize, connections: new Set() });

    // Event listeners

    // Drag box with drag handle
    let dragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    dragHandle.addEventListener('pointerdown', e => {
      if (!editMode) return;
      e.stopPropagation();
      dragging = true;
      const rect = box.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;

      // Multi-select drag starts here only if this box is selected
      if (!selectedBoxes.has(box)) {
        selectedBoxes.forEach(b => b.classList.remove('selected'));
        selectedBoxes.clear();
        selectedBoxes.add(box);
        box.classList.add('selected');
      }

      window.addEventListener('pointermove', onDrag);
      window.addEventListener('pointerup', onStopDrag);
    });

    function onDrag(e) {
      if (!dragging) return;
      e.preventDefault();
      const newX = (e.clientX - dragOffsetX - panX) / scale;
      const newY = (e.clientY - dragOffsetY - panY) / scale;

      // Move all selected boxes together
      selectedBoxes.forEach(b => {
        const id = b.dataset.id;
        const info = boxesMap.get(id);
        const boxRect = b.getBoundingClientRect();
        const dx = newX - parseFloat(b.style.left);
        const dy = newY - parseFloat(b.style.top);
        b.style.left = (parseFloat(b.style.left) + dx) + 'px';
        b.style.top = (parseFloat(b.style.top) + dy) + 'px';
      });
      drawConnections();
    }

    function onStopDrag(e) {
      if (!dragging) return;
      dragging = false;
      window.removeEventListener('pointermove', onDrag);
      window.removeEventListener('pointerup', onStopDrag);
      saveCurrentMap();
    }

    // Delete button
    delBtn.addEventListener('click', e => {
      e.stopPropagation();
      deleteBox(id);
    });

    // Connect toggle button
    connectBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      if (connectionStartBoxId === id) {
        // Cancel connect mode on same box
        connectionStartBoxId = null;
        connectBtn.classList.remove('active');
      } else if (connectionStartBoxId === null) {
        // Start connect mode
        connectionStartBoxId = id;
        connectBtn.classList.add('active');
      } else {
        // Connect to another box
        if (connectionStartBoxId !== id) {
          addConnection(connectionStartBoxId, id);
        }
        // Reset connect mode buttons
        resetConnectButtons();
        connectionStartBoxId = null;
      }
    });

    // Font size buttons
    fontIncBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      let fs = boxesMap.get(id).fontSize;
      if (fs < 30) fs++;
      boxesMap.get(id).fontSize = fs;
      content.style.fontSize = fs + 'px';
      saveCurrentMap();
    });
    fontDecBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (!editMode) return;
      let fs = boxesMap.get(id).fontSize;
      if (fs > 8) fs--;
      boxesMap.get(id).fontSize = fs;
      content.style.fontSize = fs + 'px';
      saveCurrentMap();
    });

    // Content editable change
    content.addEventListener('input', e => {
      if (!editMode) return;
      saveCurrentMap();
    });

    // Resize handling
    let resizing = false;
    let resizeDir = null;
    let startWidth, startHeight, startLeft, startTop;
    let resizeStartX, resizeStartY;

    box.querySelectorAll('.resize-handle').forEach(handle => {
      handle.addEventListener('pointerdown', e => {
        if (!editMode) return;
        e.stopPropagation();
        resizing = true;
        resizeDir = handle.classList.contains('nw') ? 'nw' :
                    handle.classList.contains('ne') ? 'ne' :
                    handle.classList.contains('sw') ? 'sw' : 'se';
        startWidth = box.offsetWidth;
        startHeight = box.offsetHeight;
        startLeft = parseFloat(box.style.left);
        startTop = parseFloat(box.style.top);
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        window.addEventListener('pointermove', onResize);
        window.addEventListener('pointerup', onStopResize);
      });
    });

    function onResize(e) {
      if (!resizing) return;
      e.preventDefault();
      const dx = (e.clientX - resizeStartX) / scale;
      const dy = (e.clientY - resizeStartY) / scale;
      let newW = startWidth;
      let newH = startHeight;
      let newLeft = startLeft;
      let newTop = startTop;

      if (resizeDir.includes('n')) {
        newH = startHeight - dy;
        newTop = startTop + dy;
        if (newH < 40) {
          newH = 40;
          newTop = startTop + (startHeight - 40);
        }
      }
      if (resizeDir.includes('s')) {
        newH = startHeight + dy;
        if (newH < 40) newH = 40;
      }
      if (resizeDir.includes('w')) {
        newW = startWidth - dx;
        newLeft = startLeft + dx;
        if (newW < 80) {
          newW = 80;
          newLeft = startLeft + (startWidth - 80);
        }
      }
      if (resizeDir.includes('e')) {
        newW = startWidth + dx;
        if (newW < 80) newW = 80;
      }

      box.style.width = newW + 'px';
      box.style.height = newH + 'px';
      box.style.left = newLeft + 'px';
      box.style.top = newTop + 'px';
      drawConnections();
    }

    function onStopResize(e) {
      if (!resizing) return;
      resizing = false;
      window.removeEventListener('pointermove', onResize);
      window.removeEventListener('pointerup', onStopResize);
      saveCurrentMap();
    }

    // Multi-select shift+click on header or drag handle
    header.addEventListener('click', e => {
      if (!e.shiftKey) return;
      e.preventDefault();
      if (selectedBoxes.has(box)) {
        selectedBoxes.delete(box);
        box.classList.remove('selected');
      } else {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });
    dragHandle.addEventListener('click', e => {
      if (!e.shiftKey) return;
      e.preventDefault();
      if (selectedBoxes.has(box)) {
        selectedBoxes.delete(box);
        box.classList.remove('selected');
      } else {
        selectedBoxes.add(box);
        box.classList.add('selected');
      }
    });

    return box;
  }

  function deleteBox(id) {
    const boxInfo = boxesMap.get(id);
    if (!boxInfo) return;
    const box = boxInfo.element;

    // Remove connections involving this box
    const toRemove = [];
    for (let i = connections.length -1; i >=0; i--) {
      const c = connections[i];
      if (c.from === id || c.to === id) {
        toRemove.push(i);
      }
    }
    toRemove.forEach(idx => connections.splice(idx,1));

    canvas.removeChild(box);
    boxesMap.delete(id);
    selectedBoxes.delete(box);
    undoStack.push({ action: 'delete', boxData: serializeBox(id) });
    undoBtn.disabled = false;
    drawConnections();
    saveCurrentMap();
  }

  function resetConnectButtons() {
    boxesMap.forEach(({element}) => {
      const btn = element.querySelector('.connect-toggle');
      if (btn) btn.classList.remove('active');
    });
  }

  function addConnection(fromId, toId) {
    if (fromId === toId) return;
    if (connections.find(c => c.from === fromId && c.to === toId)) return;
    connections.push({from: fromId, to: toId});
    saveCurrentMap();
    drawConnections();
  }

  function drawConnections() {
    while (connectionLayer.firstChild) connectionLayer.removeChild(connectionLayer.firstChild);
    connections.forEach(({from, to}) => {
      const fromBox = boxesMap.get(from);
      const toBox = boxesMap.get(to);
      if (!fromBox || !toBox) return;
      const fromEl = fromBox.element;
      const toEl = toBox.element;
      const fromRect = fromEl.getBoundingClientRect();
      const toRect = toEl.getBoundingClientRect();
      const parentRect = canvas.getBoundingClientRect();

      // Calculate center points relative to canvas
      const fromX = fromRect.left + fromRect.width / 2 - parentRect.left;
      const fromY = fromRect.top + fromRect.height / 2 - parentRect.top;
      const toX = toRect.left + toRect.width / 2 - parentRect.left;
      const toY = toRect.top + toRect.height / 2 - parentRect.top;

      const svgNS = "http://www.w3.org/2000/svg";
      const line = document.createElementNS(svgNS, 'line');
      line.setAttribute('x1', fromX);
      line.setAttribute('y1', fromY);
      line.setAttribute('x2', toX);
      line.setAttribute('y2', toY);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '2');
      connectionLayer.appendChild(line);
    });
  }

  // Serialize and deserialize for saving

  function serializeBox(id) {
    const boxInfo = boxesMap.get(id);
    if (!boxInfo) return null;
    const el = boxInfo.element;
    return {
      id,
      x: parseFloat(el.style.left),
      y: parseFloat(el.style.top),
      width: el.offsetWidth,
      height: el.offsetHeight,
      text: el.querySelector('.box-content').textContent,
      fontSize: boxInfo.fontSize,
    };
  }

  function deserializeBox(data) {
    createBox(data.id, data.x, data.y, data.width, data.height, data.text, data.fontSize);
  }

  // Save and load current map to Firebase

  async function saveCurrentMap() {
    if (!currentMapId) return;
    const boxesData = [];
    boxesMap.forEach((info, id) => {
      boxesData.push(serializeBox(id));
    });
    const mapData = {
      boxes: boxesData,
      connections,
      center: { panX, panY, scale }
    };
    try {
      await setDoc(doc(db, 'mindmaps', currentMapId), mapData);
      saveStatus.textContent = 'Saved';
      setTimeout(() => { if (saveStatus.textContent === 'Saved') saveStatus.textContent = ''; }, 3000);
      mapsCache.set(currentMapId, { name: mapSelect.value, ...mapData });
    } catch(e) {
      saveStatus.textContent = 'Error saving';
    }
  }

  async function loadMap(id) {
    clearAll();
    if (!id) return;
    try {
      const docSnap = await getDoc(doc(db, 'mindmaps', id));
      if (!docSnap.exists()) {
        alert('Map not found');
        return;
      }
      const data = docSnap.data();
      if (data.boxes) data.boxes.forEach(deserializeBox);
      if (data.connections) {
        connections.length = 0;
        data.connections.forEach(c => connections.push(c));
      }
      if (data.center) {
        panX = data.center.panX || 0;
        panY = data.center.panY || 0;
        scale = data.center.scale || 1;
      } else {
        panX = 0; panY = 0; scale = 1;
      }
      updateTransform();
      drawConnections();
      currentMapId = id;
      saveStatus.textContent = '';
    } catch(e) {
      alert('Error loading map');
    }
  }

  function clearAll() {
    boxesMap.forEach(({element}) => {
      canvas.removeChild(element);
    });
    boxesMap.clear();
    connections.length = 0;
    selectedBoxes.clear();
    undoStack.length = 0;
    undoBtn.disabled = true;
    resetConnectButtons();
    drawConnections();
  }

  // Load map list from Firebase

  async function loadMapList() {
    try {
      const querySnapshot = await getDocs(collection(db, 'mindmaps'));
      mapSelect.innerHTML = '';
      mapsCache.clear();
      querySnapshot.forEach(docSnap => {
        const id = docSnap.id;
        const data = docSnap.data();
        mapsCache.set(id, { name: id, ...data });
        const option = document.createElement('option');
        option.value = id;
        option.textContent = id;
        mapSelect.appendChild(option);
      });
      if (mapSelect.options.length > 0) {
        mapSelect.selectedIndex = 0;
        currentMapId = mapSelect.value;
        await loadMap(currentMapId);
      }
    } catch(e) {
      alert('Error loading map list');
    }
  }

  // Undo

  undoBtn.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const last = undoStack.pop();
    if (last.action === 'delete' && last.boxData) {
      deserializeBox(last.boxData);
      saveCurrentMap();
    }
    undoBtn.disabled = undoStack.length === 0;
  });

  // Buttons

  goCenterBtn.addEventListener('click', () => {
    panX = 0; panY = 0; scale = 1;
    updateTransform();
    saveCurrentMap();
  });
  markCenterBtn.addEventListener('click', () => {
    // Mark current view as center
    saveCurrentMap();
  });
  toggleEditModeBtn.addEventListener('click', () => {
    editMode = !editMode;
    boxesMap.forEach(({element}) => {
      element.querySelector('.box-content').contentEditable = editMode;
      element.querySelector('.connect-toggle').disabled = !editMode;
      element.querySelectorAll('.resize-handle').forEach(h => h.style.display = editMode ? 'block' : 'none');
      element.querySelector('.delete-btn').disabled = !editMode;
      element.querySelector('.font-size-btn').forEach ? 
        element.querySelectorAll('.font-size-btn').forEach(b => b.disabled = !editMode) : null;
    });
    toggleEditModeBtn.textContent = editMode ? 'Toggle Edit Mode' : 'View Mode';
  });

  howToBtn.addEventListener('click', () => {
    howToModal.style.display = 'block';
  });
  closeHowToBtn.addEventListener('click', () => {
    howToModal.style.display = 'none';
  });

  // New map button
  newMapBtn.addEventListener('click', async () => {
    const newId = prompt('Enter new map name (unique id):');
    if (!newId) return;
    if (mapsCache.has(newId)) {
      alert('Map name already exists');
      return;
    }
    clearAll();
    currentMapId = newId;
    mapSelect.value = newId;
    const option = document.createElement('option');
    option.value = newId;
    option.textContent = newId;
    mapSelect.appendChild(option);
    mapSelect.value = newId;
    await saveCurrentMap();
    loadMapList();
  });

  // Rename map button
  renameMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return alert('No map loaded');
    const newName = prompt('Enter new map name:', currentMapId);
    if (!newName || newName === currentMapId) return;
    if (mapsCache.has(newName)) {
      alert('Map name already exists');
      return;
    }
    // Save current map under new name and delete old
    await saveCurrentMap();
    const docRefOld = doc(db, 'mindmaps', currentMapId);
    const docRefNew = doc(db, 'mindmaps', newName);
    const data = mapsCache.get(currentMapId);
    await setDoc(docRefNew, data);
    await deleteDoc(docRefOld);
    mapsCache.delete(currentMapId);
    currentMapId = newName;
    loadMapList();
  });

  // Delete map button
  deleteMapBtn.addEventListener('click', async () => {
    if (!currentMapId) return alert('No map loaded');
    if (!confirm(`Delete map "${currentMapId}"? This action cannot be undone.`)) return;
    try {
      await deleteDoc(doc(db, 'mindmaps', currentMapId));
      mapsCache.delete(currentMapId);
      clearAll();
      currentMapId = null;
      loadMapList();
    } catch(e) {
      alert('Error deleting map');
    }
  });

  // Map select change
  mapSelect.addEventListener('change', async () => {
    const val = mapSelect.value;
    if (val !== currentMapId) {
      await loadMap(val);
    }
  });

  // Double click to create new box
  viewport.addEventListener('dblclick', e => {
    if (!editMode) return;
    if (e.target.closest('.box')) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / scale - 60;
    const y = (e.clientY - rect.top - panY) / scale - 30;
    const id = generateId();
    createBox(id, x, y);
    saveCurrentMap();
  });

  // Initialize
  (async () => {
    await loadMapList();
    updateTransform();
  })();
</script>
</body>
</html>
